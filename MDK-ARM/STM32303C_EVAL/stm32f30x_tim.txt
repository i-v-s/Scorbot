; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_tim.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3833     */
;;;3834   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;3835                          uint16_t TIM_ICFilter)
;;;3836   {
;;;3837     uint32_t tmpccmr1 = 0, tmpccer = 0;
;;;3838   
;;;3839     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3840     TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;3841     tmpccmr1 = TIMx->CCMR1;
00000a  6985              LDR      r5,[r0,#0x18]
;;;3842     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;3843   
;;;3844     /* Select the Input and set the filter */
;;;3845     tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
;;;3846     tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
00000e  ea421203          ORR      r2,r2,r3,LSL #4
000012  f02505f3          BIC      r5,r5,#0xf3           ;3845
000016  432a              ORRS     r2,r2,r5
;;;3847   
;;;3848     /* Select the Polarity and set the CC1E Bit */
;;;3849     tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000018  f024030a          BIC      r3,r4,#0xa
;;;3850     tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
00001c  430b              ORRS     r3,r3,r1
00001e  f0430101          ORR      r1,r3,#1
;;;3851   
;;;3852     /* Write to TIMx CCMR1 and CCER registers */
;;;3853     TIMx->CCMR1 = tmpccmr1;
000022  6182              STR      r2,[r0,#0x18]
;;;3854     TIMx->CCER = tmpccer;
000024  6201              STR      r1,[r0,#0x20]
;;;3855   }
000026  bd30              POP      {r4,r5,pc}
;;;3856   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3874     */
;;;3875   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;3876                          uint16_t TIM_ICFilter)
;;;3877   {
;;;3878     uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3879   
;;;3880     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3881     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f64f75ef          MOV      r5,#0xffef
000008  402c              ANDS     r4,r4,r5
00000a  6204              STR      r4,[r0,#0x20]
;;;3882     tmpccmr1 = TIMx->CCMR1;
00000c  6985              LDR      r5,[r0,#0x18]
;;;3883     tmpccer = TIMx->CCER;
00000e  6a04              LDR      r4,[r0,#0x20]
;;;3884     tmp = (uint16_t)(TIM_ICPolarity << 4);
;;;3885   
;;;3886     /* Select the Input and set the filter */
;;;3887     tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
000010  f4254573          BIC      r5,r5,#0xf300
;;;3888     tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
000014  ea453303          ORR      r3,r5,r3,LSL #12
;;;3889     tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);
000018  ea432202          ORR      r2,r3,r2,LSL #8
00001c  f64f76ff          MOV      r6,#0xffff            ;3884
000020  ea061101          AND      r1,r6,r1,LSL #4       ;3884
;;;3890   
;;;3891     /* Select the Polarity and set the CC2E Bit */
;;;3892     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000024  f64f735f          MOV      r3,#0xff5f
000028  401c              ANDS     r4,r4,r3
;;;3893     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
00002a  f0410110          ORR      r1,r1,#0x10
00002e  4321              ORRS     r1,r1,r4
;;;3894   
;;;3895     /* Write to TIMx CCMR1 and CCER registers */
;;;3896     TIMx->CCMR1 = tmpccmr1 ;
000030  6182              STR      r2,[r0,#0x18]
;;;3897     TIMx->CCER = tmpccer;
000032  6201              STR      r1,[r0,#0x20]
;;;3898   }
000034  bd70              POP      {r4-r6,pc}
;;;3899   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;526      */
;;;527    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;528    {
;;;529      /* Check the parameters */
;;;530      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;531      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;532    
;;;533      if (NewState != DISABLE)
;;;534      {
;;;535        /* Set the ARR Preload Bit */
;;;536        TIMx->CR1 |= TIM_CR1_ARPE;
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Reset the ARR Preload Bit */
;;;541        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410180          ORR      r1,r1,#0x80           ;536
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;536
;;;542      }
;;;543    }
000012  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;2708     */
;;;2709   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  b510              PUSH     {r4,lr}
;;;2710   {
;;;2711     /* Check the parameters */
;;;2712     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2713     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2714     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2715     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2716     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2717     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2718     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2719   
;;;2720     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2721        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2722     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  880a              LDRH     r2,[r1,#0]
000004  884b              LDRH     r3,[r1,#2]
000006  88cc              LDRH     r4,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  890b              LDRH     r3,[r1,#8]
000012  431a              ORRS     r2,r2,r3
000014  894b              LDRH     r3,[r1,#0xa]
000016  8989              LDRH     r1,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  430a              ORRS     r2,r2,r1
00001c  6442              STR      r2,[r0,#0x44]
;;;2723                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2724                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2725                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2726   }
00001e  bd10              POP      {r4,pc}
;;;2727   
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;2829     */
;;;2830   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;2831   {
;;;2832     /* Set the default configuration */
;;;2833     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;2834     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;2835     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;2836     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;2837     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;2838     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;2839     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;2840   }
000010  4770              BX       lr
;;;2841   
                          ENDP


                          AREA ||i.TIM_Break1Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Break1Cmd PROC
;;;2780     */
;;;2781   void TIM_Break1Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2782   {
;;;2783     /* Check the parameters */
;;;2784     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2785     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2786   
;;;2787     if (NewState != DISABLE)
;;;2788     {
;;;2789       /* Enable the Break1 */
;;;2790       TIMx->BDTR |= TIM_BDTR_BKE;
;;;2791     }
;;;2792     else
;;;2793     {
;;;2794       /* Disable the Break1 */
;;;2795       TIMx->BDTR &= (uint32_t)~TIM_BDTR_BKE;
000002  6c41              LDR      r1,[r0,#0x44]
000004  d002              BEQ      |L6.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;2790
00000a  e001              B        |L6.16|
                  |L6.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L6.16|
000010  6441              STR      r1,[r0,#0x44]         ;2790
;;;2796     } 
;;;2797   }
000012  4770              BX       lr
;;;2798   
                          ENDP


                          AREA ||i.TIM_Break1Config||, CODE, READONLY, ALIGN=1

                  TIM_Break1Config PROC
;;;2738     */
;;;2739   void TIM_Break1Config(TIM_TypeDef* TIMx, uint32_t TIM_Break1Polarity, uint8_t TIM_Break1Filter)
000000  6c43              LDR      r3,[r0,#0x44]
;;;2740   {   /* Check the parameters */
;;;2741     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2742     assert_param(IS_TIM_BREAK1_FILTER(TIM_Break1Filter));
;;;2743   
;;;2744     /* Reset the BKP and BKF Bits */
;;;2745     TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BKP | TIM_BDTR_BKF);
000002  f4232372          BIC      r3,r3,#0xf2000
000006  6443              STR      r3,[r0,#0x44]
;;;2746     /* Configure the Break1 polarity and filter */
;;;2747     TIMx->BDTR |=	TIM_Break1Polarity |((uint32_t)TIM_Break1Filter << 16);
000008  6c43              LDR      r3,[r0,#0x44]
00000a  ea414102          ORR      r1,r1,r2,LSL #16
00000e  430b              ORRS     r3,r3,r1
000010  6443              STR      r3,[r0,#0x44]
;;;2748   }
000012  4770              BX       lr
;;;2749   
                          ENDP


                          AREA ||i.TIM_Break2Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Break2Cmd PROC
;;;2805     */
;;;2806   void TIM_Break2Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2807   {
;;;2808     /* Check the parameters */
;;;2809     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2810     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2811   
;;;2812     if (NewState != DISABLE)
;;;2813     {
;;;2814       /* Enable the Break1 */
;;;2815       TIMx->BDTR |= TIM_BDTR_BK2E;
;;;2816     }
;;;2817     else
;;;2818     {
;;;2819       /* Disable the Break1 */
;;;2820       TIMx->BDTR &= (uint32_t)~TIM_BDTR_BK2E;
000002  6c41              LDR      r1,[r0,#0x44]
000004  d002              BEQ      |L8.12|
000006  f0417180          ORR      r1,r1,#0x1000000      ;2815
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f0217180          BIC      r1,r1,#0x1000000
                  |L8.16|
000010  6441              STR      r1,[r0,#0x44]         ;2815
;;;2821     }
;;;2822   }
000012  4770              BX       lr
;;;2823   
                          ENDP


                          AREA ||i.TIM_Break2Config||, CODE, READONLY, ALIGN=1

                  TIM_Break2Config PROC
;;;2760     */
;;;2761   void TIM_Break2Config(TIM_TypeDef* TIMx, uint32_t TIM_Break2Polarity, uint8_t TIM_Break2Filter)
000000  6c43              LDR      r3,[r0,#0x44]
;;;2762   {
;;;2763     /* Check the parameters */
;;;2764     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2765     assert_param(IS_TIM_BREAK2_FILTER(TIM_Break2Filter));
;;;2766   
;;;2767     /* Reset the BKP and BKF Bits */
;;;2768     TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BK2P | TIM_BDTR_BK2F);
000002  f023733c          BIC      r3,r3,#0x2f00000
000006  6443              STR      r3,[r0,#0x44]
;;;2769   
;;;2770     /* Configure the Break1 polarity and filter */
;;;2771     TIMx->BDTR |=	TIM_Break2Polarity |((uint32_t)TIM_Break2Filter << 20);
000008  6c43              LDR      r3,[r0,#0x44]
00000a  ea415102          ORR      r1,r1,r2,LSL #20
00000e  430b              ORRS     r3,r3,r1
000010  6443              STR      r3,[r0,#0x44]
;;;2772   }
000012  4770              BX       lr
;;;2773   
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;2898     */
;;;2899   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2900   { 
;;;2901     /* Check the parameters */
;;;2902     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2903     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2904     if (NewState != DISABLE)
;;;2905     {
;;;2906       /* Set the CCPC Bit */
;;;2907       TIMx->CR2 |= TIM_CR2_CCPC;
;;;2908     }
;;;2909     else
;;;2910     {
;;;2911       /* Reset the CCPC Bit */
;;;2912       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L10.12|
000006  f0410101          ORR      r1,r1,#1              ;2907
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  f64f72fe          MOV      r2,#0xfffe
000010  4011              ANDS     r1,r1,r2
                  |L10.18|
000012  6041              STR      r1,[r0,#4]            ;2907
;;;2913     }
;;;2914   }
000014  4770              BX       lr
;;;2915   /**
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;2278     */
;;;2279   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;2280   {
;;;2281     uint32_t tmp = 0;
;;;2282   
;;;2283     /* Check the parameters */
;;;2284     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2285     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2286     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2287   
;;;2288     tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;
000002  2301              MOVS     r3,#1
;;;2289   
;;;2290     /* Reset the CCxE Bit */
;;;2291     TIMx->CCER &= (uint32_t)(~tmp);
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;2288
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;2292   
;;;2293     /* Set or reset the CCxE Bit */ 
;;;2294     TIMx->CCER |=  ((uint32_t)TIM_CCx << (uint32_t)TIM_Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;2295   }
000014  bd10              POP      {r4,pc}
;;;2296   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2308     */
;;;2309   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2310   {
;;;2311     uint32_t tmp = 0;
;;;2312   
;;;2313     /* Check the parameters */
;;;2314     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2315     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2316     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2317   
;;;2318     tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;
000002  2304              MOVS     r3,#4
;;;2319   
;;;2320     /* Reset the CCxNE Bit */
;;;2321     TIMx->CCER &= (uint32_t) ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;2318
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;2322   
;;;2323     /* Set or reset the CCxNE Bit */ 
;;;2324     TIMx->CCER |=  ((uint32_t)TIM_CCxN << (uint32_t)TIM_Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;2325   }
000014  bd10              POP      {r4,pc}
;;;2326   /**
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;3072     */
;;;3073   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;3074   {  
;;;3075     /* Check the parameters */
;;;3076     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3077      
;;;3078     /* Clear the flags */
;;;3079     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  b289              UXTH     r1,r1
000004  6101              STR      r1,[r0,#0x10]
;;;3080   }
000006  4770              BX       lr
;;;3081   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;3141     */
;;;3142   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;3143   {
;;;3144     /* Check the parameters */
;;;3145     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3146   
;;;3147     /* Clear the IT pending Bit */
;;;3148     TIMx->SR = (uint16_t)~TIM_IT;
000002  b289              UXTH     r1,r1
000004  6101              STR      r1,[r0,#0x10]
;;;3149   }
000006  4770              BX       lr
;;;3150   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1834     */
;;;1835   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  6982              LDR      r2,[r0,#0x18]
;;;1836   {
;;;1837     uint32_t tmpccmr1 = 0;
;;;1838   
;;;1839     /* Check the parameters */
;;;1840     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1841     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1842   
;;;1843     tmpccmr1 = TIMx->CCMR1;
;;;1844   
;;;1845     /* Reset the OC1CE Bit */
;;;1846     tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1847   
;;;1848     /* Enable or Disable the Output Compare Clear Bit */
;;;1849     tmpccmr1 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1850   
;;;1851     /* Write to TIMx CCMR1 register */
;;;1852     TIMx->CCMR1 = tmpccmr1;
000008  6182              STR      r2,[r0,#0x18]
;;;1853   }
00000a  4770              BX       lr
;;;1854   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1864     */
;;;1865   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  6982              LDR      r2,[r0,#0x18]
;;;1866   {
;;;1867     uint32_t tmpccmr1 = 0;
;;;1868   
;;;1869     /* Check the parameters */
;;;1870     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1871     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1872   
;;;1873     tmpccmr1 = TIMx->CCMR1;
;;;1874   
;;;1875     /* Reset the OC2CE Bit */
;;;1876     tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2CE;
000002  f4224200          BIC      r2,r2,#0x8000
;;;1877   
;;;1878     /* Enable or Disable the Output Compare Clear Bit */
;;;1879     tmpccmr1 |= ((uint32_t)TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1880   
;;;1881     /* Write to TIMx CCMR1 register */
;;;1882     TIMx->CCMR1 = tmpccmr1;
00000a  6181              STR      r1,[r0,#0x18]
;;;1883   }
00000c  4770              BX       lr
;;;1884   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1893     */
;;;1894   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1895   {
;;;1896     uint32_t tmpccmr2 = 0;
;;;1897   
;;;1898     /* Check the parameters */
;;;1899     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1900     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1901   
;;;1902     tmpccmr2 = TIMx->CCMR2;
;;;1903   
;;;1904     /* Reset the OC3CE Bit */
;;;1905     tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1906   
;;;1907     /* Enable or Disable the Output Compare Clear Bit */
;;;1908     tmpccmr2 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1909   
;;;1910     /* Write to TIMx CCMR2 register */
;;;1911     TIMx->CCMR2 = tmpccmr2;
000008  61c2              STR      r2,[r0,#0x1c]
;;;1912   }
00000a  4770              BX       lr
;;;1913   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1922     */
;;;1923   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1924   {
;;;1925     uint32_t tmpccmr2 = 0;
;;;1926   
;;;1927     /* Check the parameters */
;;;1928     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1929     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1930   
;;;1931     tmpccmr2 = TIMx->CCMR2;
;;;1932   
;;;1933     /* Reset the OC4CE Bit */
;;;1934     tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4CE;
000002  f4224200          BIC      r2,r2,#0x8000
;;;1935   
;;;1936     /* Enable or Disable the Output Compare Clear Bit */
;;;1937     tmpccmr2 |= ((uint32_t)TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1938   
;;;1939     /* Write to TIMx CCMR2 register */
;;;1940     TIMx->CCMR2 = tmpccmr2;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;1941   }
00000c  4770              BX       lr
;;;1942   
                          ENDP


                          AREA ||i.TIM_ClearOC5Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC5Ref PROC
;;;1951     */
;;;1952   void TIM_ClearOC5Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1953   {
;;;1954     uint32_t tmpccmr3 = 0;
;;;1955   
;;;1956     /* Check the parameters */
;;;1957     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1958     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1959   
;;;1960     tmpccmr3 = TIMx->CCMR3;
;;;1961   
;;;1962     /* Reset the OC5CE Bit */
;;;1963     tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1964   
;;;1965     /* Enable or Disable the Output Compare Clear Bit */
;;;1966     tmpccmr3 |= (uint32_t)(TIM_OCClear);
000006  430a              ORRS     r2,r2,r1
;;;1967   
;;;1968     /* Write to TIMx CCMR3 register */
;;;1969     TIMx->CCMR3 = tmpccmr3;
000008  6542              STR      r2,[r0,#0x54]
;;;1970   }
00000a  4770              BX       lr
;;;1971   
                          ENDP


                          AREA ||i.TIM_ClearOC6Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC6Ref PROC
;;;1980     */
;;;1981   void TIM_ClearOC6Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1982   {
;;;1983     uint32_t tmpccmr3 = 0;
;;;1984   
;;;1985     /* Check the parameters */
;;;1986     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1987     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1988   
;;;1989     tmpccmr3 = TIMx->CCMR3;
;;;1990   
;;;1991     /* Reset the OC5CE Bit */
;;;1992     tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6CE;
000002  f4224200          BIC      r2,r2,#0x8000
;;;1993   
;;;1994     /* Enable or Disable the Output Compare Clear Bit */
;;;1995     tmpccmr3 |= ((uint32_t)TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1996   
;;;1997     /* Write to TIMx CCMR3 register */
;;;1998     TIMx->CCMR3 = tmpccmr3;
00000a  6541              STR      r1,[r0,#0x54]
;;;1999   }
00000c  4770              BX       lr
;;;2000   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;597      */
;;;598    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;599    {
;;;600      /* Check the parameters */
;;;601      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;602      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;603      
;;;604      if (NewState != DISABLE)
;;;605      {
;;;606        /* Enable the TIM Counter */
;;;607        TIMx->CR1 |= TIM_CR1_CEN;
;;;608      }
;;;609      else
;;;610      {
;;;611        /* Disable the TIM Counter */
;;;612        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L21.12|
000006  f0410101          ORR      r1,r1,#1              ;607
00000a  e001              B        |L21.16|
                  |L21.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L21.16|
000010  8001              STRH     r1,[r0,#0]            ;607
;;;613      }
;;;614    }
000012  4770              BX       lr
;;;615    /**
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;361      */
;;;362    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;363    {
;;;364      uint16_t tmpcr1 = 0;
;;;365    
;;;366      /* Check the parameters */
;;;367      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;368      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;369    
;;;370      tmpcr1 = TIMx->CR1;
;;;371    
;;;372      /* Reset the CMS and DIR Bits */
;;;373      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000002  f0220270          BIC      r2,r2,#0x70
;;;374    
;;;375      /* Set the Counter Mode */
;;;376      tmpcr1 |= TIM_CounterMode;
000006  430a              ORRS     r2,r2,r1
;;;377    
;;;378      /* Write to TIMx CR1 register */
;;;379      TIMx->CR1 = tmpcr1;
000008  8002              STRH     r2,[r0,#0]
;;;380    }
00000a  4770              BX       lr
;;;381    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;2848     */
;;;2849   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2850   {
;;;2851     /* Check the parameters */
;;;2852     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2853     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2854   
;;;2855     if (NewState != DISABLE)
;;;2856     {
;;;2857       /* Enable the TIM Main Output */
;;;2858       TIMx->BDTR |= TIM_BDTR_MOE;
;;;2859     }
;;;2860     else
;;;2861     {
;;;2862       /* Disable the TIM Main Output */
;;;2863       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000002  6c41              LDR      r1,[r0,#0x44]
000004  d002              BEQ      |L23.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;2858
00000a  e001              B        |L23.16|
                  |L23.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L23.16|
000010  6441              STR      r1,[r0,#0x44]         ;2858
;;;2864     }  
;;;2865   }
000012  4770              BX       lr
;;;2866   
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;3205     */
;;;3206   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;3207   { 
;;;3208     /* Check the parameters */
;;;3209     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3210     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;3211     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3212     
;;;3213     if (NewState != DISABLE)
;;;3214     {
;;;3215       /* Enable the DMA sources */
;;;3216       TIMx->DIER |= TIM_DMASource; 
;;;3217     }
;;;3218     else
;;;3219     {
;;;3220       /* Disable the DMA sources */
;;;3221       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  68c2              LDR      r2,[r0,#0xc]
000004  d001              BEQ      |L24.10|
000006  430a              ORRS     r2,r2,r1              ;3216
000008  e002              B        |L24.16|
                  |L24.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L24.16|
000010  60c2              STR      r2,[r0,#0xc]          ;3216
;;;3222     }
;;;3223   }
000012  4770              BX       lr
;;;3224   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;3178     */
;;;3179   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;3180   {
;;;3181     /* Check the parameters */
;;;3182     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;3183     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;3184     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;3185   
;;;3186     /* Set the DMA Base and the DMA Burst Length */
;;;3187     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;3188   }
000006  4770              BX       lr
;;;3189   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;198      */
;;;199    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  492e              LDR      r1,|L26.188|
;;;200    {
000002  b510              PUSH     {r4,lr}
;;;201      /* Check the parameters */
;;;202      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;203     
;;;204      if (TIMx == TIM1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L26.14|
;;;205      {
;;;206        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  14c4              ASRS     r4,r0,#19
;;;207        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
00000c  e04b              B        |L26.166|
                  |L26.14|
;;;208      } 
;;;209      else if (TIMx == TIM2) 
00000e  f1b04f80          CMP      r0,#0x40000000
000012  d009              BEQ      |L26.40|
;;;210      {     
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;213      }  
;;;214      else if (TIMx == TIM3)
000014  492a              LDR      r1,|L26.192|
000016  4288              CMP      r0,r1
000018  d10d              BNE      |L26.54|
;;;215      { 
;;;216        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000022  2100              MOVS     r1,#0
000024  2002              MOVS     r0,#2
000026  e023              B        |L26.112|
                  |L26.40|
000028  2101              MOVS     r1,#1                 ;211
00002a  4608              MOV      r0,r1                 ;211
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000030  2100              MOVS     r1,#0                 ;212
000032  2001              MOVS     r0,#1                 ;212
000034  e01c              B        |L26.112|
                  |L26.54|
;;;218      }  
;;;219      else if (TIMx == TIM4)
000036  4923              LDR      r1,|L26.196|
000038  4288              CMP      r0,r1
00003a  d106              BNE      |L26.74|
;;;220      { 
;;;221        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2004              MOVS     r0,#4
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
000044  2100              MOVS     r1,#0
000046  2004              MOVS     r0,#4
000048  e012              B        |L26.112|
                  |L26.74|
;;;223      }   
;;;224      else if (TIMx == TIM6)  
00004a  491f              LDR      r1,|L26.200|
00004c  4288              CMP      r0,r1
00004e  d106              BNE      |L26.94|
;;;225      {    
;;;226        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000050  2101              MOVS     r1,#1
000052  2010              MOVS     r0,#0x10
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2010              MOVS     r0,#0x10
00005c  e008              B        |L26.112|
                  |L26.94|
;;;228      }  
;;;229      else if (TIMx == TIM7)
00005e  491b              LDR      r1,|L26.204|
000060  4288              CMP      r0,r1
000062  d109              BNE      |L26.120|
;;;230      {      
;;;231        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
000064  2101              MOVS     r1,#1
000066  2020              MOVS     r0,#0x20
000068  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
00006c  2100              MOVS     r1,#0
00006e  2020              MOVS     r0,#0x20
                  |L26.112|
000070  e8bd4010          POP      {r4,lr}
000074  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L26.120|
;;;233      }  
;;;234      else if (TIMx == TIM8)
000078  4915              LDR      r1,|L26.208|
00007a  4288              CMP      r0,r1
00007c  d102              BNE      |L26.132|
;;;235      {      
;;;236        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
00007e  2101              MOVS     r1,#1
000080  1444              ASRS     r4,r0,#17
;;;237        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
000082  e010              B        |L26.166|
                  |L26.132|
;;;238      }    
;;;239      else if (TIMx == TIM15)
000084  4913              LDR      r1,|L26.212|
000086  4288              CMP      r0,r1
000088  d102              BNE      |L26.144|
;;;240      {      
;;;241        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
00008a  2101              MOVS     r1,#1
00008c  040c              LSLS     r4,r1,#16
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);  
00008e  e00a              B        |L26.166|
                  |L26.144|
;;;243      }  
;;;244      else if (TIMx == TIM16) 
000090  4911              LDR      r1,|L26.216|
000092  4288              CMP      r0,r1
000094  d102              BNE      |L26.156|
;;;245      {       
;;;246        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
000096  2101              MOVS     r1,#1
000098  044c              LSLS     r4,r1,#17
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);  
00009a  e004              B        |L26.166|
                  |L26.156|
;;;248      }  
;;;249      else
;;;250      { 
;;;251        if (TIMx == TIM17) 
00009c  490f              LDR      r1,|L26.220|
00009e  4288              CMP      r0,r1
0000a0  d10a              BNE      |L26.184|
;;;252        {     
;;;253          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  048c              LSLS     r4,r1,#18
                  |L26.166|
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;254          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
0000ac  4620              MOV      r0,r4
0000ae  e8bd4010          POP      {r4,lr}
0000b2  2100              MOVS     r1,#0
0000b4  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L26.184|
;;;255        }   
;;;256      }
;;;257    }
0000b8  bd10              POP      {r4,pc}
;;;258    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L26.188|
                          DCD      0x40012c00
                  |L26.192|
                          DCD      0x40000400
                  |L26.196|
                          DCD      0x40000800
                  |L26.200|
                          DCD      0x40001000
                  |L26.204|
                          DCD      0x40001400
                  |L26.208|
                          DCD      0x40013400
                  |L26.212|
                          DCD      0x40014000
                  |L26.216|
                          DCD      0x40014400
                  |L26.220|
                          DCD      0x40014800

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;3361     */
;;;3362   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;3363                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3364   {
000002  4604              MOV      r4,r0
;;;3365     uint16_t tmpsmcr = 0;
;;;3366   
;;;3367     /* Check the parameters */
;;;3368     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3369     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3370     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3371     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3372     /* Configure the ETR Clock source */
;;;3373     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;3374     
;;;3375     /* Get the TIMx SMCR register value */
;;;3376     tmpsmcr = TIMx->SMCR;
000008  68a0              LDR      r0,[r4,#8]
00000a  b280              UXTH     r0,r0
;;;3377   
;;;3378     /* Reset the SMS Bits */
;;;3379     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
;;;3380   
;;;3381     /* Select the External clock mode1 */
;;;3382     tmpsmcr |= TIM_SlaveMode_External1;
;;;3383   
;;;3384     /* Select the Trigger selection : ETRF */
;;;3385     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
;;;3386     tmpsmcr |= TIM_TS_ETRF;
00000c  f0400077          ORR      r0,r0,#0x77
;;;3387   
;;;3388     /* Write to TIMx SMCR */
;;;3389     TIMx->SMCR = tmpsmcr;
000010  60a0              STR      r0,[r4,#8]
;;;3390   }
000012  bd10              POP      {r4,pc}
;;;3391   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;3408     */
;;;3409   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b510              PUSH     {r4,lr}
;;;3410                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3411   {
000002  4604              MOV      r4,r0
;;;3412     /* Check the parameters */
;;;3413     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3414     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3415     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3416     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3417   
;;;3418     /* Configure the ETR Clock source */
;;;3419     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;3420   
;;;3421     /* Enable the External clock mode2 */
;;;3422     TIMx->SMCR |= TIM_SMCR_ECE;
000008  68a0              LDR      r0,[r4,#8]
00000a  f4404080          ORR      r0,r0,#0x4000
00000e  60a0              STR      r0,[r4,#8]
;;;3423   }
000010  bd10              POP      {r4,pc}
;;;3424   /**
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;3636     */
;;;3637   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;3638                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3639   {
;;;3640     uint16_t tmpsmcr = 0;
;;;3641   
;;;3642     /* Check the parameters */
;;;3643     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3644     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3645     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3646     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3647   
;;;3648     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;3649   
;;;3650     /* Reset the ETR Bits */
;;;3651     tmpsmcr &= SMCR_ETR_MASK;
;;;3652   
;;;3653     /* Set the Prescaler, the Filter value and the Polarity */
;;;3654     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000004  f64f75ff          MOV      r5,#0xffff
000008  ea052303          AND      r3,r5,r3,LSL #8
00000c  4313              ORRS     r3,r3,r2
00000e  b2e4              UXTB     r4,r4                 ;3651
000010  430b              ORRS     r3,r3,r1
000012  4323              ORRS     r3,r3,r4
;;;3655   
;;;3656     /* Write to TIMx SMCR */
;;;3657     TIMx->SMCR = tmpsmcr;
000014  6083              STR      r3,[r0,#8]
;;;3658   }
000016  bd30              POP      {r4,r5,pc}
;;;3659   /**
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3694     */
;;;3695   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b570              PUSH     {r4-r6,lr}
;;;3696                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3697   {
;;;3698     uint16_t tmpsmcr = 0;
;;;3699     uint16_t tmpccmr1 = 0;
;;;3700     uint16_t tmpccer = 0;
;;;3701       
;;;3702     /* Check the parameters */
;;;3703     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3704     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3705     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3706     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3707   
;;;3708     /* Get the TIMx SMCR register value */
;;;3709     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
000004  b2a5              UXTH     r5,r4
;;;3710   
;;;3711     /* Get the TIMx CCMR1 register value */
;;;3712     tmpccmr1 = TIMx->CCMR1;
000006  6984              LDR      r4,[r0,#0x18]
;;;3713   
;;;3714     /* Get the TIMx CCER register value */
;;;3715     tmpccer = TIMx->CCER;
000008  6a06              LDR      r6,[r0,#0x20]
00000a  b2a4              UXTH     r4,r4                 ;3712
;;;3716   
;;;3717     /* Set the encoder Mode */
;;;3718     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
00000c  f0250507          BIC      r5,r5,#7
;;;3719     tmpsmcr |= TIM_EncoderMode;
000010  430d              ORRS     r5,r5,r1
;;;3720   
;;;3721     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3722     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
000012  f64f41fc          MOV      r1,#0xfcfc
000016  400c              ANDS     r4,r4,r1
;;;3723     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000018  f2401101          MOV      r1,#0x101
00001c  430c              ORRS     r4,r4,r1
;;;3724   
;;;3725     /* Set the TI1 and the TI2 Polarities */
;;;3726     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
;;;3727     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00001e  f64f71ff          MOV      r1,#0xffff
000022  b2b6              UXTH     r6,r6                 ;3715
000024  ea011103          AND      r1,r1,r3,LSL #4
000028  f0260622          BIC      r6,r6,#0x22           ;3726
00002c  4311              ORRS     r1,r1,r2
00002e  4331              ORRS     r1,r1,r6
;;;3728   
;;;3729     /* Write to TIMx SMCR */
;;;3730     TIMx->SMCR = tmpsmcr;
000030  6085              STR      r5,[r0,#8]
;;;3731   
;;;3732     /* Write to TIMx CCMR1 */
;;;3733     TIMx->CCMR1 = tmpccmr1;
000032  6184              STR      r4,[r0,#0x18]
;;;3734   
;;;3735     /* Write to TIMx CCER */
;;;3736     TIMx->CCER = tmpccer;
000034  6201              STR      r1,[r0,#0x20]
;;;3737   }
000036  bd70              POP      {r4-r6,pc}
;;;3738   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=2

                  TIM_ForcedOC1Config PROC
;;;1368     */
;;;1369   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  6982              LDR      r2,[r0,#0x18]
;;;1370   {
;;;1371     uint32_t tmpccmr1 = 0;
;;;1372   
;;;1373     /* Check the parameters */
;;;1374     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1375     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1376     tmpccmr1 = TIMx->CCMR1;
;;;1377   
;;;1378     /* Reset the OC1M Bits */
;;;1379     tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1M;
000002  4b02              LDR      r3,|L31.12|
000004  401a              ANDS     r2,r2,r3
;;;1380   
;;;1381     /* Configure The Forced output Mode */
;;;1382     tmpccmr1 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1383   
;;;1384     /* Write to TIMx CCMR1 register */
;;;1385     TIMx->CCMR1 = tmpccmr1;
000008  6182              STR      r2,[r0,#0x18]
;;;1386   }
00000a  4770              BX       lr
;;;1387   
                          ENDP

                  |L31.12|
                          DCD      0xfffeff8f

                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=2

                  TIM_ForcedOC2Config PROC
;;;1397     */
;;;1398   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  6982              LDR      r2,[r0,#0x18]
;;;1399   {
;;;1400     uint32_t tmpccmr1 = 0;
;;;1401   
;;;1402     /* Check the parameters */
;;;1403     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1404     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1405     tmpccmr1 = TIMx->CCMR1;
;;;1406   
;;;1407     /* Reset the OC2M Bits */
;;;1408     tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2M;
000002  4b03              LDR      r3,|L32.16|
000004  401a              ANDS     r2,r2,r3
;;;1409   
;;;1410     /* Configure The Forced output Mode */
;;;1411     tmpccmr1 |= ((uint32_t)TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1412   
;;;1413     /* Write to TIMx CCMR1 register */
;;;1414     TIMx->CCMR1 = tmpccmr1;
00000a  6181              STR      r1,[r0,#0x18]
;;;1415   }
00000c  4770              BX       lr
;;;1416   
                          ENDP

00000e  0000              DCW      0x0000
                  |L32.16|
                          DCD      0xfeff8fff

                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1425     */
;;;1426   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1427   {
;;;1428     uint32_t tmpccmr2 = 0;
;;;1429   
;;;1430     /* Check the parameters */
;;;1431     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1432     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1433   
;;;1434     tmpccmr2 = TIMx->CCMR2;
;;;1435   
;;;1436     /* Reset the OC1M Bits */
;;;1437     tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1438   
;;;1439     /* Configure The Forced output Mode */
;;;1440     tmpccmr2 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1441   
;;;1442     /* Write to TIMx CCMR2 register */
;;;1443     TIMx->CCMR2 = tmpccmr2;
000008  61c2              STR      r2,[r0,#0x1c]
;;;1444   }
00000a  4770              BX       lr
;;;1445   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1454     */
;;;1455   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1456   {
;;;1457     uint32_t tmpccmr2 = 0;
;;;1458   
;;;1459     /* Check the parameters */
;;;1460     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1461     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1462     tmpccmr2 = TIMx->CCMR2;
;;;1463   
;;;1464     /* Reset the OC2M Bits */
;;;1465     tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4M;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1466   
;;;1467     /* Configure The Forced output Mode */
;;;1468     tmpccmr2 |= ((uint32_t)TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1469   
;;;1470     /* Write to TIMx CCMR2 register */
;;;1471     TIMx->CCMR2 = tmpccmr2;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;1472   }
00000c  4770              BX       lr
;;;1473   
                          ENDP


                          AREA ||i.TIM_ForcedOC5Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC5Config PROC
;;;1482     */
;;;1483   void TIM_ForcedOC5Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1484   {
;;;1485     uint32_t tmpccmr3 = 0;
;;;1486   
;;;1487     /* Check the parameters */
;;;1488     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1489     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1490     tmpccmr3 = TIMx->CCMR3;
;;;1491   
;;;1492     /* Reset the OC5M Bits */
;;;1493     tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1494   
;;;1495     /* Configure The Forced output Mode */
;;;1496     tmpccmr3 |= (uint32_t)(TIM_ForcedAction);
000006  430a              ORRS     r2,r2,r1
;;;1497   
;;;1498     /* Write to TIMx CCMR3 register */
;;;1499     TIMx->CCMR3 = tmpccmr3;
000008  6542              STR      r2,[r0,#0x54]
;;;1500   }
00000a  4770              BX       lr
;;;1501   
                          ENDP


                          AREA ||i.TIM_ForcedOC6Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC6Config PROC
;;;1510     */
;;;1511   void TIM_ForcedOC6Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1512   {
;;;1513     uint32_t tmpccmr3 = 0;
;;;1514   
;;;1515     /* Check the parameters */
;;;1516     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1517     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1518     tmpccmr3 = TIMx->CCMR3;
;;;1519   
;;;1520     /* Reset the OC6M Bits */
;;;1521     tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6M;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1522   
;;;1523     /* Configure The Forced output Mode */
;;;1524     tmpccmr3 |= ((uint32_t)TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1525   
;;;1526     /* Write to TIMx CCMR3 register */
;;;1527     TIMx->CCMR3 = tmpccmr3;
00000a  6541              STR      r1,[r0,#0x54]
;;;1528   }
00000c  4770              BX       lr
;;;1529   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2993     */
;;;2994   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  6141              STR      r1,[r0,#0x14]
;;;2995   { 
;;;2996     /* Check the parameters */
;;;2997     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2998     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2999    
;;;3000     /* Set the event sources */
;;;3001     TIMx->EGR = TIM_EventSource;
;;;3002   }
000002  4770              BX       lr
;;;3003   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2519     */
;;;2520   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  6b40              LDR      r0,[r0,#0x34]
;;;2521   {
;;;2522     /* Check the parameters */
;;;2523     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2524   
;;;2525     /* Get the Capture 1 Register value */
;;;2526     return TIMx->CCR1;
;;;2527   }
000002  4770              BX       lr
;;;2528   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2534     */
;;;2535   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  6b80              LDR      r0,[r0,#0x38]
;;;2536   {
;;;2537     /* Check the parameters */
;;;2538     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2539   
;;;2540     /* Get the Capture 2 Register value */
;;;2541     return TIMx->CCR2;
;;;2542   }
000002  4770              BX       lr
;;;2543   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2548     */
;;;2549   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2550   {
;;;2551     /* Check the parameters */
;;;2552     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2553   
;;;2554     /* Get the Capture 3 Register value */
;;;2555     return TIMx->CCR3;
;;;2556   }
000002  4770              BX       lr
;;;2557   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2562     */
;;;2563   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  6c00              LDR      r0,[r0,#0x40]
;;;2564   {
;;;2565     /* Check the parameters */
;;;2566     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2567   
;;;2568     /* Get the Capture 4 Register value */
;;;2569     return TIMx->CCR4;
;;;2570   }
000002  4770              BX       lr
;;;2571   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;416      */
;;;417    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  6a40              LDR      r0,[r0,#0x24]
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;421    
;;;422      /* Get the Counter Register value */
;;;423      return TIMx->CNT;
;;;424    }
000002  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;3028     */
;;;3029   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint32_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;3030   { 
;;;3031     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;3032     /* Check the parameters */
;;;3033     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3034     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;3035   
;;;3036     
;;;3037     if ((TIMx->SR & TIM_FLAG) != RESET)
000004  6912              LDR      r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L43.12|
;;;3038     {
;;;3039       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L43.12|
;;;3040     }
;;;3041     else
;;;3042     {
;;;3043       bitstatus = RESET;
;;;3044     }
;;;3045     return bitstatus;
;;;3046   }
00000c  4770              BX       lr
;;;3047   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;3100     */
;;;3101   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  4602              MOV      r2,r0
;;;3102   {
;;;3103     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;3104     uint16_t itstatus = 0x0, itenable = 0x0;
;;;3105     /* Check the parameters */
;;;3106     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3107     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;3108      
;;;3109     itstatus = TIMx->SR & TIM_IT;
000004  6913              LDR      r3,[r2,#0x10]
;;;3110     
;;;3111     itenable = TIMx->DIER & TIM_IT;
000006  68d2              LDR      r2,[r2,#0xc]
000008  420b              TST      r3,r1                 ;3109
00000a  ea020201          AND      r2,r2,r1
00000e  d002              BEQ      |L44.22|
;;;3112     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L44.22|
;;;3113     {
;;;3114       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L44.22|
;;;3115     }
;;;3116     else
;;;3117     {
;;;3118       bitstatus = RESET;
;;;3119     }
;;;3120     return bitstatus;
;;;3121   }
000016  4770              BX       lr
;;;3122   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;430      */
;;;431    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;432    {
;;;433      /* Check the parameters */
;;;434      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;435    
;;;436      /* Get the Prescaler Register value */
;;;437      return TIMx->PSC;
;;;438    }
000002  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;2390     */
;;;2391   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2392   {
000004  460d              MOV      r5,r1
;;;2393     /* Check the parameters */
;;;2394     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2395     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;2396     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;2397     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;2398     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;2399     
;;;2400     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  880e              LDRH     r6,[r1,#0]
;;;2401     {
;;;2402       /* TI1 Configuration */
;;;2403       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000008  8849              LDRH     r1,[r1,#2]
00000a  88aa              LDRH     r2,[r5,#4]
00000c  892b              LDRH     r3,[r5,#8]
00000e  4604              MOV      r4,r0                 ;2392
000010  b32e              CBZ      r6,|L46.94|
;;;2404                  TIM_ICInitStruct->TIM_ICSelection,
;;;2405                  TIM_ICInitStruct->TIM_ICFilter);
;;;2406       /* Set the Input Capture Prescaler value */
;;;2407       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2408     }
;;;2409     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000012  2e04              CMP      r6,#4
000014  d02b              BEQ      |L46.110|
;;;2410     {
;;;2411       /* TI2 Configuration */
;;;2412       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;2413                  TIM_ICInitStruct->TIM_ICSelection,
;;;2414                  TIM_ICInitStruct->TIM_ICFilter);
;;;2415       /* Set the Input Capture Prescaler value */
;;;2416       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2417     }
;;;2418     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000016  2e08              CMP      r6,#8
000018  6a26              LDR      r6,[r4,#0x20]
00001a  f64f70ff          MOV      r0,#0xffff
00001e  d02e              BEQ      |L46.126|
000020  f64e77ff          MOV      r7,#0xefff
000024  403e              ANDS     r6,r6,r7
000026  6226              STR      r6,[r4,#0x20]
000028  69e6              LDR      r6,[r4,#0x1c]
00002a  b2b7              UXTH     r7,r6
00002c  6a26              LDR      r6,[r4,#0x20]
00002e  ea002202          AND      r2,r0,r2,LSL #8
000032  ea003101          AND      r1,r0,r1,LSL #12
000036  f4274773          BIC      r7,r7,#0xf300
00003a  433a              ORRS     r2,r2,r7
00003c  ea003003          AND      r0,r0,r3,LSL #12
000040  4310              ORRS     r0,r0,r2
000042  b2b6              UXTH     r6,r6
000044  f4264220          BIC      r2,r6,#0xa000
000048  430a              ORRS     r2,r2,r1
00004a  f4425180          ORR      r1,r2,#0x1000
00004e  61e0              STR      r0,[r4,#0x1c]
000050  6221              STR      r1,[r4,#0x20]
;;;2419     {
;;;2420       /* TI3 Configuration */
;;;2421       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;2422                  TIM_ICInitStruct->TIM_ICSelection,
;;;2423                  TIM_ICInitStruct->TIM_ICFilter);
;;;2424       /* Set the Input Capture Prescaler value */
;;;2425       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2426     }
;;;2427     else
;;;2428     {
;;;2429       /* TI4 Configuration */
;;;2430       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;2431                  TIM_ICInitStruct->TIM_ICSelection,
;;;2432                  TIM_ICInitStruct->TIM_ICFilter);
;;;2433       /* Set the Input Capture Prescaler value */
;;;2434       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000052  88e9              LDRH     r1,[r5,#6]
000054  4620              MOV      r0,r4
000056  e8bd41f0          POP      {r4-r8,lr}
00005a  f7ffbffe          B.W      TIM_SetIC4Prescaler
                  |L46.94|
00005e  f7fffffe          BL       TI1_Config
000062  88e9              LDRH     r1,[r5,#6]            ;2407
000064  4620              MOV      r0,r4                 ;2407
000066  e8bd41f0          POP      {r4-r8,lr}            ;2407
00006a  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L46.110|
00006e  f7fffffe          BL       TI2_Config
000072  88e9              LDRH     r1,[r5,#6]            ;2416
000074  4620              MOV      r0,r4                 ;2416
000076  e8bd41f0          POP      {r4-r8,lr}            ;2416
00007a  f7ffbffe          B.W      TIM_SetIC2Prescaler
                  |L46.126|
00007e  f64f67ff          MOV      r7,#0xfeff            ;2416
000082  403e              ANDS     r6,r6,r7              ;2416
000084  6226              STR      r6,[r4,#0x20]         ;2416
000086  69e6              LDR      r6,[r4,#0x1c]         ;2416
000088  b2b7              UXTH     r7,r6                 ;2416
00008a  6a26              LDR      r6,[r4,#0x20]         ;2416
00008c  ea002101          AND      r1,r0,r1,LSL #8       ;2416
000090  ea001003          AND      r0,r0,r3,LSL #4       ;2416
000094  4310              ORRS     r0,r0,r2              ;2416
000096  f02707f3          BIC      r7,r7,#0xf3           ;2416
00009a  b2b6              UXTH     r6,r6                 ;2416
00009c  4338              ORRS     r0,r0,r7              ;2416
00009e  f4266220          BIC      r2,r6,#0xa00          ;2416
0000a2  430a              ORRS     r2,r2,r1              ;2416
0000a4  f4427180          ORR      r1,r2,#0x100          ;2416
0000a8  61e0              STR      r0,[r4,#0x1c]         ;2416
0000aa  6221              STR      r1,[r4,#0x20]         ;2416
0000ac  88e9              LDRH     r1,[r5,#6]            ;2425
0000ae  4620              MOV      r0,r4                 ;2425
0000b0  e8bd41f0          POP      {r4-r8,lr}            ;2425
0000b4  f7ffbffe          B.W      TIM_SetIC3Prescaler
;;;2435     }
;;;2436   }
;;;2437   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;2443     */
;;;2444   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;2445   {
;;;2446     /* Set the default configuration */
;;;2447     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;2448     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;2449     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;2450     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;2451     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;2452   }
00000e  4770              BX       lr
;;;2453   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2955     */
;;;2956   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2957   {  
;;;2958     /* Check the parameters */
;;;2959     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2960     assert_param(IS_TIM_IT(TIM_IT));
;;;2961     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2962     
;;;2963     if (NewState != DISABLE)
;;;2964     {
;;;2965       /* Enable the Interrupt sources */
;;;2966       TIMx->DIER |= TIM_IT;
;;;2967     }
;;;2968     else
;;;2969     {
;;;2970       /* Disable the Interrupt sources */
;;;2971       TIMx->DIER &= (uint16_t)~TIM_IT;
000002  68c2              LDR      r2,[r0,#0xc]
000004  d001              BEQ      |L48.10|
000006  430a              ORRS     r2,r2,r1              ;2966
000008  e002              B        |L48.16|
                  |L48.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L48.16|
000010  60c2              STR      r2,[r0,#0xc]          ;2966
;;;2972     }
;;;2973   }
000012  4770              BX       lr
;;;2974   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;3291     */
;;;3292   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b500              PUSH     {lr}
;;;3293   {
000002  4603              MOV      r3,r0
;;;3294     /* Check the parameters */
;;;3295     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3296     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;3297   
;;;3298     /* Select the Internal Trigger */
;;;3299     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000004  f7fffffe          BL       TIM_SelectInputTrigger
;;;3300   
;;;3301     /* Select the External clock mode1 */
;;;3302     TIMx->SMCR |= TIM_SlaveMode_External1;
000008  6898              LDR      r0,[r3,#8]
00000a  f0400007          ORR      r0,r0,#7
00000e  6098              STR      r0,[r3,#8]
;;;3303   }
000010  bd00              POP      {pc}
;;;3304   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;3270     */
;;;3271   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  6881              LDR      r1,[r0,#8]
;;;3272   {
;;;3273     /* Check the parameters */
;;;3274     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3275   
;;;3276     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3277     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;3278   }
00000a  4770              BX       lr
;;;3279   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1713     */
;;;1714   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  6982              LDR      r2,[r0,#0x18]
;;;1715   {
;;;1716     uint32_t tmpccmr1 = 0;
;;;1717   
;;;1718     /* Check the parameters */
;;;1719     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1720     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1721   
;;;1722     /* Get the TIMx CCMR1 register value */
;;;1723     tmpccmr1 = TIMx->CCMR1;
;;;1724   
;;;1725     /* Reset the OC1FE Bit */
;;;1726     tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1FE;
000002  f0220204          BIC      r2,r2,#4
;;;1727   
;;;1728     /* Enable or Disable the Output Compare Fast Bit */
;;;1729     tmpccmr1 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1730   
;;;1731     /* Write to TIMx CCMR1 */
;;;1732     TIMx->CCMR1 = tmpccmr1;
000008  6182              STR      r2,[r0,#0x18]
;;;1733   }
00000a  4770              BX       lr
;;;1734   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;675      */
;;;676    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;677    {
;;;678      uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;679       
;;;680      /* Check the parameters */
;;;681      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;682      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;683      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;684      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;685    
;;;686      /* Disable the Channel 1: Reset the CC1E Bit */
;;;687      TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  6202              STR      r2,[r0,#0x20]
;;;688      
;;;689      /* Get the TIMx CCER register value */
;;;690      tmpccer = TIMx->CCER;
00000a  6a05              LDR      r5,[r0,#0x20]
;;;691      /* Get the TIMx CR2 register value */
;;;692      tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;693      
;;;694      /* Get the TIMx CCMR1 register value */
;;;695      tmpccmrx = TIMx->CCMR1;
00000e  6982              LDR      r2,[r0,#0x18]
;;;696        
;;;697      /* Reset the Output Compare Mode Bits */
;;;698      tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
000010  4c17              LDR      r4,|L52.112|
000012  4022              ANDS     r2,r2,r4
;;;699      tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
;;;700      /* Select the Output Compare Mode */
;;;701      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000014  680c              LDR      r4,[r1,#0]
000016  f0220203          BIC      r2,r2,#3              ;699
00001a  4314              ORRS     r4,r4,r2
;;;702      
;;;703      /* Reset the Output Polarity level */
;;;704      tmpccer &= (uint32_t)~TIM_CCER_CC1P;
00001c  f0250202          BIC      r2,r5,#2
;;;705      /* Set the Output Compare Polarity */
;;;706      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000020  898d              LDRH     r5,[r1,#0xc]
000022  4315              ORRS     r5,r5,r2
;;;707      
;;;708      /* Set the Output State */
;;;709      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000024  888a              LDRH     r2,[r1,#4]
000026  432a              ORRS     r2,r2,r5
;;;710        
;;;711      if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
000028  4d12              LDR      r5,|L52.116|
00002a  42a8              CMP      r0,r5
00002c  d00b              BEQ      |L52.70|
00002e  4d12              LDR      r5,|L52.120|
000030  42a8              CMP      r0,r5
000032  d008              BEQ      |L52.70|
000034  4d11              LDR      r5,|L52.124|
000036  42a8              CMP      r0,r5
000038  d005              BEQ      |L52.70|
00003a  4d11              LDR      r5,|L52.128|
00003c  42a8              CMP      r0,r5
00003e  d002              BEQ      |L52.70|
000040  4d10              LDR      r5,|L52.132|
000042  42a8              CMP      r0,r5
000044  d10d              BNE      |L52.98|
                  |L52.70|
;;;712      {
;;;713        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;714        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;715        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;716        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;717        
;;;718        /* Reset the Output N Polarity level */
;;;719        tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
000046  f0220508          BIC      r5,r2,#8
;;;720        /* Set the Output N Polarity */
;;;721        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00004a  89ca              LDRH     r2,[r1,#0xe]
;;;722        /* Reset the Output N State */
;;;723        tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
;;;724        
;;;725        /* Set the Output N State */
;;;726        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
;;;727        /* Reset the Output Compare and Output Compare N IDLE State */
;;;728        tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
;;;729        tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
00004c  f4237340          BIC      r3,r3,#0x300
000050  432a              ORRS     r2,r2,r5              ;721
000052  f0220504          BIC      r5,r2,#4              ;723
000056  88ca              LDRH     r2,[r1,#6]            ;726
000058  432a              ORRS     r2,r2,r5              ;726
;;;730        /* Set the Output Idle state */
;;;731        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005a  8a0d              LDRH     r5,[r1,#0x10]
00005c  431d              ORRS     r5,r5,r3
;;;732        /* Set the Output N Idle state */
;;;733        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00005e  8a4b              LDRH     r3,[r1,#0x12]
000060  432b              ORRS     r3,r3,r5
                  |L52.98|
;;;734      }
;;;735      /* Write to TIMx CR2 */
;;;736      TIMx->CR2 = tmpcr2;
000062  6043              STR      r3,[r0,#4]
;;;737      
;;;738      /* Write to TIMx CCMR1 */
;;;739      TIMx->CCMR1 = tmpccmrx;
000064  6184              STR      r4,[r0,#0x18]
;;;740      
;;;741      /* Set the Capture Compare Register value */
;;;742      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000066  6889              LDR      r1,[r1,#8]
000068  6341              STR      r1,[r0,#0x34]
;;;743      
;;;744      /* Write to TIMx CCER */
;;;745      TIMx->CCER = tmpccer;
00006a  6202              STR      r2,[r0,#0x20]
;;;746    }
00006c  bd30              POP      {r4,r5,pc}
;;;747    
                          ENDP

00006e  0000              DCW      0x0000
                  |L52.112|
                          DCD      0xfffeff8f
                  |L52.116|
                          DCD      0x40012c00
                  |L52.120|
                          DCD      0x40013400
                  |L52.124|
                          DCD      0x40014000
                  |L52.128|
                          DCD      0x40014400
                  |L52.132|
                          DCD      0x40014800

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;2056     */
;;;2057   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2058   {
;;;2059     uint32_t tmpccer = 0;
;;;2060     /* Check the parameters */
;;;2061     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2062     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2063      
;;;2064     tmpccer = TIMx->CCER;
;;;2065   
;;;2066     /* Set or Reset the CC1NP Bit */
;;;2067     tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
000002  f0220208          BIC      r2,r2,#8
;;;2068     tmpccer |= TIM_OCNPolarity;
000006  430a              ORRS     r2,r2,r1
;;;2069   
;;;2070     /* Write to TIMx CCER register */
;;;2071     TIMx->CCER = tmpccer;
000008  6202              STR      r2,[r0,#0x20]
;;;2072   }
00000a  4770              BX       lr
;;;2073   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;2029     */
;;;2030   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2031   {
;;;2032     uint32_t tmpccer = 0;
;;;2033   
;;;2034     /* Check the parameters */
;;;2035     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2036     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2037   
;;;2038     tmpccer = TIMx->CCER;
;;;2039   
;;;2040     /* Set or Reset the CC1P Bit */
;;;2041     tmpccer &= (uint32_t)(~TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;2042     tmpccer |= TIM_OCPolarity;
000006  430a              ORRS     r2,r2,r1
;;;2043   
;;;2044     /* Write to TIMx CCER register */
;;;2045     TIMx->CCER = tmpccer;
000008  6202              STR      r2,[r0,#0x20]
;;;2046   }
00000a  4770              BX       lr
;;;2047   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1538     */
;;;1539   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  6982              LDR      r2,[r0,#0x18]
;;;1540   {
;;;1541     uint32_t tmpccmr1 = 0;
;;;1542   
;;;1543     /* Check the parameters */
;;;1544     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1545     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1546   
;;;1547     tmpccmr1 = TIMx->CCMR1;
;;;1548   
;;;1549     /* Reset the OC1PE Bit */
;;;1550     tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1551   
;;;1552     /* Enable or Disable the Output Compare Preload feature */
;;;1553     tmpccmr1 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1554   
;;;1555     /* Write to TIMx CCMR1 register */
;;;1556     TIMx->CCMR1 = tmpccmr1;
000008  6182              STR      r2,[r0,#0x18]
;;;1557   }
00000a  4770              BX       lr
;;;1558   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1744     */
;;;1745   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  6982              LDR      r2,[r0,#0x18]
;;;1746   {
;;;1747     uint32_t tmpccmr1 = 0;
;;;1748   
;;;1749     /* Check the parameters */
;;;1750     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1751     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1752   
;;;1753     /* Get the TIMx CCMR1 register value */
;;;1754     tmpccmr1 = TIMx->CCMR1;
;;;1755   
;;;1756     /* Reset the OC2FE Bit */
;;;1757     tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1758   
;;;1759     /* Enable or Disable the Output Compare Fast Bit */
;;;1760     tmpccmr1 |= ((uint32_t)TIM_OCFast << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1761   
;;;1762     /* Write to TIMx CCMR1 */
;;;1763     TIMx->CCMR1 = tmpccmr1;
00000a  6181              STR      r1,[r0,#0x18]
;;;1764   }
00000c  4770              BX       lr
;;;1765   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;755      */
;;;756    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;757    {
;;;758      uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;759       
;;;760      /* Check the parameters */
;;;761      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;762      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;763      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;764      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;765    
;;;766      /* Disable the Channel 2: Reset the CC2E Bit */
;;;767      TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;768      
;;;769      /* Get the TIMx CCER register value */  
;;;770      tmpccer = TIMx->CCER;
00000a  6a05              LDR      r5,[r0,#0x20]
;;;771      /* Get the TIMx CR2 register value */
;;;772      tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;773      
;;;774      /* Get the TIMx CCMR1 register value */
;;;775      tmpccmrx = TIMx->CCMR1;
00000e  6983              LDR      r3,[r0,#0x18]
;;;776        
;;;777      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;778      tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
000010  4c16              LDR      r4,|L57.108|
000012  4023              ANDS     r3,r3,r4
;;;779      tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
;;;780      
;;;781      /* Select the Output Compare Mode */
;;;782      tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000014  680c              LDR      r4,[r1,#0]
000016  f4237340          BIC      r3,r3,#0x300          ;779
00001a  ea432404          ORR      r4,r3,r4,LSL #8
;;;783      
;;;784      /* Reset the Output Polarity level */
;;;785      tmpccer &= (uint32_t)~TIM_CCER_CC2P;
00001e  f0250320          BIC      r3,r5,#0x20
;;;786      /* Set the Output Compare Polarity */
;;;787      tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
000022  898d              LDRH     r5,[r1,#0xc]
000024  ea431305          ORR      r3,r3,r5,LSL #4
;;;788      
;;;789      /* Set the Output State */
;;;790      tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
000028  888d              LDRH     r5,[r1,#4]
00002a  ea431305          ORR      r3,r3,r5,LSL #4
;;;791        
;;;792      if((TIMx == TIM1) || (TIMx == TIM8))
00002e  4d10              LDR      r5,|L57.112|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L57.58|
000034  4d0f              LDR      r5,|L57.116|
000036  42a8              CMP      r0,r5
000038  d111              BNE      |L57.94|
                  |L57.58|
;;;793      {
;;;794        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;795        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;796        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;797        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;798        
;;;799        /* Reset the Output N Polarity level */
;;;800        tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
;;;801        /* Set the Output N Polarity */
;;;802        tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
00003a  89cd              LDRH     r5,[r1,#0xe]
00003c  f0230380          BIC      r3,r3,#0x80           ;800
000040  ea431305          ORR      r3,r3,r5,LSL #4
;;;803        /* Reset the Output N State */
;;;804        tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
;;;805        
;;;806        /* Set the Output N State */
;;;807        tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
000044  88cd              LDRH     r5,[r1,#6]
000046  f0230340          BIC      r3,r3,#0x40           ;804
00004a  ea431305          ORR      r3,r3,r5,LSL #4
;;;808        /* Reset the Output Compare and Output Compare N IDLE State */
;;;809        tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
;;;810        tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
;;;811        /* Set the Output Idle state */
;;;812        tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
00004e  8a0d              LDRH     r5,[r1,#0x10]
000050  f4226240          BIC      r2,r2,#0xc00          ;810
000054  ea420285          ORR      r2,r2,r5,LSL #2
;;;813        /* Set the Output N Idle state */
;;;814        tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
000058  8a4d              LDRH     r5,[r1,#0x12]
00005a  ea420285          ORR      r2,r2,r5,LSL #2
                  |L57.94|
;;;815      }
;;;816      /* Write to TIMx CR2 */
;;;817      TIMx->CR2 = tmpcr2;
00005e  6042              STR      r2,[r0,#4]
;;;818      
;;;819      /* Write to TIMx CCMR1 */
;;;820      TIMx->CCMR1 = tmpccmrx;
000060  6184              STR      r4,[r0,#0x18]
;;;821      
;;;822      /* Set the Capture Compare Register value */
;;;823      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000062  6889              LDR      r1,[r1,#8]
000064  6381              STR      r1,[r0,#0x38]
;;;824      
;;;825      /* Write to TIMx CCER */
;;;826      TIMx->CCER = tmpccer;
000066  6203              STR      r3,[r0,#0x20]
;;;827    }
000068  bd30              POP      {r4,r5,pc}
;;;828    
                          ENDP

00006a  0000              DCW      0x0000
                  |L57.108|
                          DCD      0xfeff8fff
                  |L57.112|
                          DCD      0x40012c00
                  |L57.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;2110     */
;;;2111   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2112   {
;;;2113     uint32_t tmpccer = 0;
;;;2114   
;;;2115     /* Check the parameters */
;;;2116     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2117     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2118     
;;;2119     tmpccer = TIMx->CCER;
;;;2120   
;;;2121     /* Set or Reset the CC2NP Bit */
;;;2122     tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
000002  f0220280          BIC      r2,r2,#0x80
;;;2123     tmpccer |= ((uint32_t)TIM_OCNPolarity << 4);
000006  ea421101          ORR      r1,r2,r1,LSL #4
;;;2124   
;;;2125     /* Write to TIMx CCER register */
;;;2126     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2127   }
00000c  4770              BX       lr
;;;2128   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;2083     */
;;;2084   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2085   {
;;;2086     uint32_t tmpccer = 0;
;;;2087   
;;;2088     /* Check the parameters */
;;;2089     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2090     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2091   
;;;2092     tmpccer = TIMx->CCER;
;;;2093   
;;;2094     /* Set or Reset the CC2P Bit */
;;;2095     tmpccer &= (uint32_t)(~TIM_CCER_CC2P);
000002  f0220220          BIC      r2,r2,#0x20
;;;2096     tmpccer |= ((uint32_t)TIM_OCPolarity << 4);
000006  ea421101          ORR      r1,r2,r1,LSL #4
;;;2097   
;;;2098     /* Write to TIMx CCER register */
;;;2099     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2100   }
00000c  4770              BX       lr
;;;2101   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1568     */
;;;1569   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  6982              LDR      r2,[r0,#0x18]
;;;1570   {
;;;1571     uint32_t tmpccmr1 = 0;
;;;1572   
;;;1573     /* Check the parameters */
;;;1574     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1575     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1576   
;;;1577     tmpccmr1 = TIMx->CCMR1;
;;;1578   
;;;1579     /* Reset the OC2PE Bit */
;;;1580     tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1581   
;;;1582     /* Enable or Disable the Output Compare Preload feature */
;;;1583     tmpccmr1 |= ((uint32_t)TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1584   
;;;1585     /* Write to TIMx CCMR1 register */
;;;1586     TIMx->CCMR1 = tmpccmr1;
00000a  6181              STR      r1,[r0,#0x18]
;;;1587   }
00000c  4770              BX       lr
;;;1588   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1774     */
;;;1775   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1776   {
;;;1777     uint32_t tmpccmr2 = 0;
;;;1778     
;;;1779     /* Check the parameters */
;;;1780     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1781     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1782   
;;;1783     /* Get the TIMx CCMR2 register value */
;;;1784     tmpccmr2 = TIMx->CCMR2;
;;;1785   
;;;1786     /* Reset the OC3FE Bit */
;;;1787     tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3FE;
000002  f0220204          BIC      r2,r2,#4
;;;1788   
;;;1789     /* Enable or Disable the Output Compare Fast Bit */
;;;1790     tmpccmr2 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1791   
;;;1792     /* Write to TIMx CCMR2 */
;;;1793     TIMx->CCMR2 = tmpccmr2;
000008  61c2              STR      r2,[r0,#0x1c]
;;;1794   }
00000a  4770              BX       lr
;;;1795   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;836      */
;;;837    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;838    {
;;;839      uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;840       
;;;841      /* Check the parameters */
;;;842      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;843      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;844      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;845      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;846    
;;;847      /* Disable the Channel 3: Reset the CC2E Bit */
;;;848      TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  6202              STR      r2,[r0,#0x20]
;;;849      
;;;850      /* Get the TIMx CCER register value */
;;;851      tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;852      /* Get the TIMx CR2 register value */
;;;853      tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;854      
;;;855      /* Get the TIMx CCMR2 register value */
;;;856      tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;857        
;;;858      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;859      tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
;;;860      tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
;;;861      /* Select the Output Compare Mode */
;;;862      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;863      
;;;864      /* Reset the Output Polarity level */
;;;865      tmpccer &= (uint32_t)~TIM_CCER_CC3P;
000010  f4237300          BIC      r3,r3,#0x200
000014  f0240573          BIC      r5,r4,#0x73           ;860
000018  680c              LDR      r4,[r1,#0]            ;862
00001a  432c              ORRS     r4,r4,r5              ;862
;;;866      /* Set the Output Compare Polarity */
;;;867      tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
00001c  898d              LDRH     r5,[r1,#0xc]
00001e  ea432305          ORR      r3,r3,r5,LSL #8
;;;868      
;;;869      /* Set the Output State */
;;;870      tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
000022  888d              LDRH     r5,[r1,#4]
000024  ea432305          ORR      r3,r3,r5,LSL #8
;;;871        
;;;872      if((TIMx == TIM1) || (TIMx == TIM8))
000028  4d0e              LDR      r5,|L62.100|
00002a  42a8              CMP      r0,r5
00002c  d002              BEQ      |L62.52|
00002e  4d0e              LDR      r5,|L62.104|
000030  42a8              CMP      r0,r5
000032  d111              BNE      |L62.88|
                  |L62.52|
;;;873      {
;;;874        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;875        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;876        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;877        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;878        
;;;879        /* Reset the Output N Polarity level */
;;;880        tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
;;;881        /* Set the Output N Polarity */
;;;882        tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
000034  89cd              LDRH     r5,[r1,#0xe]
000036  f4236300          BIC      r3,r3,#0x800          ;880
00003a  ea432305          ORR      r3,r3,r5,LSL #8
;;;883        /* Reset the Output N State */
;;;884        tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
;;;885        
;;;886        /* Set the Output N State */
;;;887        tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
00003e  88cd              LDRH     r5,[r1,#6]
000040  f4236380          BIC      r3,r3,#0x400          ;884
000044  ea432305          ORR      r3,r3,r5,LSL #8
;;;888        /* Reset the Output Compare and Output Compare N IDLE State */
;;;889        tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
;;;890        tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
;;;891        /* Set the Output Idle state */
;;;892        tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
000048  8a0d              LDRH     r5,[r1,#0x10]
00004a  f4225240          BIC      r2,r2,#0x3000         ;890
00004e  ea421205          ORR      r2,r2,r5,LSL #4
;;;893        /* Set the Output N Idle state */
;;;894        tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
000052  8a4d              LDRH     r5,[r1,#0x12]
000054  ea421205          ORR      r2,r2,r5,LSL #4
                  |L62.88|
;;;895      }
;;;896      /* Write to TIMx CR2 */
;;;897      TIMx->CR2 = tmpcr2;
000058  6042              STR      r2,[r0,#4]
;;;898      
;;;899      /* Write to TIMx CCMR2 */
;;;900      TIMx->CCMR2 = tmpccmrx;
00005a  61c4              STR      r4,[r0,#0x1c]
;;;901      
;;;902      /* Set the Capture Compare Register value */
;;;903      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00005c  6889              LDR      r1,[r1,#8]
00005e  63c1              STR      r1,[r0,#0x3c]
;;;904      
;;;905      /* Write to TIMx CCER */
;;;906      TIMx->CCER = tmpccer;
000060  6203              STR      r3,[r0,#0x20]
;;;907    }
000062  bd30              POP      {r4,r5,pc}
;;;908    
                          ENDP

                  |L62.100|
                          DCD      0x40012c00
                  |L62.104|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;2164     */
;;;2165   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2166   {
;;;2167     uint32_t tmpccer = 0;
;;;2168    
;;;2169     /* Check the parameters */
;;;2170     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2171     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2172       
;;;2173     tmpccer = TIMx->CCER;
;;;2174   
;;;2175     /* Set or Reset the CC3NP Bit */
;;;2176     tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
000002  f4226200          BIC      r2,r2,#0x800
;;;2177     tmpccer |= ((uint32_t)TIM_OCNPolarity << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;2178   
;;;2179     /* Write to TIMx CCER register */
;;;2180     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2181   }
00000c  4770              BX       lr
;;;2182   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;2137     */
;;;2138   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2139   {
;;;2140     uint32_t tmpccer = 0;
;;;2141   
;;;2142     /* Check the parameters */
;;;2143     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2144     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2145   
;;;2146     tmpccer = TIMx->CCER;
;;;2147   
;;;2148     /* Set or Reset the CC3P Bit */
;;;2149     tmpccer &= (uint32_t)~TIM_CCER_CC3P;
000002  f4227200          BIC      r2,r2,#0x200
;;;2150     tmpccer |= ((uint32_t)TIM_OCPolarity << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;2151   
;;;2152     /* Write to TIMx CCER register */
;;;2153     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2154   }
00000c  4770              BX       lr
;;;2155   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1597     */
;;;1598   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1599   {
;;;1600     uint32_t tmpccmr2 = 0;
;;;1601   
;;;1602     /* Check the parameters */
;;;1603     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1604     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1605   
;;;1606     tmpccmr2 = TIMx->CCMR2;
;;;1607   
;;;1608     /* Reset the OC3PE Bit */
;;;1609     tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1610   
;;;1611     /* Enable or Disable the Output Compare Preload feature */
;;;1612     tmpccmr2 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1613   
;;;1614     /* Write to TIMx CCMR2 register */
;;;1615     TIMx->CCMR2 = tmpccmr2;
000008  61c2              STR      r2,[r0,#0x1c]
;;;1616   }
00000a  4770              BX       lr
;;;1617   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1804     */
;;;1805   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1806   {
;;;1807     uint32_t tmpccmr2 = 0;
;;;1808   
;;;1809     /* Check the parameters */
;;;1810     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1811     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1812   
;;;1813     /* Get the TIMx CCMR2 register value */
;;;1814     tmpccmr2 = TIMx->CCMR2;
;;;1815   
;;;1816     /* Reset the OC4FE Bit */
;;;1817     tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1818   
;;;1819     /* Enable or Disable the Output Compare Fast Bit */
;;;1820     tmpccmr2 |= ((uint32_t)TIM_OCFast << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1821   
;;;1822     /* Write to TIMx CCMR2 */
;;;1823     TIMx->CCMR2 = tmpccmr2;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;1824   }
00000c  4770              BX       lr
;;;1825   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;916      */
;;;917    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;918    {
;;;919      uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;920       
;;;921      /* Check the parameters */
;;;922      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;923      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;924      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;925      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;926    
;;;927      /* Disable the Channel 4: Reset the CC4E Bit */
;;;928      TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  6202              STR      r2,[r0,#0x20]
;;;929      
;;;930      /* Get the TIMx CCER register value */
;;;931      tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;932      /* Get the TIMx CR2 register value */
;;;933      tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;934      
;;;935      /* Get the TIMx CCMR2 register value */
;;;936      tmpccmrx = TIMx->CCMR2;
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;937        
;;;938      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;939      tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
;;;940      tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
;;;941      
;;;942      /* Select the Output Compare Mode */
;;;943      tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000010  680d              LDR      r5,[r1,#0]
000012  f42343e6          BIC      r3,r3,#0x7300         ;940
000016  ea432305          ORR      r3,r3,r5,LSL #8
;;;944      
;;;945      /* Reset the Output Polarity level */
;;;946      tmpccer &= (uint32_t)~TIM_CCER_CC4P;
;;;947      /* Set the Output Compare Polarity */
;;;948      tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
00001a  898d              LDRH     r5,[r1,#0xc]
00001c  f4245400          BIC      r4,r4,#0x2000         ;946
000020  ea443405          ORR      r4,r4,r5,LSL #12
;;;949      
;;;950      /* Set the Output State */
;;;951      tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
000024  888d              LDRH     r5,[r1,#4]
000026  ea443405          ORR      r4,r4,r5,LSL #12
;;;952      
;;;953      if((TIMx == TIM1) || (TIMx == TIM8))
00002a  4d08              LDR      r5,|L67.76|
00002c  42a8              CMP      r0,r5
00002e  d002              BEQ      |L67.54|
000030  4d07              LDR      r5,|L67.80|
000032  42a8              CMP      r0,r5
000034  d104              BNE      |L67.64|
                  |L67.54|
;;;954      {
;;;955        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;956        /* Reset the Output Compare IDLE State */
;;;957        tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
;;;958        /* Set the Output Idle state */
;;;959        tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
000036  8a0d              LDRH     r5,[r1,#0x10]
000038  f4224280          BIC      r2,r2,#0x4000         ;957
00003c  ea421285          ORR      r2,r2,r5,LSL #6
                  |L67.64|
;;;960      }
;;;961      /* Write to TIMx CR2 */
;;;962      TIMx->CR2 = tmpcr2;
000040  6042              STR      r2,[r0,#4]
;;;963      
;;;964      /* Write to TIMx CCMR2 */  
;;;965      TIMx->CCMR2 = tmpccmrx;
000042  61c3              STR      r3,[r0,#0x1c]
;;;966        
;;;967      /* Set the Capture Compare Register value */
;;;968      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000044  6889              LDR      r1,[r1,#8]
000046  6401              STR      r1,[r0,#0x40]
;;;969      
;;;970      /* Write to TIMx CCER */
;;;971      TIMx->CCER = tmpccer;
000048  6204              STR      r4,[r0,#0x20]
;;;972    }
00004a  bd30              POP      {r4,r5,pc}
;;;973    
                          ENDP

                  |L67.76|
                          DCD      0x40012c00
                  |L67.80|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;2191     */
;;;2192   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2193   {
;;;2194     uint32_t tmpccer = 0;
;;;2195   
;;;2196     /* Check the parameters */
;;;2197     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2198     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2199   
;;;2200     tmpccer = TIMx->CCER;
;;;2201   
;;;2202     /* Set or Reset the CC4P Bit */
;;;2203     tmpccer &= (uint32_t)~TIM_CCER_CC4P;
000002  f4225200          BIC      r2,r2,#0x2000
;;;2204     tmpccer |= ((uint32_t)TIM_OCPolarity << 12);
000006  ea423101          ORR      r1,r2,r1,LSL #12
;;;2205   
;;;2206     /* Write to TIMx CCER register */
;;;2207     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2208   }
00000c  4770              BX       lr
;;;2209   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1626     */
;;;1627   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;1628   {
;;;1629     uint32_t tmpccmr2 = 0;
;;;1630   
;;;1631     /* Check the parameters */
;;;1632     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1633     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1634   
;;;1635     tmpccmr2 = TIMx->CCMR2;
;;;1636   
;;;1637     /* Reset the OC4PE Bit */
;;;1638     tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1639   
;;;1640     /* Enable or Disable the Output Compare Preload feature */
;;;1641     tmpccmr2 |= ((uint32_t)TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1642   
;;;1643     /* Write to TIMx CCMR2 register */
;;;1644     TIMx->CCMR2 = tmpccmr2;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;1645   }
00000c  4770              BX       lr
;;;1646   
                          ENDP


                          AREA ||i.TIM_OC5Init||, CODE, READONLY, ALIGN=2

                  TIM_OC5Init PROC
;;;981      */
;;;982    void TIM_OC5Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;983    {
;;;984      uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;985       
;;;986      /* Check the parameters */
;;;987      assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
;;;988      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;989      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;990      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;991    
;;;992      /* Disable the Channel 5: Reset the CC5E Bit */
;;;993      TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4223280          BIC      r2,r2,#0x10000
000008  6202              STR      r2,[r0,#0x20]
;;;994      
;;;995      /* Get the TIMx CCER register value */
;;;996      tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;997      /* Get the TIMx CR2 register value */
;;;998      tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;999      
;;;1000     /* Get the TIMx CCMR3 register value */
;;;1001     tmpccmrx = TIMx->CCMR3;
00000e  6d44              LDR      r4,[r0,#0x54]
;;;1002     
;;;1003     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;1004     tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
;;;1005     
;;;1006     /* Select the Output Compare Mode */
;;;1007     tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
000010  680d              LDR      r5,[r1,#0]
000012  f0240470          BIC      r4,r4,#0x70           ;1004
000016  4325              ORRS     r5,r5,r4
;;;1008     
;;;1009     /* Reset the Output Polarity level */
;;;1010     tmpccer &= (uint32_t)~TIM_CCER_CC5P;
;;;1011     /* Set the Output Compare Polarity */
;;;1012     tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
000018  898c              LDRH     r4,[r1,#0xc]
00001a  f4233300          BIC      r3,r3,#0x20000        ;1010
00001e  ea434304          ORR      r3,r3,r4,LSL #16
;;;1013   
;;;1014     /* Set the Output State */
;;;1015     tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
000022  888c              LDRH     r4,[r1,#4]
000024  ea434304          ORR      r3,r3,r4,LSL #16
;;;1016     
;;;1017     if((TIMx == TIM1) || (TIMx == TIM8))
000028  4c08              LDR      r4,|L70.76|
00002a  42a0              CMP      r0,r4
00002c  d002              BEQ      |L70.52|
00002e  4c08              LDR      r4,|L70.80|
000030  42a0              CMP      r0,r4
000032  d104              BNE      |L70.62|
                  |L70.52|
;;;1018     {
;;;1019       assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;1020       /* Reset the Output Compare IDLE State */
;;;1021       tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
;;;1022       /* Set the Output Idle state */
;;;1023       tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
000034  8a0c              LDRH     r4,[r1,#0x10]
000036  f4223280          BIC      r2,r2,#0x10000        ;1021
00003a  ea424204          ORR      r2,r2,r4,LSL #16
                  |L70.62|
;;;1024     }
;;;1025     /* Write to TIMx CR2 */
;;;1026     TIMx->CR2 = tmpcr2;
00003e  6042              STR      r2,[r0,#4]
;;;1027     
;;;1028     /* Write to TIMx CCMR2 */  
;;;1029     TIMx->CCMR3 = tmpccmrx;
000040  6545              STR      r5,[r0,#0x54]
;;;1030       
;;;1031     /* Set the Capture Compare Register value */
;;;1032     TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
000042  6889              LDR      r1,[r1,#8]
000044  6581              STR      r1,[r0,#0x58]
;;;1033     
;;;1034     /* Write to TIMx CCER */
;;;1035     TIMx->CCER = tmpccer;
000046  6203              STR      r3,[r0,#0x20]
;;;1036   }
000048  bd30              POP      {r4,r5,pc}
;;;1037   
                          ENDP

00004a  0000              DCW      0x0000
                  |L70.76|
                          DCD      0x40012c00
                  |L70.80|
                          DCD      0x40013400

                          AREA ||i.TIM_OC5PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC5PolarityConfig PROC
;;;2218     */
;;;2219   void TIM_OC5PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2220   {
;;;2221     uint32_t tmpccer = 0;
;;;2222   
;;;2223     /* Check the parameters */
;;;2224     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2225     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2226   
;;;2227     tmpccer = TIMx->CCER;
;;;2228   
;;;2229     /* Set or Reset the CC5P Bit */
;;;2230     tmpccer &= (uint32_t)~TIM_CCER_CC5P;
000002  f4223200          BIC      r2,r2,#0x20000
;;;2231     tmpccer |= ((uint32_t)TIM_OCPolarity << 16);
000006  ea424101          ORR      r1,r2,r1,LSL #16
;;;2232   
;;;2233     /* Write to TIMx CCER register */
;;;2234     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2235   }
00000c  4770              BX       lr
;;;2236   
                          ENDP


                          AREA ||i.TIM_OC5PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC5PreloadConfig PROC
;;;1655     */
;;;1656   void TIM_OC5PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1657   {
;;;1658     uint32_t tmpccmr3 = 0;
;;;1659   
;;;1660     /* Check the parameters */
;;;1661     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1662     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1663   
;;;1664     tmpccmr3 = TIMx->CCMR3;
;;;1665   
;;;1666     /* Reset the OC5PE Bit */
;;;1667     tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC5PE);
000002  f0220208          BIC      r2,r2,#8
;;;1668   
;;;1669     /* Enable or Disable the Output Compare Preload feature */
;;;1670     tmpccmr3 |= (uint32_t)(TIM_OCPreload);
000006  430a              ORRS     r2,r2,r1
;;;1671   
;;;1672     /* Write to TIMx CCMR3 register */
;;;1673     TIMx->CCMR3 = tmpccmr3;
000008  6542              STR      r2,[r0,#0x54]
;;;1674   }
00000a  4770              BX       lr
;;;1675   
                          ENDP


                          AREA ||i.TIM_OC6Init||, CODE, READONLY, ALIGN=2

                  TIM_OC6Init PROC
;;;1045     */
;;;1046   void TIM_OC6Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;1047   {
;;;1048     uint32_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;1049      
;;;1050     /* Check the parameters */
;;;1051     assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
;;;1052     assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;1053     assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;1054     assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;1055   
;;;1056     /* Disable the Channel 5: Reset the CC5E Bit */
;;;1057     TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4221280          BIC      r2,r2,#0x100000
000008  6202              STR      r2,[r0,#0x20]
;;;1058     
;;;1059     /* Get the TIMx CCER register value */
;;;1060     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;1061     /* Get the TIMx CR2 register value */
;;;1062     tmpcr2 =  TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;1063     
;;;1064     /* Get the TIMx CCMR3 register value */
;;;1065     tmpccmrx = TIMx->CCMR3;
00000e  6d43              LDR      r3,[r0,#0x54]
;;;1066     
;;;1067     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;1068     tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
;;;1069     
;;;1070     /* Select the Output Compare Mode */
;;;1071     tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000010  680d              LDR      r5,[r1,#0]
000012  f42343e0          BIC      r3,r3,#0x7000         ;1068
000016  ea432305          ORR      r3,r3,r5,LSL #8
;;;1072     
;;;1073     /* Reset the Output Polarity level */
;;;1074     tmpccer &= (uint32_t)~TIM_CCER_CC6P;
;;;1075     /* Set the Output Compare Polarity */
;;;1076     tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
00001a  898d              LDRH     r5,[r1,#0xc]
00001c  f4241400          BIC      r4,r4,#0x200000       ;1074
000020  ea445405          ORR      r4,r4,r5,LSL #20
;;;1077   
;;;1078     /* Set the Output State */
;;;1079     tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
000024  888d              LDRH     r5,[r1,#4]
000026  ea445405          ORR      r4,r4,r5,LSL #20
;;;1080     
;;;1081     if((TIMx == TIM1) || (TIMx == TIM8))
00002a  4d07              LDR      r5,|L73.72|
00002c  42a8              CMP      r0,r5
00002e  d002              BEQ      |L73.54|
000030  4d06              LDR      r5,|L73.76|
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L73.58|
                  |L73.54|
;;;1082     {
;;;1083       assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;1084       /* Reset the Output Compare IDLE State */
;;;1085       tmpcr2 &=(uint32_t) ~TIM_CR2_OIS6;
000036  f4223200          BIC      r2,r2,#0x20000
                  |L73.58|
;;;1086       /* Set the Output Idle state */
;;;1087       tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 18);
;;;1088     }
;;;1089     /* Write to TIMx CR2 */
;;;1090     TIMx->CR2 = tmpcr2;
00003a  6042              STR      r2,[r0,#4]
;;;1091     
;;;1092     /* Write to TIMx CCMR2 */  
;;;1093     TIMx->CCMR3 = tmpccmrx;
00003c  6543              STR      r3,[r0,#0x54]
;;;1094       
;;;1095     /* Set the Capture Compare Register value */
;;;1096     TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
00003e  6889              LDR      r1,[r1,#8]
000040  65c1              STR      r1,[r0,#0x5c]
;;;1097     
;;;1098     /* Write to TIMx CCER */
;;;1099     TIMx->CCER = tmpccer;
000042  6204              STR      r4,[r0,#0x20]
;;;1100   }
000044  bd30              POP      {r4,r5,pc}
;;;1101   
                          ENDP

000046  0000              DCW      0x0000
                  |L73.72|
                          DCD      0x40012c00
                  |L73.76|
                          DCD      0x40013400

                          AREA ||i.TIM_OC6PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC6PolarityConfig PROC
;;;2245     */
;;;2246   void TIM_OC6PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  6a02              LDR      r2,[r0,#0x20]
;;;2247   {
;;;2248     uint32_t tmpccer = 0;
;;;2249   
;;;2250     /* Check the parameters */
;;;2251     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2252     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2253   
;;;2254     tmpccer = TIMx->CCER;
;;;2255   
;;;2256     /* Set or Reset the CC6P Bit */
;;;2257     tmpccer &= (uint32_t)~TIM_CCER_CC6P;
000002  f4221200          BIC      r2,r2,#0x200000
;;;2258     tmpccer |= ((uint32_t)TIM_OCPolarity << 20);
000006  ea425101          ORR      r1,r2,r1,LSL #20
;;;2259   
;;;2260     /* Write to TIMx CCER register */
;;;2261     TIMx->CCER = tmpccer;
00000a  6201              STR      r1,[r0,#0x20]
;;;2262   }
00000c  4770              BX       lr
;;;2263   
                          ENDP


                          AREA ||i.TIM_OC6PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC6PreloadConfig PROC
;;;1684     */
;;;1685   void TIM_OC6PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1686   {
;;;1687     uint32_t tmpccmr3 = 0;
;;;1688   
;;;1689     /* Check the parameters */
;;;1690     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1691     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1692   
;;;1693     tmpccmr3 = TIMx->CCMR3;
;;;1694   
;;;1695     /* Reset the OC5PE Bit */
;;;1696     tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC6PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1697   
;;;1698     /* Enable or Disable the Output Compare Preload feature */
;;;1699     tmpccmr3 |= ((uint32_t)TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1700   
;;;1701     /* Write to TIMx CCMR3 register */
;;;1702     TIMx->CCMR3 = tmpccmr3;
00000a  6541              STR      r1,[r0,#0x54]
;;;1703   }
00000c  4770              BX       lr
;;;1704   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;1186     */
;;;1187   void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;1188   {
;;;1189     /* Set the default configuration */
;;;1190     TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
;;;1191     TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000002  6001              STR      r1,[r0,#0]
000004  8081              STRH     r1,[r0,#4]
;;;1192     TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  80c1              STRH     r1,[r0,#6]
;;;1193     TIM_OCInitStruct->TIM_Pulse = 0x00000000;
;;;1194     TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000008  6081              STR      r1,[r0,#8]
00000a  8181              STRH     r1,[r0,#0xc]
;;;1195     TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;1196     TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;1197     TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;1198   }
000012  4770              BX       lr
;;;1199   
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;2462     */
;;;2463   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2464   {
000004  460c              MOV      r4,r1
;;;2465     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000006  2600              MOVS     r6,#0
;;;2466     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;2467   
;;;2468     /* Check the parameters */
;;;2469     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2470   
;;;2471     /* Select the Opposite Input Polarity */
;;;2472     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000008  8849              LDRH     r1,[r1,#2]
00000a  4607              MOV      r7,r0                 ;2464
00000c  2501              MOVS     r5,#1                 ;2466
00000e  b901              CBNZ     r1,|L77.18|
;;;2473     {
;;;2474       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
                  |L77.18|
;;;2475     }
;;;2476     else
;;;2477     {
;;;2478       icoppositepolarity = TIM_ICPolarity_Rising;
;;;2479     }
;;;2480     /* Select the Opposite Input */
;;;2481     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000012  88a2              LDRH     r2,[r4,#4]
000014  2a01              CMP      r2,#1
000016  d100              BNE      |L77.26|
;;;2482     {
;;;2483       icoppositeselection = TIM_ICSelection_IndirectTI;
000018  2502              MOVS     r5,#2
                  |L77.26|
;;;2484     }
;;;2485     else
;;;2486     {
;;;2487       icoppositeselection = TIM_ICSelection_DirectTI;
;;;2488     }
;;;2489     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00001a  8820              LDRH     r0,[r4,#0]
;;;2490     {
;;;2491       /* TI1 Configuration */
;;;2492       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001c  8923              LDRH     r3,[r4,#8]
00001e  2800              CMP      r0,#0                 ;2489
;;;2493                  TIM_ICInitStruct->TIM_ICFilter);
;;;2494       /* Set the Input Capture Prescaler value */
;;;2495       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2496       /* TI2 Configuration */
;;;2497       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;2498       /* Set the Input Capture Prescaler value */
;;;2499       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2500     }
;;;2501     else
;;;2502     { 
;;;2503       /* TI2 Configuration */
;;;2504       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000020  4638              MOV      r0,r7
000022  d011              BEQ      |L77.72|
000024  f7fffffe          BL       TI2_Config
;;;2505                  TIM_ICInitStruct->TIM_ICFilter);
;;;2506       /* Set the Input Capture Prescaler value */
;;;2507       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000028  88e1              LDRH     r1,[r4,#6]
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2508       /* TI1 Configuration */
;;;2509       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000030  8923              LDRH     r3,[r4,#8]
000032  462a              MOV      r2,r5
000034  4631              MOV      r1,r6
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       TI1_Config
;;;2510       /* Set the Input Capture Prescaler value */
;;;2511       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003c  88e1              LDRH     r1,[r4,#6]
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L77.72|
000048  f7fffffe          BL       TI1_Config
00004c  88e1              LDRH     r1,[r4,#6]            ;2495
00004e  4638              MOV      r0,r7                 ;2495
000050  f7fffffe          BL       TIM_SetIC1Prescaler
000054  8923              LDRH     r3,[r4,#8]            ;2497
000056  462a              MOV      r2,r5                 ;2497
000058  4631              MOV      r1,r6                 ;2497
00005a  4638              MOV      r0,r7                 ;2497
00005c  f7fffffe          BL       TI2_Config
000060  88e1              LDRH     r1,[r4,#6]            ;2499
000062  4638              MOV      r0,r7                 ;2499
000064  e8bd41f0          POP      {r4-r8,lr}            ;2499
000068  f7ffbffe          B.W      TIM_SetIC2Prescaler
;;;2512     }
;;;2513   }
;;;2514   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;338      */
;;;339    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;340    {
;;;341      /* Check the parameters */
;;;342      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;343      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;344      /* Set the Prescaler value */
;;;345      TIMx->PSC = Prescaler;
;;;346      /* Set or reset the UG Bit */
;;;347      TIMx->EGR = TIM_PSCReloadMode;
000002  6142              STR      r2,[r0,#0x14]
;;;348    }
000004  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;3802     */
;;;3803   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  f8a01050          STRH     r1,[r0,#0x50]
;;;3804   {
;;;3805    /* Check the parameters */
;;;3806     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;3807     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3808   
;;;3809     /* Set the Timer remapping configuration */
;;;3810     TIMx->OR =  TIM_Remap;
;;;3811   }
000004  4770              BX       lr
;;;3812   /**
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;3231     */
;;;3232   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;3233   {
;;;3234     /* Check the parameters */
;;;3235     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;3236     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3237   
;;;3238     if (NewState != DISABLE)
;;;3239     {
;;;3240       /* Set the CCDS Bit */
;;;3241       TIMx->CR2 |= TIM_CR2_CCDS;
;;;3242     }
;;;3243     else
;;;3244     {
;;;3245       /* Reset the CCDS Bit */
;;;3246       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L80.12|
000006  f0410108          ORR      r1,r1,#8              ;3241
00000a  e002              B        |L80.18|
                  |L80.12|
00000c  f64f72f7          MOV      r2,#0xfff7
000010  4011              ANDS     r1,r1,r2
                  |L80.18|
000012  6041              STR      r1,[r0,#4]            ;3241
;;;3247     }
;;;3248   }
000014  4770              BX       lr
;;;3249   /**
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;2873     */
;;;2874   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2875   {
;;;2876     /* Check the parameters */
;;;2877     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2878     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2879   
;;;2880     if (NewState != DISABLE)
;;;2881     {
;;;2882       /* Set the COM Bit */
;;;2883       TIMx->CR2 |= TIM_CR2_CCUS;
;;;2884     }
;;;2885     else
;;;2886     {
;;;2887       /* Reset the COM Bit */
;;;2888       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L81.12|
000006  f0410104          ORR      r1,r1,#4              ;2883
00000a  e002              B        |L81.18|
                  |L81.12|
00000c  f64f72fb          MOV      r2,#0xfffb
000010  4011              ANDS     r1,r1,r2
                  |L81.18|
000012  6041              STR      r1,[r0,#4]            ;2883
;;;2889     }
;;;2890   }
000014  4770              BX       lr
;;;2891   
                          ENDP


                          AREA ||i.TIM_SelectGC5C1||, CODE, READONLY, ALIGN=1

                  TIM_SelectGC5C1 PROC
;;;1109     */
;;;1110   void TIM_SelectGC5C1(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1111   {
;;;1112     /* Check the parameters */
;;;1113     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1114     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1115   
;;;1116     if (NewState != DISABLE)
;;;1117     {
;;;1118       /* Set the GC5C1 Bit */
;;;1119       TIMx->CCR5 |= TIM_CCR5_GC5C1;
;;;1120     }
;;;1121     else
;;;1122     {
;;;1123       /* Reset the GC5C1 Bit */
;;;1124       TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C1;
000002  6d81              LDR      r1,[r0,#0x58]
000004  d002              BEQ      |L82.12|
000006  f0415100          ORR      r1,r1,#0x20000000     ;1119
00000a  e001              B        |L82.16|
                  |L82.12|
00000c  f0215100          BIC      r1,r1,#0x20000000
                  |L82.16|
000010  6581              STR      r1,[r0,#0x58]         ;1119
;;;1125     }
;;;1126   }
000012  4770              BX       lr
;;;1127   
                          ENDP


                          AREA ||i.TIM_SelectGC5C2||, CODE, READONLY, ALIGN=1

                  TIM_SelectGC5C2 PROC
;;;1135     */
;;;1136   void TIM_SelectGC5C2(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1137   {
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1140     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1141   
;;;1142     if (NewState != DISABLE)
;;;1143     {
;;;1144       /* Set the GC5C2 Bit */
;;;1145       TIMx->CCR5 |= TIM_CCR5_GC5C2;
;;;1146     }
;;;1147     else
;;;1148     {
;;;1149       /* Reset the GC5C2 Bit */
;;;1150       TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C2;
000002  6d81              LDR      r1,[r0,#0x58]
000004  d002              BEQ      |L83.12|
000006  f0414180          ORR      r1,r1,#0x40000000     ;1145
00000a  e001              B        |L83.16|
                  |L83.12|
00000c  f0214180          BIC      r1,r1,#0x40000000
                  |L83.16|
000010  6581              STR      r1,[r0,#0x58]         ;1145
;;;1151     }
;;;1152   }
000012  4770              BX       lr
;;;1153   
                          ENDP


                          AREA ||i.TIM_SelectGC5C3||, CODE, READONLY, ALIGN=1

                  TIM_SelectGC5C3 PROC
;;;1162     */
;;;1163   void TIM_SelectGC5C3(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1164   {
;;;1165     /* Check the parameters */
;;;1166     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1167     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1168   
;;;1169     if (NewState != DISABLE)
;;;1170     {
;;;1171       /* Set the GC5C3 Bit */
;;;1172       TIMx->CCR5 |= TIM_CCR5_GC5C3;
;;;1173     }
;;;1174     else
;;;1175     {
;;;1176       /* Reset the GC5C3 Bit */
;;;1177       TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C3;
000002  6d81              LDR      r1,[r0,#0x58]
000004  d002              BEQ      |L84.12|
000006  f0414100          ORR      r1,r1,#0x80000000     ;1172
00000a  e001              B        |L84.16|
                  |L84.12|
00000c  f0214100          BIC      r1,r1,#0x80000000
                  |L84.16|
000010  6581              STR      r1,[r0,#0x58]         ;1172
;;;1178     }
;;;1179   }
000012  4770              BX       lr
;;;1180   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3746     */
;;;3747   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;3748   {
;;;3749     /* Check the parameters */
;;;3750     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3751     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3752   
;;;3753     if (NewState != DISABLE)
;;;3754     {
;;;3755       /* Set the TI1S Bit */
;;;3756       TIMx->CR2 |= TIM_CR2_TI1S;
;;;3757     }
;;;3758     else
;;;3759     {
;;;3760       /* Reset the TI1S Bit */
;;;3761       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L85.12|
000006  f0410180          ORR      r1,r1,#0x80           ;3756
00000a  e002              B        |L85.18|
                  |L85.12|
00000c  f64f727f          MOV      r2,#0xff7f
000010  4011              ANDS     r1,r1,r2
                  |L85.18|
000012  6041              STR      r1,[r0,#4]            ;3756
;;;3762     }
;;;3763   }
000014  4770              BX       lr
;;;3764   /**
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;3475     */
;;;3476   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  6882              LDR      r2,[r0,#8]
;;;3477   {
;;;3478     uint16_t tmpsmcr = 0;
;;;3479   
;;;3480     /* Check the parameters */
;;;3481     assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;3482     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;3483   
;;;3484     /* Get the TIMx SMCR register value */
;;;3485     tmpsmcr = TIMx->SMCR;
000002  b292              UXTH     r2,r2
;;;3486   
;;;3487     /* Reset the TS Bits */
;;;3488     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000004  f0220270          BIC      r2,r2,#0x70
;;;3489   
;;;3490     /* Set the Input Trigger source */
;;;3491     tmpsmcr |= TIM_InputTriggerSource;
000008  430a              ORRS     r2,r2,r1
;;;3492   
;;;3493     /* Write to TIMx SMCR */
;;;3494     TIMx->SMCR = tmpsmcr;
00000a  6082              STR      r2,[r0,#8]
;;;3495   }
00000c  4770              BX       lr
;;;3496   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;3606     */
;;;3607   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  6882              LDR      r2,[r0,#8]
;;;3608   {
;;;3609     /* Check the parameters */
;;;3610     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3611     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;3612   
;;;3613     /* Reset the MSM Bit */
;;;3614     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;3615     
;;;3616     /* Set or Reset the MSM Bit */
;;;3617     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;3618   }
000010  4770              BX       lr
;;;3619   
                          ENDP


                          AREA ||i.TIM_SelectOCREFClear||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCREFClear PROC
;;;2009     */
;;;2010   void TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
000000  6882              LDR      r2,[r0,#8]
;;;2011   {
;;;2012     /* Check the parameters */
;;;2013     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2014     assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
;;;2015   
;;;2016     /* Set the TIM_OCReferenceClear source */
;;;2017     TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
000002  f64f73f7          MOV      r3,#0xfff7
000006  401a              ANDS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;2018     TIMx->SMCR |=  TIM_OCReferenceClear;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;2019   }
000010  4770              BX       lr
;;;2020   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=2

                  TIM_SelectOCxM PROC
;;;1228     */
;;;1229   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint32_t TIM_OCMode) /* to be updated*/
000000  b530              PUSH     {r4,r5,lr}
;;;1230   {
;;;1231     uint32_t tmp = 0;
;;;1232     uint16_t tmp1 = 0;
;;;1233   
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1236     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1237     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1238   
;;;1239     tmp = (uint32_t) TIMx;
;;;1240     tmp += CCMR_OFFSET;
;;;1241   
;;;1242     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000002  2401              MOVS     r4,#1
;;;1243   
;;;1244     /* Disable the Channel: Reset the CCxE Bit */
;;;1245     TIMx->CCER &= (uint16_t) ~tmp1;
000004  6a05              LDR      r5,[r0,#0x20]
000006  f1000318          ADD      r3,r0,#0x18           ;1240
00000a  408c              LSLS     r4,r4,r1              ;1242
00000c  43e4              MVNS     r4,r4
00000e  b2a4              UXTH     r4,r4
000010  4025              ANDS     r5,r5,r4
000012  6205              STR      r5,[r0,#0x20]
000014  b181              CBZ      r1,|L89.56|
;;;1246   
;;;1247     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000016  2908              CMP      r1,#8
000018  d00e              BEQ      |L89.56|
00001a  1f09              SUBS     r1,r1,#4
;;;1248     {
;;;1249       tmp += (TIM_Channel>>1);
;;;1250   
;;;1251       /* Reset the OCxM bits in the CCMRx register */
;;;1252       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
;;;1253      
;;;1254       /* Configure the OCxM bits in the CCMRx register */
;;;1255       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;1256     }
;;;1257     else
;;;1258     {
;;;1259       tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;
00001c  eb030051          ADD      r0,r3,r1,LSR #1
;;;1260   
;;;1261       /* Reset the OCxM bits in the CCMRx register */
;;;1262       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
000020  6801              LDR      r1,[r0,#0]
000022  4b09              LDR      r3,|L89.72|
000024  4019              ANDS     r1,r1,r3
000026  6001              STR      r1,[r0,#0]
;;;1263       
;;;1264       /* Configure the OCxM bits in the CCMRx register */
;;;1265       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000028  6801              LDR      r1,[r0,#0]
00002a  f64f73ff          MOV      r3,#0xffff
00002e  ea032202          AND      r2,r3,r2,LSL #8
                  |L89.50|
000032  4311              ORRS     r1,r1,r2              ;1255
000034  6001              STR      r1,[r0,#0]            ;1255
;;;1266     }
;;;1267   }
000036  bd30              POP      {r4,r5,pc}
                  |L89.56|
000038  eb030051          ADD      r0,r3,r1,LSR #1       ;1249
00003c  6801              LDR      r1,[r0,#0]            ;1252
00003e  4b03              LDR      r3,|L89.76|
000040  4019              ANDS     r1,r1,r3              ;1252
000042  6001              STR      r1,[r0,#0]            ;1252
000044  6801              LDR      r1,[r0,#0]            ;1255
000046  e7f4              B        |L89.50|
;;;1268   
                          ENDP

                  |L89.72|
                          DCD      0xfeff8fff
                  |L89.76|
                          DCD      0xfffeff8f

                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;553      */
;;;554    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;555    {
;;;556      /* Check the parameters */
;;;557      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;558      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;559    
;;;560      /* Reset the OPM Bit */
;;;561      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;562    
;;;563      /* Configure the OPM Mode */
;;;564      TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;565    }
00000e  4770              BX       lr
;;;566    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;3518     */
;;;3519   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  6842              LDR      r2,[r0,#4]
;;;3520   {
;;;3521     /* Check the parameters */
;;;3522     assert_param(IS_TIM_LIST7_PERIPH(TIMx));
;;;3523     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;3524   
;;;3525     /* Reset the MMS Bits */
;;;3526     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  6042              STR      r2,[r0,#4]
;;;3527     /* Select the TRGO source */
;;;3528     TIMx->CR2 |=  TIM_TRGOSource;
00000a  6842              LDR      r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  6042              STR      r2,[r0,#4]
;;;3529   }
000010  4770              BX       lr
;;;3530   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger2||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger2 PROC
;;;3556     */
;;;3557   void TIM_SelectOutputTrigger2(TIM_TypeDef* TIMx, uint32_t TIM_TRGO2Source)
000000  6842              LDR      r2,[r0,#4]
;;;3558   {
;;;3559     /* Check the parameters */
;;;3560     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;3561     assert_param(IS_TIM_TRGO2_SOURCE(TIM_TRGO2Source));
;;;3562   
;;;3563     /* Reset the MMS Bits */
;;;3564     TIMx->CR2 &= (uint32_t)~TIM_CR2_MMS2;
000002  f4220270          BIC      r2,r2,#0xf00000
000006  6042              STR      r2,[r0,#4]
;;;3565     /* Select the TRGO source */
;;;3566     TIMx->CR2 |=  TIM_TRGO2Source;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;3567   }
00000e  4770              BX       lr
;;;3568   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=2

                  TIM_SelectSlaveMode PROC
;;;3583     */
;;;3584   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint32_t TIM_SlaveMode)
000000  6882              LDR      r2,[r0,#8]
;;;3585   {
;;;3586     /* Check the parameters */
;;;3587     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3588     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;3589   
;;;3590     /* Reset the SMS Bits */
;;;3591     TIMx->SMCR &= (uint32_t)~TIM_SMCR_SMS;
000002  4b03              LDR      r3,|L93.16|
000004  401a              ANDS     r2,r2,r3
000006  6082              STR      r2,[r0,#8]
;;;3592   
;;;3593     /* Select the Slave Mode */
;;;3594     TIMx->SMCR |= (uint32_t)TIM_SlaveMode;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;3595   }
00000e  4770              BX       lr
;;;3596   
                          ENDP

                  |L93.16|
                          DCD      0xfffefff8

                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;402      */
;;;403    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;404    {
;;;405      /* Check the parameters */
;;;406      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;407      
;;;408      /* Set the Autoreload Register value */
;;;409      TIMx->ARR = Autoreload;
;;;410    }
000002  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;576      */
;;;577    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;578    {
;;;579      /* Check the parameters */
;;;580      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;581      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;582    
;;;583      /* Reset the CKD Bits */
;;;584      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;585    
;;;586      /* Set the CKD value */
;;;587      TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;588    }
00000e  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1274     */
;;;1275   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1276   {
;;;1277     /* Check the parameters */
;;;1278     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1279   
;;;1280     /* Set the Capture Compare1 Register value */
;;;1281     TIMx->CCR1 = Compare1;
;;;1282   }
000002  4770              BX       lr
;;;1283   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1290     */
;;;1291   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1292   {
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1295   
;;;1296     /* Set the Capture Compare2 Register value */
;;;1297     TIMx->CCR2 = Compare2;
;;;1298   }
000002  4770              BX       lr
;;;1299   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1305     */
;;;1306   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1307   {
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1310   
;;;1311     /* Set the Capture Compare3 Register value */
;;;1312     TIMx->CCR3 = Compare3;
;;;1313   }
000002  4770              BX       lr
;;;1314   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1320     */
;;;1321   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1322   {
;;;1323     /* Check the parameters */
;;;1324     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1325   
;;;1326     /* Set the Capture Compare4 Register value */
;;;1327     TIMx->CCR4 = Compare4;
;;;1328   }
000002  4770              BX       lr
;;;1329   
                          ENDP


                          AREA ||i.TIM_SetCompare5||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare5 PROC
;;;1335     */
;;;1336   void TIM_SetCompare5(TIM_TypeDef* TIMx, uint32_t Compare5)
000000  6581              STR      r1,[r0,#0x58]
;;;1337   {
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1340   
;;;1341     /* Set the Capture Compare5 Register value */
;;;1342     TIMx->CCR5 = Compare5;
;;;1343   }
000002  4770              BX       lr
;;;1344   
                          ENDP


                          AREA ||i.TIM_SetCompare6||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare6 PROC
;;;1350     */
;;;1351   void TIM_SetCompare6(TIM_TypeDef* TIMx, uint32_t Compare6)
000000  65c1              STR      r1,[r0,#0x5c]
;;;1352   {
;;;1353     /* Check the parameters */
;;;1354     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1355   
;;;1356     /* Set the Capture Compare6 Register value */
;;;1357     TIMx->CCR6 = Compare6;
;;;1358   }
000002  4770              BX       lr
;;;1359   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;387      */
;;;388    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;389    {
;;;390      /* Check the parameters */
;;;391       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;392    
;;;393      /* Set the Counter Register value */
;;;394      TIMx->CNT = Counter;
;;;395    }
000002  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2582     */
;;;2583   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  6982              LDR      r2,[r0,#0x18]
;;;2584   {
;;;2585     /* Check the parameters */
;;;2586     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2587     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2588   
;;;2589     /* Reset the IC1PSC Bits */
;;;2590     TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC1PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  6182              STR      r2,[r0,#0x18]
;;;2591   
;;;2592     /* Set the IC1PSC value */
;;;2593     TIMx->CCMR1 |= TIM_ICPSC;
000008  6982              LDR      r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  6182              STR      r2,[r0,#0x18]
;;;2594   }
00000e  4770              BX       lr
;;;2595   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2607     */
;;;2608   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  6982              LDR      r2,[r0,#0x18]
;;;2609   {
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2612     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2613   
;;;2614     /* Reset the IC2PSC Bits */
;;;2615     TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC2PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  6182              STR      r2,[r0,#0x18]
;;;2616   
;;;2617     /* Set the IC2PSC value */
;;;2618     TIMx->CCMR1 |= (uint32_t)((uint32_t)TIM_ICPSC << 8);
000008  6982              LDR      r2,[r0,#0x18]
00000a  ea422101          ORR      r1,r2,r1,LSL #8
00000e  6181              STR      r1,[r0,#0x18]
;;;2619   }
000010  4770              BX       lr
;;;2620   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2631     */
;;;2632   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;2633   {
;;;2634     /* Check the parameters */
;;;2635     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2636     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2637   
;;;2638     /* Reset the IC3PSC Bits */
;;;2639     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  61c2              STR      r2,[r0,#0x1c]
;;;2640   
;;;2641     /* Set the IC3PSC value */
;;;2642     TIMx->CCMR2 |= TIM_ICPSC;
00000a  69c2              LDR      r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  61c2              STR      r2,[r0,#0x1c]
;;;2643   }
000010  4770              BX       lr
;;;2644   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2655     */
;;;2656   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;2657   {  
;;;2658     /* Check the parameters */
;;;2659     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2660     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2661   
;;;2662     /* Reset the IC4PSC Bits */
;;;2663     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  61c2              STR      r2,[r0,#0x1c]
;;;2664   
;;;2665     /* Set the IC4PSC value */
;;;2666     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  69c2              LDR      r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032101          AND      r1,r3,r1,LSL #8
000014  430a              ORRS     r2,r2,r1
000016  61c2              STR      r2,[r0,#0x1c]
;;;2667   }
000018  4770              BX       lr
;;;2668   /**
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;3321     */
;;;3322   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;3323                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;3324   {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
;;;3325     /* Check the parameters */
;;;3326     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3327     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;3328     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;3329   
;;;3330     /* Configure the Timer Input Clock Source */
;;;3331     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000006  2960              CMP      r1,#0x60
000008  4604              MOV      r4,r0                 ;3324
;;;3332     {
;;;3333       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;3334     }
;;;3335     else
;;;3336     {
;;;3337       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000a  f04f0201          MOV      r2,#1
00000e  4631              MOV      r1,r6
000010  d00a              BEQ      |L107.40|
000012  f7fffffe          BL       TI1_Config
                  |L107.22|
;;;3338     }
;;;3339     /* Select the Trigger source */
;;;3340     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SelectInputTrigger
;;;3341     /* Select the External clock mode1 */
;;;3342     TIMx->SMCR |= TIM_SlaveMode_External1;
00001e  68a0              LDR      r0,[r4,#8]
000020  f0400007          ORR      r0,r0,#7
000024  60a0              STR      r0,[r4,#8]
;;;3343   }
000026  bd70              POP      {r4-r6,pc}
                  |L107.40|
000028  f7fffffe          BL       TI2_Config
00002c  e7f3              B        |L107.22|
;;;3344   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;266      */
;;;267    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;268    {
;;;269      uint16_t tmpcr1 = 0;
;;;270    
;;;271      /* Check the parameters */
;;;272      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;273      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;274      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;275    
;;;276      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;277    
;;;278      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
000004  4b19              LDR      r3,|L108.108|
000006  4c1a              LDR      r4,|L108.112|
000008  4298              CMP      r0,r3
00000a  d00a              BEQ      |L108.34|
00000c  42a0              CMP      r0,r4
00000e  d008              BEQ      |L108.34|
000010  f1b04f80          CMP      r0,#0x40000000
000014  d005              BEQ      |L108.34|
;;;279         (TIMx == TIM3)|| (TIMx == TIM4)) 
000016  4d17              LDR      r5,|L108.116|
000018  42a8              CMP      r0,r5
00001a  d002              BEQ      |L108.34|
00001c  4d16              LDR      r5,|L108.120|
00001e  42a8              CMP      r0,r5
000020  d103              BNE      |L108.42|
                  |L108.34|
;;;280      {
;;;281        /* Select the Counter Mode */
;;;282        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000022  f0220570          BIC      r5,r2,#0x70
;;;283        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
000026  884a              LDRH     r2,[r1,#2]
000028  432a              ORRS     r2,r2,r5
                  |L108.42|
;;;284      }
;;;285     
;;;286      if((TIMx != TIM6) && (TIMx != TIM7))
00002a  4d14              LDR      r5,|L108.124|
00002c  42a8              CMP      r0,r5
00002e  d006              BEQ      |L108.62|
000030  4d13              LDR      r5,|L108.128|
000032  42a8              CMP      r0,r5
000034  d003              BEQ      |L108.62|
;;;287      {
;;;288        /* Set the clock division */
;;;289        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
000036  f4227540          BIC      r5,r2,#0x300
;;;290        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
00003a  890a              LDRH     r2,[r1,#8]
00003c  432a              ORRS     r2,r2,r5
                  |L108.62|
;;;291      }
;;;292    
;;;293      TIMx->CR1 = tmpcr1;
00003e  8002              STRH     r2,[r0,#0]
;;;294    
;;;295      /* Set the Autoreload value */
;;;296      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000040  684a              LDR      r2,[r1,#4]
000042  62c2              STR      r2,[r0,#0x2c]
;;;297     
;;;298      /* Set the Prescaler value */
;;;299      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000044  880a              LDRH     r2,[r1,#0]
000046  8502              STRH     r2,[r0,#0x28]
;;;300        
;;;301      if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15) || 
000048  4298              CMP      r0,r3
00004a  d00a              BEQ      |L108.98|
00004c  42a0              CMP      r0,r4
00004e  d008              BEQ      |L108.98|
000050  4a0c              LDR      r2,|L108.132|
000052  4290              CMP      r0,r2
000054  d005              BEQ      |L108.98|
;;;302          (TIMx == TIM16) || (TIMx == TIM17))  
000056  4a0c              LDR      r2,|L108.136|
000058  4290              CMP      r0,r2
00005a  d002              BEQ      |L108.98|
00005c  4a0b              LDR      r2,|L108.140|
00005e  4290              CMP      r0,r2
000060  d101              BNE      |L108.102|
                  |L108.98|
;;;303      {
;;;304        /* Set the Repetition Counter value */
;;;305        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000062  7a89              LDRB     r1,[r1,#0xa]
000064  8601              STRH     r1,[r0,#0x30]
                  |L108.102|
;;;306      }
;;;307    
;;;308      /* Generate an update event to reload the Prescaler 
;;;309         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;310      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000066  2101              MOVS     r1,#1
000068  6141              STR      r1,[r0,#0x14]
;;;311    }
00006a  bd30              POP      {r4,r5,pc}
;;;312    
                          ENDP

                  |L108.108|
                          DCD      0x40012c00
                  |L108.112|
                          DCD      0x40013400
                  |L108.116|
                          DCD      0x40000400
                  |L108.120|
                          DCD      0x40000800
                  |L108.124|
                          DCD      0x40001000
                  |L108.128|
                          DCD      0x40001400
                  |L108.132|
                          DCD      0x40014000
                  |L108.136|
                          DCD      0x40014400
                  |L108.140|
                          DCD      0x40014800

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;318      */
;;;319    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;320    {
;;;321      /* Set the default configuration */
;;;322      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
;;;323      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000004  6041              STR      r1,[r0,#4]
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;324      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;325      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;326      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;327    }
000010  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.TIM_UIFRemap||, CODE, READONLY, ALIGN=1

                  TIM_UIFRemap PROC
;;;501      */
;;;502    void TIM_UIFRemap(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;503    {
;;;504      /* Check the parameters */
;;;505      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;506      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;507      
;;;508      if (NewState != DISABLE)
;;;509      {
;;;510        /* Enable the TIM Counter */
;;;511        TIMx->CR1 |= TIM_CR1_UIFREMAP;
;;;512      }
;;;513      else
;;;514      {
;;;515        /* Disable the TIM Counter */
;;;516        TIMx->CR1 &= (uint16_t)~TIM_CR1_UIFREMAP;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L110.12|
000006  f4416100          ORR      r1,r1,#0x800          ;511
00000a  e001              B        |L110.16|
                  |L110.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L110.16|
000010  8001              STRH     r1,[r0,#0]            ;511
;;;517      }  
;;;518    }
000012  4770              BX       lr
;;;519    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;446      */
;;;447    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;448    {
;;;449      /* Check the parameters */
;;;450      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;451      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;452    
;;;453      if (NewState != DISABLE)
;;;454      {
;;;455        /* Set the Update Disable Bit */
;;;456        TIMx->CR1 |= TIM_CR1_UDIS;
;;;457      }
;;;458      else
;;;459      {
;;;460        /* Reset the Update Disable Bit */
;;;461        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L111.12|
000006  f0410102          ORR      r1,r1,#2              ;456
00000a  e001              B        |L111.16|
                  |L111.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L111.16|
000010  8001              STRH     r1,[r0,#0]            ;456
;;;462      }
;;;463    }
000012  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;475      */
;;;476    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;477    {
;;;478      /* Check the parameters */
;;;479      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;480      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;481    
;;;482      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;483      {
;;;484        /* Set the URS Bit */
;;;485        TIMx->CR1 |= TIM_CR1_URS;
;;;486      }
;;;487      else
;;;488      {
;;;489        /* Reset the URS Bit */
;;;490        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L112.12|
000006  f0410104          ORR      r1,r1,#4              ;485
00000a  e001              B        |L112.16|
                  |L112.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L112.16|
000010  8001              STRH     r1,[r0,#0]            ;485
;;;491      }
;;;492    }
000012  4770              BX       lr
;;;493    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_tim_c_c458916b____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f30x_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f30x_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
