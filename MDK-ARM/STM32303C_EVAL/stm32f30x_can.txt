; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_can.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_can.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;676      */
;;;677    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b141              CBZ      r1,|L1.20|
;;;678    {
;;;679      /* Check the parameters */
;;;680      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;681      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;682      /* abort transmission */
;;;683      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d00a              BEQ      |L1.28|
000006  2902              CMP      r1,#2
000008  d103              BNE      |L1.18|
;;;684      {
;;;685        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
;;;686          break;
;;;687        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
;;;688          break;
;;;689        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
00000a  6881              LDR      r1,[r0,#8]
00000c  f4410100          ORR      r1,r1,#0x800000
                  |L1.16|
000010  6081              STR      r1,[r0,#8]
                  |L1.18|
;;;690          break;
;;;691        default:
;;;692          break;
;;;693      }
;;;694    }
000012  4770              BX       lr
                  |L1.20|
000014  6881              LDR      r1,[r0,#8]            ;685
000016  f0410180          ORR      r1,r1,#0x80           ;685
00001a  e7f9              B        |L1.16|
                  |L1.28|
00001c  6881              LDR      r1,[r0,#8]            ;687
00001e  f4414100          ORR      r1,r1,#0x8000         ;687
000022  e7f5              B        |L1.16|
;;;695    /**
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1357     */
;;;1358   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4a0a              LDR      r2,|L2.44|
;;;1359   {
;;;1360     uint32_t flagtmp=0;
;;;1361     /* Check the parameters */
;;;1362     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1363     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1364     
;;;1365     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000002  4291              CMP      r1,r2
000004  d102              BNE      |L2.12|
;;;1366     {
;;;1367       /* Clear the selected CAN flags */
;;;1368       CANx->ESR = (uint32_t)RESET;
000006  2100              MOVS     r1,#0
000008  6181              STR      r1,[r0,#0x18]
;;;1369     }
;;;1370     else /* MSR or TSR or RF0R or RF1R */
;;;1371     {
;;;1372       flagtmp = CAN_FLAG & 0x000FFFFF;
;;;1373   
;;;1374       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
;;;1375       {
;;;1376         /* Receive Flags */
;;;1377         CANx->RF0R = (uint32_t)(flagtmp);
;;;1378       }
;;;1379       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
;;;1380       {
;;;1381         /* Receive Flags */
;;;1382         CANx->RF1R = (uint32_t)(flagtmp);
;;;1383       }
;;;1384       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
;;;1385       {
;;;1386         /* Transmit Flags */
;;;1387         CANx->TSR = (uint32_t)(flagtmp);
;;;1388       }
;;;1389       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1390       {
;;;1391         /* Operating mode Flags */
;;;1392         CANx->MSR = (uint32_t)(flagtmp);
;;;1393       }
;;;1394     }
;;;1395   }
00000a  4770              BX       lr
                  |L2.12|
00000c  f3c10213          UBFX     r2,r1,#0,#20          ;1372
000010  018b              LSLS     r3,r1,#6              ;1374
000012  d501              BPL      |L2.24|
000014  60c2              STR      r2,[r0,#0xc]          ;1377
000016  4770              BX       lr
                  |L2.24|
000018  014b              LSLS     r3,r1,#5              ;1379
00001a  d501              BPL      |L2.32|
00001c  6102              STR      r2,[r0,#0x10]         ;1382
00001e  4770              BX       lr
                  |L2.32|
000020  0109              LSLS     r1,r1,#4              ;1384
000022  d501              BPL      |L2.40|
000024  6082              STR      r2,[r0,#8]            ;1387
000026  4770              BX       lr
                  |L2.40|
000028  6042              STR      r2,[r0,#4]            ;1392
00002a  4770              BX       lr
;;;1396   
                          ENDP

                  |L2.44|
                          DCD      0x30f00070

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1521     */
;;;1522   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1523   {
;;;1524     /* Check the parameters */
;;;1525     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1526     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1527   
;;;1528     switch (CAN_IT)
;;;1529     {
;;;1530       case CAN_IT_TME:
;;;1531         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1532         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
;;;1533         break;
;;;1534       case CAN_IT_FF0:
;;;1535         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1536         CANx->RF0R = CAN_RF0R_FULL0; 
000002  2308              MOVS     r3,#8
;;;1537         break;
;;;1538       case CAN_IT_FOV0:
;;;1539         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1540         CANx->RF0R = CAN_RF0R_FOVR0; 
000004  2410              MOVS     r4,#0x10
;;;1541         break;
;;;1542       case CAN_IT_FF1:
;;;1543         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1544         CANx->RF1R = CAN_RF1R_FULL1;  
;;;1545         break;
;;;1546       case CAN_IT_FOV1:
;;;1547         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1548         CANx->RF1R = CAN_RF1R_FOVR1; 
;;;1549         break;
;;;1550       case CAN_IT_WKU:
;;;1551         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1552         CANx->MSR = CAN_MSR_WKUI;  
;;;1553         break;
;;;1554       case CAN_IT_SLK:
;;;1555         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1556         CANx->MSR = CAN_MSR_SLAKI;   
;;;1557         break;
;;;1558       case CAN_IT_EWG:
;;;1559         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1560         CANx->MSR = CAN_MSR_ERRI;
000006  2204              MOVS     r2,#4
000008  f5b17f00          CMP      r1,#0x200             ;1528
00000c  d01d              BEQ      |L3.74|
00000e  dc10              BGT      |L3.50|
000010  2920              CMP      r1,#0x20              ;1528
000012  d029              BEQ      |L3.104|
000014  dc07              BGT      |L3.38|
000016  2901              CMP      r1,#1                 ;1528
000018  d021              BEQ      |L3.94|
00001a  2904              CMP      r1,#4                 ;1528
00001c  d022              BEQ      |L3.100|
00001e  2908              CMP      r1,#8                 ;1528
000020  d100              BNE      |L3.36|
000022  60c4              STR      r4,[r0,#0xc]          ;1540
                  |L3.36|
;;;1561          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1562         break;
;;;1563       case CAN_IT_EPV:
;;;1564         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1565         CANx->MSR = CAN_MSR_ERRI; 
;;;1566          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1567         break;
;;;1568       case CAN_IT_BOF:
;;;1569         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1570         CANx->MSR = CAN_MSR_ERRI; 
;;;1571          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1572          break;
;;;1573       case CAN_IT_LEC:
;;;1574         /*  Clear LEC bits */
;;;1575         CANx->ESR = RESET; 
;;;1576         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1577         CANx->MSR = CAN_MSR_ERRI; 
;;;1578         break;
;;;1579       case CAN_IT_ERR:
;;;1580         /*Clear LEC bits */
;;;1581         CANx->ESR = RESET; 
;;;1582         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1583         CANx->MSR = CAN_MSR_ERRI; 
;;;1584          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1585          break;
;;;1586       default:
;;;1587          break;
;;;1588      }
;;;1589   }
000024  bd30              POP      {r4,r5,pc}
                  |L3.38|
000026  2940              CMP      r1,#0x40              ;1528
000028  d020              BEQ      |L3.108|
00002a  f5b17f80          CMP      r1,#0x100             ;1528
00002e  d1f9              BNE      |L3.36|
000030  e00b              B        |L3.74|
                  |L3.50|
000032  2500              MOVS     r5,#0                 ;1528
000034  f5b14f00          CMP      r1,#0x8000            ;1528
000038  d006              BEQ      |L3.72|
00003a  dc08              BGT      |L3.78|
00003c  f5b16f80          CMP      r1,#0x400             ;1528
000040  d003              BEQ      |L3.74|
000042  f5b16f00          CMP      r1,#0x800             ;1528
000046  d1ed              BNE      |L3.36|
                  |L3.72|
000048  6185              STR      r5,[r0,#0x18]         ;1581
                  |L3.74|
00004a  6042              STR      r2,[r0,#4]            ;1570
                  |L3.76|
00004c  bd30              POP      {r4,r5,pc}
                  |L3.78|
00004e  f5b13f80          CMP      r1,#0x10000           ;1528
000052  d00d              BEQ      |L3.112|
000054  f5b13f00          CMP      r1,#0x20000           ;1528
000058  d1f8              BNE      |L3.76|
00005a  6044              STR      r4,[r0,#4]            ;1556
00005c  bd30              POP      {r4,r5,pc}
                  |L3.94|
00005e  4905              LDR      r1,|L3.116|
000060  6081              STR      r1,[r0,#8]            ;1532
000062  bd30              POP      {r4,r5,pc}
                  |L3.100|
000064  60c3              STR      r3,[r0,#0xc]          ;1536
000066  bd30              POP      {r4,r5,pc}
                  |L3.104|
000068  6103              STR      r3,[r0,#0x10]         ;1544
00006a  bd30              POP      {r4,r5,pc}
                  |L3.108|
00006c  6104              STR      r4,[r0,#0x10]         ;1548
00006e  bd30              POP      {r4,r5,pc}
                  |L3.112|
000070  6043              STR      r3,[r0,#4]            ;1552
000072  bd30              POP      {r4,r5,pc}
;;;1590    /**
                          ENDP

                  |L3.116|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;467      */
;;;468    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473      
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Enable Debug Freeze  */
;;;477        CANx->MCR |= MCR_DBF;
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Disable Debug Freeze */
;;;482        CANx->MCR &= ~MCR_DBF;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L4.12|
000006  f4413180          ORR      r1,r1,#0x10000        ;477
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f4213180          BIC      r1,r1,#0x10000
                  |L4.16|
000010  6001              STR      r1,[r0,#0]            ;477
;;;483      }
;;;484    }
000012  4770              BX       lr
;;;485    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=1

                  CAN_DeInit PROC
;;;151      */
;;;152    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154      /* Check the parameters */
;;;155      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;156     
;;;157      /* Enable CAN1 reset state */
;;;158      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
000002  2101              MOVS     r1,#1
000004  064c              LSLS     r4,r1,#25
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159      /* Release CAN1 from reset state */
;;;160      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;161    }
;;;162    
                          ENDP


                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;772      */
;;;773    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b121              CBZ      r1,|L6.12|
;;;774    {
;;;775      /* Check the parameters */
;;;776      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;777      assert_param(IS_CAN_FIFO(FIFONumber));
;;;778      /* Release FIFO0 */
;;;779      if (FIFONumber == CAN_FIFO0)
;;;780      {
;;;781        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;782      }
;;;783      /* Release FIFO1 */
;;;784      else /* FIFONumber == CAN_FIFO1 */
;;;785      {
;;;786        CANx->RF1R |= CAN_RF1R_RFOM1;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410120          ORR      r1,r1,#0x20
000008  6101              STR      r1,[r0,#0x10]
;;;787      }
;;;788    }
00000a  4770              BX       lr
                  |L6.12|
00000c  68c1              LDR      r1,[r0,#0xc]          ;781
00000e  f0410120          ORR      r1,r1,#0x20           ;781
000012  60c1              STR      r1,[r0,#0xc]          ;781
000014  4770              BX       lr
;;;789    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;308      */
;;;309    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;310    {
;;;311      uint32_t filter_number_bit_pos = 0;
;;;312      /* Check the parameters */
;;;313      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;314      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;315      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;316      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;317      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;318    
;;;319      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000002  7a82              LDRB     r2,[r0,#0xa]
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;320    
;;;321      /* Initialisation mode for the filter */
;;;322      CAN1->FMR |= FMR_FINIT;
000008  4a2e              LDR      r2,|L7.196|
00000a  6813              LDR      r3,[r2,#0]
00000c  f0430301          ORR      r3,r3,#1
000010  6013              STR      r3,[r2,#0]
;;;323    
;;;324      /* Filter Deactivation */
;;;325      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000012  4b2c              LDR      r3,|L7.196|
000014  331c              ADDS     r3,r3,#0x1c
000016  681c              LDR      r4,[r3,#0]
000018  438c              BICS     r4,r4,r1
00001a  601c              STR      r4,[r3,#0]
;;;326    
;;;327      /* Filter Scale */
;;;328      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
;;;329      {
;;;330        /* 16-bit scale for the filter */
;;;331        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00001c  4d29              LDR      r5,|L7.196|
00001e  7b06              LDRB     r6,[r0,#0xc]          ;328
;;;332    
;;;333        /* First 16-bit identifier and First 16-bit mask */
;;;334        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;335        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000020  4c29              LDR      r4,|L7.200|
000022  350c              ADDS     r5,r5,#0xc            ;331
000024  b9a6              CBNZ     r6,|L7.80|
000026  682e              LDR      r6,[r5,#0]            ;331
000028  438e              BICS     r6,r6,r1              ;331
00002a  602e              STR      r6,[r5,#0]            ;331
00002c  8846              LDRH     r6,[r0,#2]
00002e  88c7              LDRH     r7,[r0,#6]
000030  ea464607          ORR      r6,r6,r7,LSL #16
000034  7a87              LDRB     r7,[r0,#0xa]
000036  eb0407c7          ADD      r7,r4,r7,LSL #3
00003a  f8c76640          STR      r6,[r7,#0x640]
;;;336           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;337            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;338    
;;;339        /* Second 16-bit identifier and Second 16-bit mask */
;;;340        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;341        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00003e  8806              LDRH     r6,[r0,#0]
000040  8887              LDRH     r7,[r0,#4]
000042  ea464607          ORR      r6,r6,r7,LSL #16
000046  7a87              LDRB     r7,[r0,#0xa]
000048  eb0407c7          ADD      r7,r4,r7,LSL #3
00004c  f8c76644          STR      r6,[r7,#0x644]
                  |L7.80|
;;;342           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;343            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;344      }
;;;345    
;;;346      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
000050  7b06              LDRB     r6,[r0,#0xc]
000052  2e01              CMP      r6,#1
000054  d112              BNE      |L7.124|
;;;347      {
;;;348        /* 32-bit scale for the filter */
;;;349        CAN1->FS1R |= filter_number_bit_pos;
000056  682e              LDR      r6,[r5,#0]
000058  430e              ORRS     r6,r6,r1
00005a  602e              STR      r6,[r5,#0]
;;;350        /* 32-bit identifier or First 32-bit identifier */
;;;351        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00005c  7a86              LDRB     r6,[r0,#0xa]
00005e  6805              LDR      r5,[r0,#0]
000060  eb0406c6          ADD      r6,r4,r6,LSL #3
000064  ea4f4535          ROR      r5,r5,#16
000068  f8c65640          STR      r5,[r6,#0x640]
;;;352           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;353            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;354        /* 32-bit mask or Second 32-bit identifier */
;;;355        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00006c  7a86              LDRB     r6,[r0,#0xa]
00006e  6845              LDR      r5,[r0,#4]
000070  eb0404c6          ADD      r4,r4,r6,LSL #3
000074  ea4f4535          ROR      r5,r5,#16
000078  f8c45644          STR      r5,[r4,#0x644]
                  |L7.124|
;;;356           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;357            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;358      }
;;;359    
;;;360      /* Filter Mode */
;;;361      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
;;;362      {
;;;363        /*Id/Mask mode for the filter*/
;;;364        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
00007c  4c11              LDR      r4,|L7.196|
00007e  7ac5              LDRB     r5,[r0,#0xb]          ;361
000080  1d24              ADDS     r4,r4,#4
000082  2d00              CMP      r5,#0                 ;361
;;;365      }
;;;366      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;367      {
;;;368        /*Identifier list mode for the filter*/
;;;369        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
000084  6825              LDR      r5,[r4,#0]
000086  d006              BEQ      |L7.150|
000088  430d              ORRS     r5,r5,r1
                  |L7.138|
00008a  6025              STR      r5,[r4,#0]
;;;370      }
;;;371    
;;;372      /* Filter FIFO assignment */
;;;373      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
;;;374      {
;;;375        /* FIFO 0 assignation for the filter */
;;;376        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
00008c  4c0d              LDR      r4,|L7.196|
00008e  8905              LDRH     r5,[r0,#8]            ;373
000090  3414              ADDS     r4,r4,#0x14
000092  b115              CBZ      r5,|L7.154|
000094  e004              B        |L7.160|
                  |L7.150|
000096  438d              BICS     r5,r5,r1              ;364
000098  e7f7              B        |L7.138|
                  |L7.154|
00009a  6825              LDR      r5,[r4,#0]
00009c  438d              BICS     r5,r5,r1
00009e  6025              STR      r5,[r4,#0]
                  |L7.160|
;;;377      }
;;;378    
;;;379      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0000a0  8905              LDRH     r5,[r0,#8]
0000a2  2d01              CMP      r5,#1
0000a4  d102              BNE      |L7.172|
;;;380      {
;;;381        /* FIFO 1 assignation for the filter */
;;;382        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000a6  6825              LDR      r5,[r4,#0]
0000a8  430d              ORRS     r5,r5,r1
0000aa  6025              STR      r5,[r4,#0]
                  |L7.172|
;;;383      }
;;;384      
;;;385      /* Filter activation */
;;;386      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000ac  7b40              LDRB     r0,[r0,#0xd]
0000ae  2801              CMP      r0,#1
0000b0  d102              BNE      |L7.184|
;;;387      {
;;;388        CAN1->FA1R |= filter_number_bit_pos;
0000b2  6818              LDR      r0,[r3,#0]
0000b4  4308              ORRS     r0,r0,r1
0000b6  6018              STR      r0,[r3,#0]
                  |L7.184|
;;;389      }
;;;390    
;;;391      /* Leave the initialisation mode for the filter */
;;;392      CAN1->FMR &= ~FMR_FINIT;
0000b8  6810              LDR      r0,[r2,#0]
0000ba  f0200001          BIC      r0,r0,#1
0000be  6010              STR      r0,[r2,#0]
;;;393    }
0000c0  bdf0              POP      {r4-r7,pc}
;;;394    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L7.196|
                          DCD      0x40006600
                  |L7.200|
                          DCD      0x40006000

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;1257     */
;;;1258   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4602              MOV      r2,r0
;;;1259   {
;;;1260     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1261     
;;;1262     /* Check the parameters */
;;;1263     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1264     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1265     
;;;1266   
;;;1267     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
000004  f4110f70          TST      r1,#0xf00000
000008  d003              BEQ      |L8.18|
;;;1268     { 
;;;1269       /* Check the status of the specified CAN flag */
;;;1270       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00000a  6992              LDR      r2,[r2,#0x18]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;1271       { 
;;;1272         /* CAN_FLAG is set */
;;;1273         bitstatus = SET;
00000e  2001              MOVS     r0,#1
;;;1274       }
;;;1275       else
;;;1276       { 
;;;1277         /* CAN_FLAG is reset */
;;;1278         bitstatus = RESET;
;;;1279       }
;;;1280     }
;;;1281     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
;;;1282     { 
;;;1283       /* Check the status of the specified CAN flag */
;;;1284       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1285       { 
;;;1286         /* CAN_FLAG is set */
;;;1287         bitstatus = SET;
;;;1288       }
;;;1289       else
;;;1290       { 
;;;1291         /* CAN_FLAG is reset */
;;;1292         bitstatus = RESET;
;;;1293       }
;;;1294     }
;;;1295     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
;;;1296     { 
;;;1297       /* Check the status of the specified CAN flag */
;;;1298       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1299       { 
;;;1300         /* CAN_FLAG is set */
;;;1301         bitstatus = SET;
;;;1302       }
;;;1303       else
;;;1304       { 
;;;1305         /* CAN_FLAG is reset */
;;;1306         bitstatus = RESET;
;;;1307       }
;;;1308     }
;;;1309     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
;;;1310     { 
;;;1311       /* Check the status of the specified CAN flag */
;;;1312       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1313       { 
;;;1314         /* CAN_FLAG is set */
;;;1315         bitstatus = SET;
;;;1316       }
;;;1317       else
;;;1318       { 
;;;1319         /* CAN_FLAG is reset */
;;;1320         bitstatus = RESET;
;;;1321       }
;;;1322     }
;;;1323     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1324     { 
;;;1325       /* Check the status of the specified CAN flag */
;;;1326       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1327       { 
;;;1328         /* CAN_FLAG is set */
;;;1329         bitstatus = SET;
;;;1330       }
;;;1331       else
;;;1332       { 
;;;1333         /* CAN_FLAG is reset */
;;;1334         bitstatus = RESET;
;;;1335       }
;;;1336     }
;;;1337     /* Return the CAN_FLAG status */
;;;1338     return  bitstatus;
;;;1339   }
000010  4770              BX       lr
                  |L8.18|
000012  01cb              LSLS     r3,r1,#7              ;1281
000014  d504              BPL      |L8.32|
000016  6852              LDR      r2,[r2,#4]            ;1284
                  |L8.24|
000018  400a              ANDS     r2,r2,r1              ;1270
00001a  0311              LSLS     r1,r2,#12             ;1270
00001c  d1f7              BNE      |L8.14|
00001e  4770              BX       lr
                  |L8.32|
000020  010b              LSLS     r3,r1,#4
000022  d501              BPL      |L8.40|
000024  6892              LDR      r2,[r2,#8]            ;1298
000026  e7f7              B        |L8.24|
                  |L8.40|
000028  018b              LSLS     r3,r1,#6              ;1309
00002a  d501              BPL      |L8.48|
00002c  68d2              LDR      r2,[r2,#0xc]          ;1312
00002e  e7f3              B        |L8.24|
                  |L8.48|
000030  6912              LDR      r2,[r2,#0x10]         ;1326
000032  e7f1              B        |L8.24|
;;;1340   
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1417     */
;;;1418   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  4602              MOV      r2,r0
;;;1419   {
;;;1420     ITStatus itstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1421     /* Check the parameters */
;;;1422     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1423     assert_param(IS_CAN_IT(CAN_IT));
;;;1424     
;;;1425     /* check the interrupt enable bit */
;;;1426    if((CANx->IER & CAN_IT) != RESET)
000004  6953              LDR      r3,[r2,#0x14]
000006  420b              TST      r3,r1
000008  d04a              BEQ      |L9.160|
;;;1427    {
;;;1428      /* in case the Interrupt is enabled, .... */
;;;1429       switch (CAN_IT)
00000a  f5b17f80          CMP      r1,#0x100
00000e  d03b              BEQ      |L9.136|
000010  dc13              BGT      |L9.58|
000012  2908              CMP      r1,#8
000014  d02e              BEQ      |L9.116|
000016  dc07              BGT      |L9.40|
000018  2901              CMP      r1,#1
00001a  d026              BEQ      |L9.106|
00001c  2902              CMP      r1,#2
00001e  d027              BEQ      |L9.112|
000020  2904              CMP      r1,#4
000022  d13d              BNE      |L9.160|
;;;1430       {
;;;1431         case CAN_IT_TME:
;;;1432           /* Check CAN_TSR_RQCPx bits */
;;;1433           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
;;;1434           break;
;;;1435         case CAN_IT_FMP0:
;;;1436           /* Check CAN_RF0R_FMP0 bit */
;;;1437           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
;;;1438           break;
;;;1439         case CAN_IT_FF0:
;;;1440           /* Check CAN_RF0R_FULL0 bit */
;;;1441           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
000024  68d0              LDR      r0,[r2,#0xc]
;;;1442           break;
000026  e02b              B        |L9.128|
                  |L9.40|
000028  2910              CMP      r1,#0x10              ;1429
00002a  d025              BEQ      |L9.120|
00002c  2920              CMP      r1,#0x20              ;1429
00002e  d026              BEQ      |L9.126|
000030  2940              CMP      r1,#0x40              ;1429
000032  d135              BNE      |L9.160|
;;;1443         case CAN_IT_FOV0:
;;;1444           /* Check CAN_RF0R_FOVR0 bit */
;;;1445           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
;;;1446           break;
;;;1447         case CAN_IT_FMP1:
;;;1448           /* Check CAN_RF1R_FMP1 bit */
;;;1449           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
;;;1450           break;
;;;1451         case CAN_IT_FF1:
;;;1452           /* Check CAN_RF1R_FULL1 bit */
;;;1453           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
;;;1454           break;
;;;1455         case CAN_IT_FOV1:
;;;1456           /* Check CAN_RF1R_FOVR1 bit */
;;;1457           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
000034  6910              LDR      r0,[r2,#0x10]
                  |L9.54|
000036  2110              MOVS     r1,#0x10              ;1445
000038  e030              B        |L9.156|
                  |L9.58|
00003a  f5b14f00          CMP      r1,#0x8000            ;1429
00003e  d02b              BEQ      |L9.152|
000040  dc0b              BGT      |L9.90|
000042  f5b17f00          CMP      r1,#0x200             ;1429
000046  d022              BEQ      |L9.142|
000048  f5b16f80          CMP      r1,#0x400             ;1429
00004c  d022              BEQ      |L9.148|
00004e  f5b16f00          CMP      r1,#0x800             ;1429
000052  d125              BNE      |L9.160|
;;;1458           break;
;;;1459         case CAN_IT_WKU:
;;;1460           /* Check CAN_MSR_WKUI bit */
;;;1461           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
;;;1462           break;
;;;1463         case CAN_IT_SLK:
;;;1464           /* Check CAN_MSR_SLAKI bit */
;;;1465           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
;;;1466           break;
;;;1467         case CAN_IT_EWG:
;;;1468           /* Check CAN_ESR_EWGF bit */
;;;1469           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
;;;1470           break;
;;;1471         case CAN_IT_EPV:
;;;1472           /* Check CAN_ESR_EPVF bit */
;;;1473           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
;;;1474           break;
;;;1475         case CAN_IT_BOF:
;;;1476           /* Check CAN_ESR_BOFF bit */
;;;1477           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
;;;1478           break;
;;;1479         case CAN_IT_LEC:
;;;1480           /* Check CAN_ESR_LEC bit */
;;;1481           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
000054  6990              LDR      r0,[r2,#0x18]
000056  2170              MOVS     r1,#0x70
;;;1482           break;
000058  e020              B        |L9.156|
                  |L9.90|
00005a  f5b13f80          CMP      r1,#0x10000           ;1429
00005e  d011              BEQ      |L9.132|
000060  f5b13f00          CMP      r1,#0x20000           ;1429
000064  d11c              BNE      |L9.160|
000066  6850              LDR      r0,[r2,#4]            ;1465
000068  e7e5              B        |L9.54|
                  |L9.106|
00006a  6890              LDR      r0,[r2,#8]            ;1433
00006c  490d              LDR      r1,|L9.164|
00006e  e015              B        |L9.156|
                  |L9.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1437
000072  e002              B        |L9.122|
                  |L9.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;1445
000076  e7de              B        |L9.54|
                  |L9.120|
000078  6910              LDR      r0,[r2,#0x10]         ;1449
                  |L9.122|
00007a  2103              MOVS     r1,#3                 ;1437
00007c  e00e              B        |L9.156|
                  |L9.126|
00007e  6910              LDR      r0,[r2,#0x10]         ;1453
                  |L9.128|
000080  2108              MOVS     r1,#8                 ;1441
000082  e00b              B        |L9.156|
                  |L9.132|
000084  6850              LDR      r0,[r2,#4]            ;1461
000086  e7fb              B        |L9.128|
                  |L9.136|
000088  6990              LDR      r0,[r2,#0x18]         ;1469
00008a  2101              MOVS     r1,#1                 ;1469
00008c  e006              B        |L9.156|
                  |L9.142|
00008e  6990              LDR      r0,[r2,#0x18]         ;1473
000090  2102              MOVS     r1,#2                 ;1473
000092  e003              B        |L9.156|
                  |L9.148|
000094  6990              LDR      r0,[r2,#0x18]         ;1477
000096  e000              B        |L9.154|
                  |L9.152|
;;;1483         case CAN_IT_ERR:
;;;1484           /* Check CAN_MSR_ERRI bit */ 
;;;1485           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
000098  6850              LDR      r0,[r2,#4]
                  |L9.154|
00009a  2104              MOVS     r1,#4                 ;1477
                  |L9.156|
00009c  f7ffbffe          B.W      CheckITStatus
                  |L9.160|
;;;1486           break;
;;;1487         default:
;;;1488           /* in case of error, return RESET */
;;;1489           itstatus = RESET;
;;;1490           break;
;;;1491       }
;;;1492     }
;;;1493     else
;;;1494     {
;;;1495      /* in case the Interrupt is not enabled, return RESET */
;;;1496       itstatus  = RESET;
;;;1497     }
;;;1498     
;;;1499     /* Return the CAN_IT status */
;;;1500     return  itstatus;
;;;1501   }
0000a0  4770              BX       lr
;;;1502   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L9.164|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1058     */
;;;1059   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1060   {
;;;1061     uint8_t counter=0;
;;;1062     
;;;1063     /* Check the parameters */
;;;1064     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1065     
;;;1066     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1067     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
000002  f3c04007          UBFX     r0,r0,#16,#8
;;;1068     
;;;1069     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1070     return counter;
;;;1071   }
000006  4770              BX       lr
;;;1072   /**
                          ENDP


                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=1

                  CAN_GetLastErrorCode PROC
;;;1013     */
;;;1014   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1015   {
;;;1016     uint8_t errorcode=0;
;;;1017     
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1020     
;;;1021     /* Get the error code*/
;;;1022     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
000002  f3c01002          UBFX     r0,r0,#4,#3
000006  0100              LSLS     r0,r0,#4
;;;1023     
;;;1024     /* Return the error code*/
;;;1025     return errorcode;
;;;1026   }
000008  4770              BX       lr
;;;1027   
                          ENDP


                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetReceiveErrorCounter PROC
;;;1038     */
;;;1039   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1040   {
;;;1041     uint8_t counter=0;
;;;1042     
;;;1043     /* Check the parameters */
;;;1044     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1045     
;;;1046     /* Get the Receive Error Counter*/
;;;1047     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
000002  0e00              LSRS     r0,r0,#24
;;;1048     
;;;1049     /* Return the Receive Error Counter*/
;;;1050     return counter;
;;;1051   }
000004  4770              BX       lr
;;;1052   
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;1217     */
;;;1218   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1219   {
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1222     assert_param(IS_CAN_IT(CAN_IT));
;;;1223     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1224   
;;;1225     if (NewState != DISABLE)
;;;1226     {
;;;1227       /* Enable the selected CANx interrupt */
;;;1228       CANx->IER |= CAN_IT;
;;;1229     }
;;;1230     else
;;;1231     {
;;;1232       /* Disable the selected CANx interrupt */
;;;1233       CANx->IER &= ~CAN_IT;
000002  6942              LDR      r2,[r0,#0x14]
000004  d001              BEQ      |L13.10|
000006  430a              ORRS     r2,r2,r1              ;1228
000008  e000              B        |L13.12|
                  |L13.10|
00000a  438a              BICS     r2,r2,r1
                  |L13.12|
00000c  6142              STR      r2,[r0,#0x14]         ;1228
;;;1234     }
;;;1235   }
00000e  4770              BX       lr
;;;1236   /**
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;171      */
;;;172    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b538              PUSH     {r3-r5,lr}
;;;173    {
;;;174      uint8_t InitStatus = CAN_InitStatus_Failed;
;;;175      __IO uint32_t wait_ack = 0x00000000;
000002  2300              MOVS     r3,#0
;;;176      /* Check the parameters */
;;;177      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;178      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;179      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;180      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;181      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;182      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;183      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;184      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;185      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;186      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;187      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;188      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;189    
;;;190      /* Exit from sleep mode */
;;;191      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
000004  9300              STR      r3,[sp,#0]
000006  6802              LDR      r2,[r0,#0]
000008  f0220202          BIC      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
;;;192    
;;;193      /* Request initialisation */
;;;194      CANx->MCR |= CAN_MCR_INRQ ;
00000e  6802              LDR      r2,[r0,#0]
000010  f0420201          ORR      r2,r2,#1
000014  6002              STR      r2,[r0,#0]
;;;195    
;;;196      /* Wait the acknowledge */
;;;197      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000016  f06f427f          MVN      r2,#0xff000000
00001a  e001              B        |L14.32|
                  |L14.28|
00001c  1c64              ADDS     r4,r4,#1              ;173
;;;198      {
;;;199        wait_ack++;
00001e  9400              STR      r4,[sp,#0]
                  |L14.32|
000020  6844              LDR      r4,[r0,#4]            ;197
000022  07e4              LSLS     r4,r4,#31             ;197
000024  d102              BNE      |L14.44|
000026  9c00              LDR      r4,[sp,#0]            ;197
000028  4294              CMP      r4,r2                 ;197
00002a  d1f7              BNE      |L14.28|
                  |L14.44|
;;;200      }
;;;201    
;;;202      /* Check acknowledge */
;;;203      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
00002c  6844              LDR      r4,[r0,#4]
00002e  07e4              LSLS     r4,r4,#31
000030  d03e              BEQ      |L14.176|
;;;204      {
;;;205        InitStatus = CAN_InitStatus_Failed;
;;;206      }
;;;207      else 
;;;208      {
;;;209        /* Set the time triggered communication mode */
;;;210        if (CAN_InitStruct->CAN_TTCM == ENABLE)
000032  798c              LDRB     r4,[r1,#6]
000034  2c01              CMP      r4,#1
;;;211        {
;;;212          CANx->MCR |= CAN_MCR_TTCM;
;;;213        }
;;;214        else
;;;215        {
;;;216          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000036  6804              LDR      r4,[r0,#0]
000038  d03c              BEQ      |L14.180|
00003a  f0240480          BIC      r4,r4,#0x80
                  |L14.62|
00003e  6004              STR      r4,[r0,#0]
;;;217        }
;;;218    
;;;219        /* Set the automatic bus-off management */
;;;220        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000040  79cc              LDRB     r4,[r1,#7]
000042  2c01              CMP      r4,#1
;;;221        {
;;;222          CANx->MCR |= CAN_MCR_ABOM;
;;;223        }
;;;224        else
;;;225        {
;;;226          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000044  6804              LDR      r4,[r0,#0]
000046  d038              BEQ      |L14.186|
000048  f0240440          BIC      r4,r4,#0x40
                  |L14.76|
00004c  6004              STR      r4,[r0,#0]
;;;227        }
;;;228    
;;;229        /* Set the automatic wake-up mode */
;;;230        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00004e  7a0c              LDRB     r4,[r1,#8]
000050  2c01              CMP      r4,#1
;;;231        {
;;;232          CANx->MCR |= CAN_MCR_AWUM;
;;;233        }
;;;234        else
;;;235        {
;;;236          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
000052  6804              LDR      r4,[r0,#0]
000054  d034              BEQ      |L14.192|
000056  f0240420          BIC      r4,r4,#0x20
                  |L14.90|
00005a  6004              STR      r4,[r0,#0]
;;;237        }
;;;238    
;;;239        /* Set the no automatic retransmission */
;;;240        if (CAN_InitStruct->CAN_NART == ENABLE)
00005c  7a4c              LDRB     r4,[r1,#9]
00005e  2c01              CMP      r4,#1
;;;241        {
;;;242          CANx->MCR |= CAN_MCR_NART;
;;;243        }
;;;244        else
;;;245        {
;;;246          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
000060  6804              LDR      r4,[r0,#0]
000062  d030              BEQ      |L14.198|
000064  f0240410          BIC      r4,r4,#0x10
                  |L14.104|
000068  6004              STR      r4,[r0,#0]
;;;247        }
;;;248    
;;;249        /* Set the receive FIFO locked mode */
;;;250        if (CAN_InitStruct->CAN_RFLM == ENABLE)
00006a  7a8c              LDRB     r4,[r1,#0xa]
00006c  2c01              CMP      r4,#1
;;;251        {
;;;252          CANx->MCR |= CAN_MCR_RFLM;
;;;253        }
;;;254        else
;;;255        {
;;;256          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
00006e  6804              LDR      r4,[r0,#0]
000070  d02c              BEQ      |L14.204|
000072  f0240408          BIC      r4,r4,#8
                  |L14.118|
000076  6004              STR      r4,[r0,#0]
;;;257        }
;;;258    
;;;259        /* Set the transmit FIFO priority */
;;;260        if (CAN_InitStruct->CAN_TXFP == ENABLE)
000078  7acc              LDRB     r4,[r1,#0xb]
00007a  2c01              CMP      r4,#1
;;;261        {
;;;262          CANx->MCR |= CAN_MCR_TXFP;
;;;263        }
;;;264        else
;;;265        {
;;;266          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
00007c  6804              LDR      r4,[r0,#0]
00007e  d028              BEQ      |L14.210|
000080  f0240404          BIC      r4,r4,#4
                  |L14.132|
000084  6004              STR      r4,[r0,#0]
;;;267        }
;;;268    
;;;269        /* Set the bit timing register */
;;;270        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
000086  788c              LDRB     r4,[r1,#2]
000088  78cd              LDRB     r5,[r1,#3]
00008a  07a4              LSLS     r4,r4,#30
00008c  ea446405          ORR      r4,r4,r5,LSL #24
000090  790d              LDRB     r5,[r1,#4]
000092  ea444405          ORR      r4,r4,r5,LSL #16
000096  794d              LDRB     r5,[r1,#5]
000098  8809              LDRH     r1,[r1,#0]
00009a  ea445405          ORR      r4,r4,r5,LSL #20
00009e  1e49              SUBS     r1,r1,#1
0000a0  430c              ORRS     r4,r4,r1
0000a2  61c4              STR      r4,[r0,#0x1c]
;;;271                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;272                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;273                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;274                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;275    
;;;276        /* Request leave initialisation */
;;;277        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
0000a4  6801              LDR      r1,[r0,#0]
0000a6  f0210101          BIC      r1,r1,#1
0000aa  6001              STR      r1,[r0,#0]
;;;278    
;;;279       /* Wait the acknowledge */
;;;280       wait_ack = 0;
0000ac  9300              STR      r3,[sp,#0]
0000ae  e015              B        |L14.220|
                  |L14.176|
0000b0  2000              MOVS     r0,#0                 ;205
;;;281    
;;;282       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
;;;283       {
;;;284         wait_ack++;
;;;285       }
;;;286    
;;;287        /* ...and check acknowledged */
;;;288        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
;;;289        {
;;;290          InitStatus = CAN_InitStatus_Failed;
;;;291        }
;;;292        else
;;;293        {
;;;294          InitStatus = CAN_InitStatus_Success ;
;;;295        }
;;;296      }
;;;297    
;;;298      /* At this step, return the status of initialization */
;;;299      return InitStatus;
;;;300    }
0000b2  bd38              POP      {r3-r5,pc}
                  |L14.180|
0000b4  f0440480          ORR      r4,r4,#0x80           ;212
0000b8  e7c1              B        |L14.62|
                  |L14.186|
0000ba  f0440440          ORR      r4,r4,#0x40           ;222
0000be  e7c5              B        |L14.76|
                  |L14.192|
0000c0  f0440420          ORR      r4,r4,#0x20           ;232
0000c4  e7c9              B        |L14.90|
                  |L14.198|
0000c6  f0440410          ORR      r4,r4,#0x10           ;242
0000ca  e7cd              B        |L14.104|
                  |L14.204|
0000cc  f0440408          ORR      r4,r4,#8              ;252
0000d0  e7d1              B        |L14.118|
                  |L14.210|
0000d2  f0440404          ORR      r4,r4,#4              ;262
0000d6  e7d5              B        |L14.132|
                  |L14.216|
0000d8  1c49              ADDS     r1,r1,#1              ;262
0000da  9100              STR      r1,[sp,#0]            ;284
                  |L14.220|
0000dc  6841              LDR      r1,[r0,#4]            ;282
0000de  07c9              LSLS     r1,r1,#31             ;282
0000e0  d002              BEQ      |L14.232|
0000e2  9900              LDR      r1,[sp,#0]            ;282
0000e4  4291              CMP      r1,r2                 ;282
0000e6  d1f7              BNE      |L14.216|
                  |L14.232|
0000e8  6840              LDR      r0,[r0,#4]            ;288
0000ea  07c0              LSLS     r0,r0,#31             ;288
0000ec  d1e0              BNE      |L14.176|
0000ee  2001              MOVS     r0,#1                 ;294
0000f0  bd38              POP      {r3-r5,pc}
;;;301    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;795      */
;;;796    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;797    {
;;;798      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
000004  b129              CBZ      r1,|L15.18|
;;;799      /* Check the parameters */
;;;800      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;801      assert_param(IS_CAN_FIFO(FIFONumber));
;;;802      if (FIFONumber == CAN_FIFO0)
;;;803      {
;;;804        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
;;;805      }
;;;806      else if (FIFONumber == CAN_FIFO1)
000006  2901              CMP      r1,#1
000008  d102              BNE      |L15.16|
;;;807      {
;;;808        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
00000a  6910              LDR      r0,[r2,#0x10]
                  |L15.12|
00000c  f0000003          AND      r0,r0,#3              ;804
                  |L15.16|
;;;809      }
;;;810      else
;;;811      {
;;;812        message_pending = 0;
;;;813      }
;;;814      return message_pending;
;;;815    }
000010  4770              BX       lr
                  |L15.18|
000012  68d0              LDR      r0,[r2,#0xc]          ;804
000014  e7fa              B        |L15.12|
;;;816    /**
                          ENDP


                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=1

                  CAN_OperatingModeRequest PROC
;;;845      */
;;;846    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  2300              MOVS     r3,#0
;;;847    {
;;;848      uint8_t status = CAN_ModeStatus_Failed;
;;;849      
;;;850      /* Timeout for INAK or also for SLAK bits*/
;;;851      uint32_t timeout = INAK_TIMEOUT; 
000002  f06f427f          MVN      r2,#0xff000000
000006  b121              CBZ      r1,|L16.18|
;;;852    
;;;853      /* Check the parameters */
;;;854      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;855      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;856    
;;;857      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
;;;858      {
;;;859        /* Request initialisation */
;;;860        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
;;;861    
;;;862        /* Wait the acknowledge */
;;;863        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
;;;864        {
;;;865          timeout--;
;;;866        }
;;;867        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
;;;868        {
;;;869          status = CAN_ModeStatus_Failed;
;;;870        }
;;;871        else
;;;872        {
;;;873          status = CAN_ModeStatus_Success;
;;;874        }
;;;875      }
;;;876      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
000008  2901              CMP      r1,#1
00000a  d017              BEQ      |L16.60|
;;;877      {
;;;878        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;879        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
;;;880    
;;;881        /* Wait the acknowledge */
;;;882        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
;;;883        {
;;;884          timeout--;
;;;885        }
;;;886        if ((CANx->MSR & CAN_MODE_MASK) != 0)
;;;887        {
;;;888          status = CAN_ModeStatus_Failed;
;;;889        }
;;;890        else
;;;891        {
;;;892          status = CAN_ModeStatus_Success;
;;;893        }
;;;894      }
;;;895      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00000c  2902              CMP      r1,#2
00000e  d024              BEQ      |L16.90|
000010  e03a              B        |L16.136|
                  |L16.18|
000012  6801              LDR      r1,[r0,#0]            ;860
000014  f0210102          BIC      r1,r1,#2              ;860
000018  f0410101          ORR      r1,r1,#1              ;860
00001c  6001              STR      r1,[r0,#0]            ;860
00001e  e000              B        |L16.34|
                  |L16.32|
000020  1e52              SUBS     r2,r2,#1              ;863
                  |L16.34|
000022  6841              LDR      r1,[r0,#4]            ;863
000024  f0010103          AND      r1,r1,#3              ;863
000028  2901              CMP      r1,#1                 ;863
00002a  d001              BEQ      |L16.48|
00002c  2a00              CMP      r2,#0                 ;863
00002e  d1f7              BNE      |L16.32|
                  |L16.48|
000030  6840              LDR      r0,[r0,#4]            ;867
000032  f0000003          AND      r0,r0,#3              ;867
000036  2801              CMP      r0,#1                 ;867
000038  d123              BNE      |L16.130|
00003a  e024              B        |L16.134|
                  |L16.60|
00003c  6801              LDR      r1,[r0,#0]            ;879
00003e  f0210103          BIC      r1,r1,#3              ;879
000042  6001              STR      r1,[r0,#0]            ;879
000044  e000              B        |L16.72|
                  |L16.70|
000046  1e52              SUBS     r2,r2,#1              ;882
                  |L16.72|
000048  6841              LDR      r1,[r0,#4]            ;882
00004a  0789              LSLS     r1,r1,#30             ;882
00004c  d001              BEQ      |L16.82|
00004e  2a00              CMP      r2,#0                 ;882
000050  d1f9              BNE      |L16.70|
                  |L16.82|
000052  6840              LDR      r0,[r0,#4]            ;886
000054  0780              LSLS     r0,r0,#30             ;886
000056  d114              BNE      |L16.130|
000058  e015              B        |L16.134|
                  |L16.90|
;;;896      {
;;;897        /* Request Sleep mode */
;;;898        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  f0410102          ORR      r1,r1,#2
000064  6001              STR      r1,[r0,#0]
;;;899    
;;;900        /* Wait the acknowledge */
;;;901        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
000066  e000              B        |L16.106|
                  |L16.104|
000068  1e52              SUBS     r2,r2,#1
                  |L16.106|
00006a  6841              LDR      r1,[r0,#4]
00006c  f0010103          AND      r1,r1,#3
000070  2902              CMP      r1,#2
000072  d001              BEQ      |L16.120|
000074  2a00              CMP      r2,#0
000076  d1f7              BNE      |L16.104|
                  |L16.120|
;;;902        {
;;;903          timeout--;
;;;904        }
;;;905        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
000078  6840              LDR      r0,[r0,#4]
00007a  f0000003          AND      r0,r0,#3
00007e  2802              CMP      r0,#2
000080  d001              BEQ      |L16.134|
                  |L16.130|
;;;906        {
;;;907          status = CAN_ModeStatus_Failed;
000082  2300              MOVS     r3,#0
000084  e000              B        |L16.136|
                  |L16.134|
;;;908        }
;;;909        else
;;;910        {
;;;911          status = CAN_ModeStatus_Success;
000086  2301              MOVS     r3,#1
                  |L16.136|
;;;912        }
;;;913      }
;;;914      else
;;;915      {
;;;916        status = CAN_ModeStatus_Failed;
;;;917      }
;;;918    
;;;919      return  (uint8_t) status;
000088  4618              MOV      r0,r3
;;;920    }
00008a  4770              BX       lr
;;;921    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=2

                  CAN_Receive PROC
;;;723      */
;;;724    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b510              PUSH     {r4,lr}
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;728      assert_param(IS_CAN_FIFO(FIFONumber));
;;;729      /* Get the Id */
;;;730      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000002  eb001301          ADD      r3,r0,r1,LSL #4
000006  f8d341b0          LDR      r4,[r3,#0x1b0]
00000a  f0140404          ANDS     r4,r4,#4
00000e  7214              STRB     r4,[r2,#8]
;;;731      if (RxMessage->IDE == CAN_Id_Standard)
;;;732      {
;;;733        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;734      }
;;;735      else
;;;736      {
;;;737        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000010  f8d341b0          LDR      r4,[r3,#0x1b0]
000014  d034              BEQ      |L17.128|
000016  08e4              LSRS     r4,r4,#3
000018  f8c24004          STR.W    r4,[r2,#4]
                  |L17.28|
;;;738      }
;;;739      
;;;740      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
00001c  f8d341b0          LDR      r4,[r3,#0x1b0]
000020  f0040402          AND      r4,r4,#2
000024  7254              STRB     r4,[r2,#9]
;;;741      /* Get the DLC */
;;;742      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000026  f8d341b4          LDR      r4,[r3,#0x1b4]
00002a  f004040f          AND      r4,r4,#0xf
00002e  7294              STRB     r4,[r2,#0xa]
;;;743      /* Get the FMI */
;;;744      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000030  f8d341b4          LDR      r4,[r3,#0x1b4]
000034  0a24              LSRS     r4,r4,#8
000036  74d4              STRB     r4,[r2,#0x13]
;;;745      /* Get the data field */
;;;746      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000038  f8d341b8          LDR      r4,[r3,#0x1b8]
00003c  72d4              STRB     r4,[r2,#0xb]
;;;747      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
00003e  f8d341b8          LDR      r4,[r3,#0x1b8]
000042  0a24              LSRS     r4,r4,#8
000044  7314              STRB     r4,[r2,#0xc]
;;;748      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000046  f8d341b8          LDR      r4,[r3,#0x1b8]
00004a  0c24              LSRS     r4,r4,#16
00004c  7354              STRB     r4,[r2,#0xd]
;;;749      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00004e  f8d341b8          LDR      r4,[r3,#0x1b8]
000052  0e24              LSRS     r4,r4,#24
000054  7394              STRB     r4,[r2,#0xe]
;;;750      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
000056  f8d341bc          LDR      r4,[r3,#0x1bc]
00005a  73d4              STRB     r4,[r2,#0xf]
;;;751      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
00005c  f8d341bc          LDR      r4,[r3,#0x1bc]
000060  0a24              LSRS     r4,r4,#8
000062  7414              STRB     r4,[r2,#0x10]
;;;752      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
000064  f8d341bc          LDR      r4,[r3,#0x1bc]
000068  0c24              LSRS     r4,r4,#16
00006a  7454              STRB     r4,[r2,#0x11]
;;;753      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
00006c  f8d331bc          LDR      r3,[r3,#0x1bc]
000070  0e1b              LSRS     r3,r3,#24
000072  7493              STRB     r3,[r2,#0x12]
;;;754      /* Release the FIFO */
;;;755      /* Release FIFO0 */
;;;756      if (FIFONumber == CAN_FIFO0)
000074  b139              CBZ      r1,|L17.134|
;;;757      {
;;;758        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;759      }
;;;760      /* Release FIFO1 */
;;;761      else /* FIFONumber == CAN_FIFO1 */
;;;762      {
;;;763        CANx->RF1R |= CAN_RF1R_RFOM1;
000076  6901              LDR      r1,[r0,#0x10]
000078  f0410120          ORR      r1,r1,#0x20
00007c  6101              STR      r1,[r0,#0x10]
;;;764      }
;;;765    }
00007e  bd10              POP      {r4,pc}
                  |L17.128|
000080  0d64              LSRS     r4,r4,#21             ;733
000082  6014              STR      r4,[r2,#0]            ;733
000084  e7ca              B        |L17.28|
                  |L17.134|
000086  68c1              LDR      r1,[r0,#0xc]          ;758
000088  f0410120          ORR      r1,r1,#0x20           ;758
00008c  60c1              STR      r1,[r0,#0xc]          ;758
00008e  bd10              POP      {r4,pc}
;;;766    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;442      */
;;;443    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  4909              LDR      r1,|L18.40|
;;;444    {
;;;445      /* Check the parameters */
;;;446      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;447      
;;;448      /* Enter Initialisation mode for the filter */
;;;449      CAN1->FMR |= FMR_FINIT;
000002  680a              LDR      r2,[r1,#0]
000004  f0420201          ORR      r2,r2,#1
000008  600a              STR      r2,[r1,#0]
;;;450      
;;;451      /* Select the start slave bank */
;;;452      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000a  680a              LDR      r2,[r1,#0]
00000c  f643730e          MOV      r3,#0x3f0e
000010  439a              BICS     r2,r2,r3
000012  600a              STR      r2,[r1,#0]
;;;453      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000014  680a              LDR      r2,[r1,#0]
000016  ea422000          ORR      r0,r2,r0,LSL #8
00001a  6008              STR      r0,[r1,#0]
;;;454      
;;;455      /* Leave Initialisation mode for the filter */
;;;456      CAN1->FMR &= ~FMR_FINIT;
00001c  6808              LDR      r0,[r1,#0]
00001e  f0200001          BIC      r0,r0,#1
000022  6008              STR      r0,[r1,#0]
;;;457    }
000024  4770              BX       lr
;;;458    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;926      */
;;;927    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  6802              LDR      r2,[r0,#0]
;;;928    {
;;;929      uint8_t sleepstatus = CAN_Sleep_Failed;
000002  2100              MOVS     r1,#0
;;;930      
;;;931      /* Check the parameters */
;;;932      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;933        
;;;934      /* Request Sleep mode */
;;;935       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000004  f0220201          BIC      r2,r2,#1
000008  f0420202          ORR      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
;;;936       
;;;937      /* Sleep mode status */
;;;938      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
00000e  6840              LDR      r0,[r0,#4]
000010  f0000003          AND      r0,r0,#3
000014  2802              CMP      r0,#2
000016  d100              BNE      |L19.26|
;;;939      {
;;;940        /* Sleep mode not entered */
;;;941        sleepstatus =  CAN_Sleep_Ok;
000018  2101              MOVS     r1,#1
                  |L19.26|
;;;942      }
;;;943      /* return sleep mode status */
;;;944       return (uint8_t)sleepstatus;
00001a  4608              MOV      r0,r1
;;;945    }
00001c  4770              BX       lr
;;;946    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;399      */
;;;400    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;401    {
;;;402      /* Reset CAN init structure parameters values */
;;;403      
;;;404      /* Initialize the time triggered communication mode */
;;;405      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;406      
;;;407      /* Initialize the automatic bus-off management */
;;;408      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;409      
;;;410      /* Initialize the automatic wake-up mode */
;;;411      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;412      
;;;413      /* Initialize the no automatic retransmission */
;;;414      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;415      
;;;416      /* Initialize the receive FIFO locked mode */
;;;417      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;418      
;;;419      /* Initialize the transmit FIFO priority */
;;;420      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;421      
;;;422      /* Initialize the CAN_Mode member */
;;;423      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;424      
;;;425      /* Initialize the CAN_SJW member */
;;;426      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;427      
;;;428      /* Initialize the CAN_BS1 member */
;;;429      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;430      
;;;431      /* Initialize the CAN_BS2 member */
;;;432      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;433      
;;;434      /* Initialize the CAN_Prescaler member */
;;;435      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;436    }
00001e  4770              BX       lr
;;;437    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=1

                  CAN_TTComModeCmd PROC
;;;496      */
;;;497    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;498    {
;;;499      /* Check the parameters */
;;;500      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;501      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;502      if (NewState != DISABLE)
;;;503      {
;;;504        /* Enable the TTCM mode */
;;;505        CANx->MCR |= CAN_MCR_TTCM;
;;;506    
;;;507        /* Set TGT bits */
;;;508        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
;;;509        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
;;;510        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
;;;511      }
;;;512      else
;;;513      {
;;;514        /* Disable the TTCM mode */
;;;515        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
000002  6801              LDR      r1,[r0,#0]
000004  d013              BEQ      |L21.46|
000006  f0410180          ORR      r1,r1,#0x80           ;505
00000a  6001              STR      r1,[r0,#0]            ;505
00000c  f8d01184          LDR      r1,[r0,#0x184]        ;508
000010  f4417180          ORR      r1,r1,#0x100          ;508
000014  f8c01184          STR      r1,[r0,#0x184]        ;508
000018  f8d01194          LDR      r1,[r0,#0x194]        ;509
00001c  f4417180          ORR      r1,r1,#0x100          ;509
000020  f8c01194          STR      r1,[r0,#0x194]        ;509
000024  f8d011a4          LDR      r1,[r0,#0x1a4]        ;510
000028  f4417180          ORR      r1,r1,#0x100          ;510
00002c  e012              B        |L21.84|
                  |L21.46|
00002e  f0210180          BIC      r1,r1,#0x80
000032  6001              STR      r1,[r0,#0]
;;;516    
;;;517        /* Reset TGT bits */
;;;518        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
000034  f8d01184          LDR      r1,[r0,#0x184]
000038  f4217180          BIC      r1,r1,#0x100
00003c  f8c01184          STR      r1,[r0,#0x184]
;;;519        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000040  f8d01194          LDR      r1,[r0,#0x194]
000044  f4217180          BIC      r1,r1,#0x100
000048  f8c01194          STR      r1,[r0,#0x194]
;;;520        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
00004c  f8d011a4          LDR      r1,[r0,#0x1a4]
000050  f4217180          BIC      r1,r1,#0x100
                  |L21.84|
000054  f8c011a4          STR      r1,[r0,#0x1a4]        ;510
;;;521      }
;;;522    }
000058  4770              BX       lr
;;;523    /**
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;550      */
;;;551    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;552    {
000002  4602              MOV      r2,r0
;;;553      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;554      /* Check the parameters */
;;;555      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;556      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;557      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;558      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;559    
;;;560      /* Select one empty transmit mailbox */
;;;561      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  015b              LSLS     r3,r3,#5
00000a  d408              BMI      |L22.30|
;;;562      {
;;;563        transmit_mailbox = 0;
;;;564      }
;;;565      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
00000c  6890              LDR      r0,[r2,#8]
00000e  0100              LSLS     r0,r0,#4
000010  d501              BPL      |L22.22|
;;;566      {
;;;567        transmit_mailbox = 1;
000012  2001              MOVS     r0,#1
000014  e003              B        |L22.30|
                  |L22.22|
;;;568      }
;;;569      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000016  6890              LDR      r0,[r2,#8]
000018  00c0              LSLS     r0,r0,#3
00001a  d537              BPL      |L22.140|
;;;570      {
;;;571        transmit_mailbox = 2;
00001c  2002              MOVS     r0,#2
                  |L22.30|
;;;572      }
;;;573      else
;;;574      {
;;;575        transmit_mailbox = CAN_TxStatus_NoMailBox;
;;;576      }
;;;577    
;;;578      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
;;;579      {
;;;580        /* Set up the Id */
;;;581        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00001e  eb021200          ADD      r2,r2,r0,LSL #4
000022  f8d23180          LDR      r3,[r2,#0x180]
000026  f0030301          AND      r3,r3,#1
00002a  f8c23180          STR      r3,[r2,#0x180]
;;;582        if (TxMessage->IDE == CAN_Id_Standard)
00002e  7a0b              LDRB     r3,[r1,#8]
000030  b373              CBZ      r3,|L22.144|
;;;583        {
;;;584          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;585          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
;;;586                                                      TxMessage->RTR);
;;;587        }
;;;588        else
;;;589        {
;;;590          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;591          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
000032  f8d24180          LDR      r4,[r2,#0x180]
000036  684d              LDR      r5,[r1,#4]
000038  431c              ORRS     r4,r4,r3
00003a  7a4b              LDRB     r3,[r1,#9]
00003c  ea4303c5          ORR      r3,r3,r5,LSL #3
000040  431c              ORRS     r4,r4,r3
000042  f8c24180          STR      r4,[r2,#0x180]
                  |L22.70|
;;;592                                                      TxMessage->IDE | \
;;;593                                                      TxMessage->RTR);
;;;594        }
;;;595        
;;;596        /* Set up the DLC */
;;;597        TxMessage->DLC &= (uint8_t)0x0000000F;
000046  7a8b              LDRB     r3,[r1,#0xa]
000048  f003030f          AND      r3,r3,#0xf
00004c  728b              STRB     r3,[r1,#0xa]
;;;598        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
00004e  f8d23184          LDR      r3,[r2,#0x184]
000052  f023030f          BIC      r3,r3,#0xf
000056  f8c23184          STR      r3,[r2,#0x184]
;;;599        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
00005a  f8d23184          LDR      r3,[r2,#0x184]
00005e  7a8c              LDRB     r4,[r1,#0xa]
000060  4323              ORRS     r3,r3,r4
000062  f8c23184          STR      r3,[r2,#0x184]
;;;600    
;;;601        /* Set up the data field */
;;;602        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
000066  7acb              LDRB     r3,[r1,#0xb]
000068  68cc              LDR      r4,[r1,#0xc]
00006a  ea432304          ORR      r3,r3,r4,LSL #8
00006e  f8c23188          STR      r3,[r2,#0x188]
;;;603                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;604                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;605                                                 ((uint32_t)TxMessage->Data[0]));
;;;606        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000072  7bcb              LDRB     r3,[r1,#0xf]
000074  6909              LDR      r1,[r1,#0x10]
000076  ea432101          ORR      r1,r3,r1,LSL #8
00007a  f8c2118c          STR      r1,[r2,#0x18c]
;;;607                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;608                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;609                                                 ((uint32_t)TxMessage->Data[4]));
;;;610        /* Request transmission */
;;;611        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00007e  f8d21180          LDR      r1,[r2,#0x180]
000082  f0410101          ORR      r1,r1,#1
000086  f8c21180          STR      r1,[r2,#0x180]
;;;612      }
;;;613      return transmit_mailbox;
;;;614    }
00008a  bd30              POP      {r4,r5,pc}
                  |L22.140|
00008c  2004              MOVS     r0,#4                 ;575
00008e  bd30              POP      {r4,r5,pc}
                  |L22.144|
000090  f8d23180          LDR      r3,[r2,#0x180]        ;585
000094  7a4c              LDRB     r4,[r1,#9]            ;585
000096  4323              ORRS     r3,r3,r4              ;585
000098  880c              LDRH     r4,[r1,#0]            ;585
00009a  ea435344          ORR      r3,r3,r4,LSL #21      ;585
00009e  f8c23180          STR      r3,[r2,#0x180]        ;585
0000a2  e7d0              B        |L22.70|
;;;615    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;622      */
;;;623    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  2200              MOVS     r2,#0
;;;624    {
000002  b121              CBZ      r1,|L23.14|
;;;625      uint32_t state = 0;
;;;626    
;;;627      /* Check the parameters */
;;;628      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;629      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;630     
;;;631      switch (TransmitMailbox)
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L23.20|
000008  2902              CMP      r1,#2
00000a  d106              BNE      |L23.26|
00000c  e012              B        |L23.52|
                  |L23.14|
;;;632      {
;;;633        case (CAN_TXMAILBOX_0): 
;;;634          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
00000e  6882              LDR      r2,[r0,#8]
000010  4811              LDR      r0,|L23.88|
;;;635          break;
000012  e001              B        |L23.24|
                  |L23.20|
;;;636        case (CAN_TXMAILBOX_1): 
;;;637          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
000014  6882              LDR      r2,[r0,#8]
000016  4811              LDR      r0,|L23.92|
                  |L23.24|
000018  4002              ANDS     r2,r2,r0              ;634
                  |L23.26|
;;;638          break;
;;;639        case (CAN_TXMAILBOX_2): 
;;;640          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
;;;641          break;
;;;642        default:
;;;643          state = CAN_TxStatus_Failed;
;;;644          break;
;;;645      }
;;;646      switch (state)
00001a  4911              LDR      r1,|L23.96|
00001c  1a50              SUBS     r0,r2,r1
00001e  428a              CMP      r2,r1
000020  d014              BEQ      |L23.76|
000022  dc0a              BGT      |L23.58|
000024  b1a2              CBZ      r2,|L23.80|
000026  f06f6080          MVN      r0,#0x4000000
00002a  1810              ADDS     r0,r2,r0
00002c  d00f              BEQ      |L23.78|
00002e  2802              CMP      r0,#2
000030  d10c              BNE      |L23.76|
000032  e00f              B        |L23.84|
                  |L23.52|
000034  6882              LDR      r2,[r0,#8]            ;640
000036  480b              LDR      r0,|L23.100|
000038  e7ee              B        |L23.24|
                  |L23.58|
00003a  f5b07f00          CMP      r0,#0x200
00003e  d009              BEQ      |L23.84|
000040  4909              LDR      r1,|L23.104|
000042  1840              ADDS     r0,r0,r1
000044  d003              BEQ      |L23.78|
000046  f5b03f00          CMP      r0,#0x20000
00004a  d003              BEQ      |L23.84|
                  |L23.76|
;;;647      {
;;;648          /* transmit pending  */
;;;649        case (0x0): state = CAN_TxStatus_Pending;
;;;650          break;
;;;651          /* transmit failed  */
;;;652         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
;;;653          break;
;;;654         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
;;;655          break;
;;;656         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
;;;657          break;
;;;658          /* transmit succeeded  */
;;;659        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
;;;660          break;
;;;661        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
;;;662          break;
;;;663        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
;;;664          break;
;;;665        default: state = CAN_TxStatus_Failed;
00004c  2000              MOVS     r0,#0
                  |L23.78|
;;;666          break;
;;;667      }
;;;668      return (uint8_t) state;
;;;669    }
00004e  4770              BX       lr
                  |L23.80|
000050  2002              MOVS     r0,#2                 ;649
000052  4770              BX       lr
                  |L23.84|
000054  2001              MOVS     r0,#1                 ;663
000056  4770              BX       lr
;;;670    
                          ENDP

                  |L23.88|
                          DCD      0x04000003
                  |L23.92|
                          DCD      0x08000300
                  |L23.96|
                          DCD      0x08000100
                  |L23.100|
                          DCD      0x10030000
                  |L23.104|
                          DCD      0xf7ff0100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;951      */
;;;952    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  6803              LDR      r3,[r0,#0]
;;;953    {
;;;954      uint32_t wait_slak = SLAK_TIMEOUT;
000002  f06f417f          MVN      r1,#0xff000000
;;;955      uint8_t wakeupstatus = CAN_WakeUp_Failed;
000006  2200              MOVS     r2,#0
;;;956      
;;;957      /* Check the parameters */
;;;958      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;959        
;;;960      /* Wake up request */
;;;961      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000008  f0230302          BIC      r3,r3,#2
00000c  6003              STR      r3,[r0,#0]
00000e  e000              B        |L24.18|
                  |L24.16|
000010  1e49              SUBS     r1,r1,#1              ;953
                  |L24.18|
;;;962        
;;;963      /* Sleep mode status */
;;;964      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000012  6843              LDR      r3,[r0,#4]
000014  079b              LSLS     r3,r3,#30
000016  d501              BPL      |L24.28|
000018  2900              CMP      r1,#0
00001a  d1f9              BNE      |L24.16|
                  |L24.28|
;;;965      {
;;;966       wait_slak--;
;;;967      }
;;;968      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
00001c  6840              LDR      r0,[r0,#4]
00001e  0780              LSLS     r0,r0,#30
000020  d400              BMI      |L24.36|
;;;969      {
;;;970       /* wake up done : Sleep mode exited */
;;;971        wakeupstatus = CAN_WakeUp_Ok;
000022  2201              MOVS     r2,#1
                  |L24.36|
;;;972      }
;;;973      /* return wakeup status */
;;;974      return (uint8_t)wakeupstatus;
000024  4610              MOV      r0,r2
;;;975    }
000026  4770              BX       lr
;;;976    /**
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1599     */
;;;1600   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1601   {
;;;1602     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1603     
;;;1604     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  420a              TST      r2,r1
000006  d000              BEQ      |L25.10|
;;;1605     {
;;;1606       /* CAN_IT is set */
;;;1607       pendingbitstatus = SET;
000008  2001              MOVS     r0,#1
                  |L25.10|
;;;1608     }
;;;1609     else
;;;1610     {
;;;1611       /* CAN_IT is reset */
;;;1612       pendingbitstatus = RESET;
;;;1613     }
;;;1614     return pendingbitstatus;
;;;1615   }
00000a  4770              BX       lr
;;;1616   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_can_c_347dae01____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f30x_can_c_347dae01____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_can_c_347dae01____REVSH|
#line 128
|__asm___15_stm32f30x_can_c_347dae01____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
