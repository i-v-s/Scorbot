; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_adc.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdog1SingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdog1SingleChannelConfig PROC
;;;807      */
;;;808    void ADC_AnalogWatchdog1SingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  68c2              LDR      r2,[r0,#0xc]
;;;809    {
;;;810      uint32_t tmpreg = 0;
;;;811      /* Check the parameters */
;;;812      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;813      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;814      /* Get the old register value */
;;;815      tmpreg = ADCx->CFGR;
;;;816      /* Clear the Analog watchdog channel select bits */
;;;817      tmpreg &= ~(uint32_t)ADC_CFGR_AWD1CH;
000002  f02242f8          BIC      r2,r2,#0x7c000000
;;;818      /* Set the Analog watchdog channel */
;;;819      tmpreg |= (uint32_t)((uint32_t)ADC_Channel << 26);
000006  ea426181          ORR      r1,r2,r1,LSL #26
;;;820      /* Store the new register value */
;;;821      ADCx->CFGR = tmpreg;
00000a  60c1              STR      r1,[r0,#0xc]
;;;822    }
00000c  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdog1ThresholdsConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdog1ThresholdsConfig PROC
;;;718      */
;;;719    void ADC_AnalogWatchdog1ThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  b510              PUSH     {r4,lr}
;;;720                                             uint16_t LowThreshold)
;;;721    {
;;;722      /* Check the parameters */
;;;723      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;724      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;725      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;726      /* Set the ADCx high threshold */
;;;727      ADCx->TR1 &= ~(uint32_t)ADC_TR1_HT1;
000002  6a03              LDR      r3,[r0,#0x20]
000004  4c07              LDR      r4,|L2.36|
000006  4023              ANDS     r3,r3,r4
000008  6203              STR      r3,[r0,#0x20]
;;;728      ADCx->TR1 |= (uint32_t)((uint32_t)HighThreshold << 16);
00000a  6a03              LDR      r3,[r0,#0x20]
00000c  ea434101          ORR      r1,r3,r1,LSL #16
000010  6201              STR      r1,[r0,#0x20]
;;;729    
;;;730      /* Set the ADCx low threshold */
;;;731      ADCx->TR1 &= ~(uint32_t)ADC_TR1_LT1;
000012  6a01              LDR      r1,[r0,#0x20]
000014  f36f010b          BFC      r1,#0,#12
000018  6201              STR      r1,[r0,#0x20]
;;;732      ADCx->TR1 |= LowThreshold;
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  4311              ORRS     r1,r1,r2
00001e  6201              STR      r1,[r0,#0x20]
;;;733    }
000020  bd10              POP      {r4,pc}
;;;734    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0xf000ffff

                          AREA ||i.ADC_AnalogWatchdog2SingleChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdog2SingleChannelConfig PROC
;;;848      */
;;;849    void ADC_AnalogWatchdog2SingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  f8503fa0          LDR      r3,[r0,#0xa0]!
;;;850    {
;;;851      uint32_t tmpreg = 0;
;;;852      /* Check the parameters */
;;;853      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;854      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;855      /* Get the old register value */
;;;856      tmpreg = ADCx->AWD2CR;
;;;857      /* Clear the Analog watchdog channel select bits */
;;;858      tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
000004  4a04              LDR      r2,|L3.24|
000006  4013              ANDS     r3,r3,r2
;;;859      /* Set the Analog watchdog channel */
;;;860      tmpreg |= (uint32_t)1 << (ADC_Channel);
000008  2201              MOVS     r2,#1
00000a  408a              LSLS     r2,r2,r1
;;;861      /* Store the new register value */
;;;862      ADCx->AWD2CR |= tmpreg;
00000c  6801              LDR      r1,[r0,#0]
00000e  431a              ORRS     r2,r2,r3              ;860
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;863    }
000014  4770              BX       lr
;;;864    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0xfff80001

                          AREA ||i.ADC_AnalogWatchdog2ThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdog2ThresholdsConfig PROC
;;;743      */
;;;744    void ADC_AnalogWatchdog2ThresholdsConfig(ADC_TypeDef* ADCx, uint8_t HighThreshold,
000000  6a43              LDR      r3,[r0,#0x24]
;;;745                                             uint8_t LowThreshold)
;;;746    {
;;;747      /* Check the parameters */
;;;748      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;749      
;;;750      /* Set the ADCx high threshold */
;;;751      ADCx->TR2 &= ~(uint32_t)ADC_TR2_HT2;
000002  f423037f          BIC      r3,r3,#0xff0000
000006  6243              STR      r3,[r0,#0x24]
;;;752      ADCx->TR2 |= (uint32_t)((uint32_t)HighThreshold << 16);
000008  6a43              LDR      r3,[r0,#0x24]
00000a  ea434101          ORR      r1,r3,r1,LSL #16
00000e  6241              STR      r1,[r0,#0x24]
;;;753    
;;;754      /* Set the ADCx low threshold */
;;;755      ADCx->TR2 &= ~(uint32_t)ADC_TR2_LT2;
000010  6a41              LDR      r1,[r0,#0x24]
000012  f02101ff          BIC      r1,r1,#0xff
000016  6241              STR      r1,[r0,#0x24]
;;;756      ADCx->TR2 |= LowThreshold;
000018  6a41              LDR      r1,[r0,#0x24]
00001a  4311              ORRS     r1,r1,r2
00001c  6241              STR      r1,[r0,#0x24]
;;;757    }
00001e  4770              BX       lr
;;;758    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdog3SingleChannelConfig||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdog3SingleChannelConfig PROC
;;;889      */
;;;890    void ADC_AnalogWatchdog3SingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  f8503fa4          LDR      r3,[r0,#0xa4]!
;;;891    {
;;;892      uint32_t tmpreg = 0;
;;;893      /* Check the parameters */
;;;894      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;895      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;896      /* Get the old register value */
;;;897      tmpreg = ADCx->AWD3CR;
;;;898      /* Clear the Analog watchdog channel select bits */
;;;899      tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
000004  4a04              LDR      r2,|L5.24|
000006  4013              ANDS     r3,r3,r2
;;;900      /* Set the Analog watchdog channel */
;;;901      tmpreg |= (uint32_t)1 << (ADC_Channel);
000008  2201              MOVS     r2,#1
00000a  408a              LSLS     r2,r2,r1
;;;902      /* Store the new register value */
;;;903      ADCx->AWD3CR |= tmpreg;
00000c  6801              LDR      r1,[r0,#0]
00000e  431a              ORRS     r2,r2,r3              ;901
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;904    }
000014  4770              BX       lr
;;;905    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0xfff80001

                          AREA ||i.ADC_AnalogWatchdog3ThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdog3ThresholdsConfig PROC
;;;767      */
;;;768    void ADC_AnalogWatchdog3ThresholdsConfig(ADC_TypeDef* ADCx, uint8_t HighThreshold,
000000  6a83              LDR      r3,[r0,#0x28]
;;;769                                             uint8_t LowThreshold)
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;773    
;;;774      /* Set the ADCx high threshold */
;;;775      ADCx->TR3 &= ~(uint32_t)ADC_TR3_HT3;
000002  f423037f          BIC      r3,r3,#0xff0000
000006  6283              STR      r3,[r0,#0x28]
;;;776      ADCx->TR3 |= (uint32_t)((uint32_t)HighThreshold << 16);
000008  6a83              LDR      r3,[r0,#0x28]
00000a  ea434101          ORR      r1,r3,r1,LSL #16
00000e  6281              STR      r1,[r0,#0x28]
;;;777    
;;;778      /* Set the ADCx low threshold */
;;;779      ADCx->TR3 &= ~(uint32_t)ADC_TR3_LT3;
000010  6a81              LDR      r1,[r0,#0x28]
000012  f02101ff          BIC      r1,r1,#0xff
000016  6281              STR      r1,[r0,#0x28]
;;;780      ADCx->TR3 |= LowThreshold;
000018  6a81              LDR      r1,[r0,#0x28]
00001a  4311              ORRS     r1,r1,r2
00001c  6281              STR      r1,[r0,#0x28]
;;;781    }
00001e  4770              BX       lr
;;;782    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogCmd PROC
;;;693      */
;;;694    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  68c2              LDR      r2,[r0,#0xc]
;;;695    {
;;;696      uint32_t tmpreg = 0;
;;;697      /* Check the parameters */
;;;698      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;699      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;700      /* Get the old register value */
;;;701      tmpreg = ADCx->CFGR;
;;;702      /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;703      tmpreg &= ~(uint32_t)(ADC_CFGR_AWD1SGL|ADC_CFGR_AWD1EN|ADC_CFGR_JAWD1EN);
000002  f02272e0          BIC      r2,r2,#0x1c00000
;;;704      /* Set the analog watchdog enable mode */
;;;705      tmpreg |= ADC_AnalogWatchdog;
000006  430a              ORRS     r2,r2,r1
;;;706      /* Store the new register value */
;;;707      ADCx->CFGR = tmpreg;
000008  60c2              STR      r2,[r0,#0xc]
;;;708    }
00000a  4770              BX       lr
;;;709    
                          ENDP


                          AREA ||i.ADC_AutoDelayCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoDelayCmd PROC
;;;626      */
;;;627    void ADC_AutoDelayCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;628    {
;;;629      /* Check the parameters */
;;;630      assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
;;;631      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;632    
;;;633      if (NewState != DISABLE)
;;;634      {
;;;635        /* Set the AUTDLY bit */
;;;636        ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
;;;637      }
;;;638      else
;;;639      {
;;;640        /* Reset the AUTDLY bit */
;;;641        ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_AUTDLY);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L8.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;636
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L8.16|
000010  60c1              STR      r1,[r0,#0xc]          ;636
;;;642      }
;;;643    }
000012  4770              BX       lr
;;;644    
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;1968     */
;;;1969   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1970   {
;;;1971     /* Check the parameters */
;;;1972     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1973     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1974     if (NewState != DISABLE)
;;;1975     {
;;;1976       /* Enable the selected ADC automatic injected group conversion */
;;;1977       ADCx->CFGR |= ADC_CFGR_JAUTO;
;;;1978     }
;;;1979     else
;;;1980     {
;;;1981       /* Disable the selected ADC automatic injected group conversion */
;;;1982       ADCx->CFGR &= ~ADC_CFGR_JAUTO;
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L9.12|
000006  f0417100          ORR      r1,r1,#0x2000000      ;1977
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f0217100          BIC      r1,r1,#0x2000000
                  |L9.16|
000010  60c1              STR      r1,[r0,#0xc]          ;1977
;;;1983     }
;;;1984   }
000012  4770              BX       lr
;;;1985   
                          ENDP


                          AREA ||i.ADC_ChannelOffset1Cmd||, CODE, READONLY, ALIGN=1

                  ADC_ChannelOffset1Cmd PROC
;;;1648     */
;;;1649   void ADC_ChannelOffset1Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1650   {
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1653     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1654   
;;;1655     if (NewState != DISABLE)
;;;1656     {
;;;1657       /* Set the OFFSET1_EN bit */
;;;1658       ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
;;;1659     }
;;;1660     else
;;;1661     {
;;;1662       /* Reset the OFFSET1_EN bit */
;;;1663       ADCx->OFR1 &= ~(ADC_OFR1_OFFSET1_EN);
000002  6e01              LDR      r1,[r0,#0x60]
000004  d002              BEQ      |L10.12|
000006  f0414100          ORR      r1,r1,#0x80000000     ;1658
00000a  e001              B        |L10.16|
                  |L10.12|
00000c  f0214100          BIC      r1,r1,#0x80000000
                  |L10.16|
000010  6601              STR      r1,[r0,#0x60]         ;1658
;;;1664     }
;;;1665   }
000012  4770              BX       lr
;;;1666   
                          ENDP


                          AREA ||i.ADC_ChannelOffset2Cmd||, CODE, READONLY, ALIGN=1

                  ADC_ChannelOffset2Cmd PROC
;;;1673     */
;;;1674   void ADC_ChannelOffset2Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1675   {
;;;1676     /* Check the parameters */
;;;1677     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1678     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1679   
;;;1680     if (NewState != DISABLE)
;;;1681     {
;;;1682       /* Set the OFFSET1_EN bit */
;;;1683       ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
;;;1684     }
;;;1685     else
;;;1686     {
;;;1687       /* Reset the OFFSET1_EN bit */
;;;1688       ADCx->OFR2 &= ~(ADC_OFR2_OFFSET2_EN);
000002  6e41              LDR      r1,[r0,#0x64]
000004  d002              BEQ      |L11.12|
000006  f0414100          ORR      r1,r1,#0x80000000     ;1683
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0214100          BIC      r1,r1,#0x80000000
                  |L11.16|
000010  6641              STR      r1,[r0,#0x64]         ;1683
;;;1689     }
;;;1690   }
000012  4770              BX       lr
;;;1691   
                          ENDP


                          AREA ||i.ADC_ChannelOffset3Cmd||, CODE, READONLY, ALIGN=1

                  ADC_ChannelOffset3Cmd PROC
;;;1698     */
;;;1699   void ADC_ChannelOffset3Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1700   {
;;;1701     /* Check the parameters */
;;;1702     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1703     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1704   
;;;1705     if (NewState != DISABLE)
;;;1706     {
;;;1707       /* Set the OFFSET1_EN bit */
;;;1708       ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
;;;1709     }
;;;1710     else
;;;1711     {
;;;1712       /* Reset the OFFSET1_EN bit */
;;;1713       ADCx->OFR3 &= ~(ADC_OFR3_OFFSET3_EN);
000002  6e81              LDR      r1,[r0,#0x68]
000004  d002              BEQ      |L12.12|
000006  f0414100          ORR      r1,r1,#0x80000000     ;1708
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  f0214100          BIC      r1,r1,#0x80000000
                  |L12.16|
000010  6681              STR      r1,[r0,#0x68]         ;1708
;;;1714     }
;;;1715   }
000012  4770              BX       lr
;;;1716   
                          ENDP


                          AREA ||i.ADC_ChannelOffset4Cmd||, CODE, READONLY, ALIGN=1

                  ADC_ChannelOffset4Cmd PROC
;;;1723     */
;;;1724   void ADC_ChannelOffset4Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1725   {
;;;1726     /* Check the parameters */
;;;1727     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1728     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1729   
;;;1730     if (NewState != DISABLE)
;;;1731     {
;;;1732       /* Set the OFFSET1_EN bit */
;;;1733       ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
;;;1734     }
;;;1735     else
;;;1736     {
;;;1737       /* Reset the OFFSET1_EN bit */
;;;1738       ADCx->OFR4 &= ~(ADC_OFR4_OFFSET4_EN);
000002  6ec1              LDR      r1,[r0,#0x6c]
000004  d002              BEQ      |L13.12|
000006  f0414100          ORR      r1,r1,#0x80000000     ;1733
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0214100          BIC      r1,r1,#0x80000000
                  |L13.16|
000010  66c1              STR      r1,[r0,#0x6c]         ;1733
;;;1739     }
;;;1740   }
000012  4770              BX       lr
;;;1741   
                          ENDP


                          AREA ||i.ADC_ClearCommonFlag||, CODE, READONLY, ALIGN=2

                  ADC_ClearCommonFlag PROC
;;;2331     */
;;;2332   void ADC_ClearCommonFlag(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
000000  f04f42a0          MOV      r2,#0x50000000
;;;2333   {
;;;2334     /* Check the parameters */
;;;2335     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2336     assert_param(IS_ADC_CLEAR_COMMONFLAG(ADC_FLAG));
;;;2337   
;;;2338     if((ADCx == ADC1) || (ADCx == ADC2))
000004  4290              CMP      r0,r2
000006  d002              BEQ      |L14.14|
000008  4b06              LDR      r3,|L14.36|
00000a  4298              CMP      r0,r3
00000c  d105              BNE      |L14.26|
                  |L14.14|
;;;2339     {
;;;2340       /* Clear the selected ADC flags */
;;;2341       ADC1_2->CSR |= (uint32_t)ADC_FLAG;
00000e  f8d20300          LDR      r0,[r2,#0x300]
000012  4308              ORRS     r0,r0,r1
000014  f8c20300          STR      r0,[r2,#0x300]
;;;2342     }
;;;2343     else
;;;2344     {
;;;2345       /* Clear the selected ADC flags */
;;;2346       ADC3_4->CSR |= (uint32_t)ADC_FLAG;
;;;2347     }  
;;;2348   }
000018  4770              BX       lr
                  |L14.26|
00001a  4803              LDR      r0,|L14.40|
00001c  6802              LDR      r2,[r0,#0]            ;2346
00001e  430a              ORRS     r2,r2,r1              ;2346
000020  6002              STR      r2,[r0,#0]            ;2346
000022  4770              BX       lr
;;;2349   
                          ENDP

                  |L14.36|
                          DCD      0x50000100
                  |L14.40|
                          DCD      0x50000700

                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;2232     */
;;;2233   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
000000  6001              STR      r1,[r0,#0]
;;;2234   {
;;;2235     /* Check the parameters */
;;;2236     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2237     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;2238     /* Clear the selected ADC flags */
;;;2239     ADCx->ISR = (uint32_t)ADC_FLAG;
;;;2240   }
000002  4770              BX       lr
;;;2241   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;2407     */
;;;2408   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint32_t ADC_IT)
000000  6802              LDR      r2,[r0,#0]
;;;2409   {
;;;2410     /* Check the parameters */
;;;2411     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2412     assert_param(IS_ADC_IT(ADC_IT));
;;;2413     /* Clear the selected ADC interrupt pending bit */
;;;2414     ADCx->ISR |= (uint32_t)ADC_IT;
000002  430a              ORRS     r2,r2,r1
000004  6002              STR      r2,[r0,#0]
;;;2415   }
000006  4770              BX       lr
;;;2416   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;378      */
;;;379    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;380    {
;;;381      /* Check the parameters */
;;;382      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;383      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;384    
;;;385      if (NewState != DISABLE)
;;;386      {
;;;387        /* Set the ADEN bit */
;;;388        ADCx->CR |= ADC_CR_ADEN;
;;;389      }
;;;390      else
;;;391      {
;;;392        /* Disable the selected ADC peripheral: Set the ADDIS bit */
;;;393        ADCx->CR |= ADC_CR_ADDIS;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L17.12|
000006  f0410101          ORR      r1,r1,#1              ;388
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f0410102          ORR      r1,r1,#2
                  |L17.16|
000010  6081              STR      r1,[r0,#8]            ;388
;;;394      }
;;;395    }
000012  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.ADC_CommonInit||, CODE, READONLY, ALIGN=2

                  ADC_CommonInit PROC
;;;294      */
;;;295    void ADC_CommonInit(ADC_TypeDef* ADCx, ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;296    {
;;;297      uint32_t tmpreg1 = 0;
;;;298      /* Check the parameters */
;;;299      assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
;;;300      assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
;;;301      assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
;;;302      assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
;;;303      assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
;;;304    
;;;305      if((ADCx == ADC1) || (ADCx == ADC2))
000002  f04f43a0          MOV      r3,#0x50000000
;;;306      {
;;;307        /* Get the ADC CCR value */
;;;308        tmpreg1 = ADC1_2->CCR;
;;;309      
;;;310        /* Clear MULTI, DELAY, DMA and ADCPRE bits */
;;;311        tmpreg1 &= CCR_CLEAR_MASK;
000006  4e10              LDR      r6,|L18.72|
000008  4c10              LDR      r4,|L18.76|
;;;312      }
;;;313      else
;;;314      {
;;;315        /* Get the ADC CCR value */
;;;316        tmpreg1 = ADC3_4->CCR;
00000a  4d11              LDR      r5,|L18.80|
00000c  4298              CMP      r0,r3                 ;305
00000e  d001              BEQ      |L18.20|
000010  42a0              CMP      r0,r4                 ;305
000012  d102              BNE      |L18.26|
                  |L18.20|
000014  f8d32308          LDR      r2,[r3,#0x308]        ;308
000018  e000              B        |L18.28|
                  |L18.26|
00001a  682a              LDR      r2,[r5,#0]
                  |L18.28|
;;;317      
;;;318        /* Clear MULTI, DELAY, DMA and ADCPRE bits */
;;;319        tmpreg1 &= CCR_CLEAR_MASK;
00001c  4032              ANDS     r2,r2,r6
00001e  e9d16700          LDRD     r6,r7,[r1,#0]
;;;320      }
;;;321      /*---------------------------- ADC CCR Configuration -----------------*/  
;;;322      /* Configure ADCx: Multi mode, Delay between two sampling time, ADC clock, DMA mode
;;;323         and DMA access mode for dual mode */
;;;324      /* Set MULTI bits according to ADC_Mode value */
;;;325      /* Set CKMODE bits according to ADC_Clock value */
;;;326      /* Set MDMA bits according to ADC_DMAAccessMode value */
;;;327      /* Set DMACFG bits according to ADC_DMAMode value */
;;;328      /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
;;;329      tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
000022  433e              ORRS     r6,r6,r7
000024  e9d17c02          LDRD     r7,r12,[r1,#8]
000028  ea47370c          ORR      r7,r7,r12,LSL #12
00002c  7c09              LDRB     r1,[r1,#0x10]
00002e  433e              ORRS     r6,r6,r7
000030  ea462101          ORR      r1,r6,r1,LSL #8
000034  4311              ORRS     r1,r1,r2
;;;330                            ADC_CommonInitStruct->ADC_Clock | 
;;;331                            ADC_CommonInitStruct->ADC_DMAAccessMode | 
;;;332                            (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
;;;333                            (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));
;;;334    
;;;335      if((ADCx == ADC1) || (ADCx == ADC2))
000036  4298              CMP      r0,r3
000038  d001              BEQ      |L18.62|
00003a  42a0              CMP      r0,r4
00003c  d102              BNE      |L18.68|
                  |L18.62|
;;;336      {                        
;;;337        /* Write to ADC CCR */
;;;338        ADC1_2->CCR = tmpreg1;
00003e  f8c31308          STR      r1,[r3,#0x308]
;;;339      }
;;;340      else
;;;341      {
;;;342        /* Write to ADC CCR */
;;;343        ADC3_4->CCR = tmpreg1;
;;;344      }
;;;345    }
000042  bdf0              POP      {r4-r7,pc}
                  |L18.68|
000044  6029              STR      r1,[r5,#0]            ;343
000046  bdf0              POP      {r4-r7,pc}
;;;346    
                          ENDP

                  |L18.72|
                          DCD      0xfffc10e0
                  |L18.76|
                          DCD      0x50000100
                  |L18.80|
                          DCD      0x50000708

                          AREA ||i.ADC_CommonStructInit||, CODE, READONLY, ALIGN=1

                  ADC_CommonStructInit PROC
;;;352      */
;;;353    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
000000  2100              MOVS     r1,#0
;;;354    {
;;;355      /* Initialize the ADC_Mode member */
;;;356      ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
;;;357    
;;;358      /* initialize the ADC_Clock member */
;;;359      ADC_CommonInitStruct->ADC_Clock = ADC_Clock_AsynClkMode;
000002  6001              STR      r1,[r0,#0]
;;;360    
;;;361      /* Initialize the ADC_DMAAccessMode member */
;;;362      ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
000004  6041              STR      r1,[r0,#4]
;;;363    
;;;364      /* Initialize the ADC_DMAMode member */
;;;365      ADC_CommonInitStruct->ADC_DMAMode = ADC_DMAMode_OneShot;
000006  6081              STR      r1,[r0,#8]
;;;366    
;;;367      /* Initialize the ADC_TwoSamplingDelay member */
;;;368      ADC_CommonInitStruct->ADC_TwoSamplingDelay = 0;
000008  60c1              STR      r1,[r0,#0xc]
00000a  7401              STRB     r1,[r0,#0x10]
;;;369    
;;;370    }
00000c  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;1774     */
;;;1775   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1776   {
;;;1777     /* Check the parameters */
;;;1778     assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;1779     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1780     if (NewState != DISABLE)
;;;1781     {
;;;1782       /* Enable the selected ADC DMA request */
;;;1783       ADCx->CFGR |= ADC_CFGR_DMAEN;
;;;1784     }
;;;1785     else
;;;1786     {
;;;1787       /* Disable the selected ADC DMA request */
;;;1788       ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMAEN;
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L20.12|
000006  f0410101          ORR      r1,r1,#1              ;1783
00000a  e001              B        |L20.16|
                  |L20.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L20.16|
000010  60c1              STR      r1,[r0,#0xc]          ;1783
;;;1789     }
;;;1790   }
000012  4770              BX       lr
;;;1791   
                          ENDP


                          AREA ||i.ADC_DMAConfig||, CODE, READONLY, ALIGN=1

                  ADC_DMAConfig PROC
;;;1798     */
;;;1799   void ADC_DMAConfig(ADC_TypeDef* ADCx, uint32_t ADC_DMAMode)
000000  68c2              LDR      r2,[r0,#0xc]
;;;1800   {
;;;1801     /* Check the parameters */
;;;1802     assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;1803     assert_param(IS_ADC_DMA_MODE(ADC_DMAMode));
;;;1804   
;;;1805     /* Set or reset the DMACFG bit */
;;;1806      ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMACFG;
000002  f0220202          BIC      r2,r2,#2
000006  60c2              STR      r2,[r0,#0xc]
;;;1807      ADCx->CFGR |= ADC_DMAMode;
000008  68c2              LDR      r2,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;1808   }
00000e  4770              BX       lr
;;;1809   
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;138      */
;;;139    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141      /* Check the parameters */
;;;142      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;143    
;;;144    
;;;145      if((ADCx == ADC1) || (ADCx == ADC2))
000002  f1b04fa0          CMP      r0,#0x50000000
000006  d002              BEQ      |L22.14|
000008  490b              LDR      r1,|L22.56|
00000a  4288              CMP      r0,r1
00000c  d102              BNE      |L22.20|
                  |L22.14|
;;;146      {
;;;147        /* Enable ADC1/ADC2 reset state */
;;;148        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, ENABLE);
00000e  2101              MOVS     r1,#1
000010  070c              LSLS     r4,r1,#28
;;;149        /* Release ADC1/ADC2 from reset state */
;;;150        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, DISABLE);
000012  e007              B        |L22.36|
                  |L22.20|
;;;151      }
;;;152      else if((ADCx == ADC3) || (ADCx == ADC4))
000014  4909              LDR      r1,|L22.60|
000016  4288              CMP      r0,r1
000018  d002              BEQ      |L22.32|
00001a  4909              LDR      r1,|L22.64|
00001c  4288              CMP      r0,r1
00001e  d10a              BNE      |L22.54|
                  |L22.32|
;;;153      {
;;;154        /* Enable ADC3/ADC4 reset state */
;;;155        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
000020  2101              MOVS     r1,#1
000022  074c              LSLS     r4,r1,#29
                  |L22.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;156        /* Release ADC3/ADC4 from reset state */
;;;157        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2100              MOVS     r1,#0
000032  f7ffbffe          B.W      RCC_AHBPeriphResetCmd
                  |L22.54|
;;;158      }
;;;159    }
000036  bd10              POP      {r4,pc}
;;;160    /**
                          ENDP

                  |L22.56|
                          DCD      0x50000100
                  |L22.60|
                          DCD      0x50000400
                  |L22.64|
                          DCD      0x50000500

                          AREA ||i.ADC_DisableCmd||, CODE, READONLY, ALIGN=1

                  ADC_DisableCmd PROC
;;;488      */
;;;489    void ADC_DisableCmd(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;490    {
;;;491      /* Check the parameters */
;;;492      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;493    
;;;494      /* Set the ADDIS bit */
;;;495      ADCx->CR |= ADC_CR_ADDIS;
000002  f0410102          ORR      r1,r1,#2
000006  6081              STR      r1,[r0,#8]
;;;496    }
000008  4770              BX       lr
;;;497    
                          ENDP


                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;1382     */
;;;1383   void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  68c2              LDR      r2,[r0,#0xc]
;;;1384   {
;;;1385     uint32_t tmpreg1 = 0;
;;;1386     uint32_t tmpreg2 = 0;
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1389     assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;1390     /* Get the old register value */
;;;1391     tmpreg1 = ADCx->CFGR;
;;;1392     /* Clear the old discontinuous mode channel count */
;;;1393     tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
000002  1e49              SUBS     r1,r1,#1
000004  f4222260          BIC      r2,r2,#0xe0000
;;;1394     /* Set the discontinuous mode channel count */
;;;1395     tmpreg2 = Number - 1;
;;;1396     tmpreg1 |= tmpreg2 << 17;
000008  ea424141          ORR      r1,r2,r1,LSL #17
;;;1397     /* Store the new register value */
;;;1398     ADCx->CFGR = tmpreg1;
00000c  60c1              STR      r1,[r0,#0xc]
;;;1399   }
00000e  4770              BX       lr
;;;1400   
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;1409     */
;;;1410   void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1411   {
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1414     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1415     if (NewState != DISABLE)
;;;1416     {
;;;1417       /* Enable the selected ADC regular discontinuous mode */
;;;1418       ADCx->CFGR |= ADC_CFGR_DISCEN;
;;;1419     }
;;;1420     else
;;;1421     {
;;;1422       /* Disable the selected ADC regular discontinuous mode */
;;;1423       ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_DISCEN);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L25.12|
000006  f4413180          ORR      r1,r1,#0x10000        ;1418
00000a  e001              B        |L25.16|
                  |L25.12|
00000c  f4213180          BIC      r1,r1,#0x10000
                  |L25.16|
000010  60c1              STR      r1,[r0,#0xc]          ;1418
;;;1424     }
;;;1425   }
000012  4770              BX       lr
;;;1426   
                          ENDP


                          AREA ||i.ADC_ExternalTriggerConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTriggerConfig PROC
;;;1308     */
;;;1309   void ADC_ExternalTriggerConfig(ADC_TypeDef* ADCx, uint16_t ADC_ExternalTrigConvEvent, uint16_t ADC_ExternalTrigEventEdge)
000000  68c3              LDR      r3,[r0,#0xc]
;;;1310   {
;;;1311     /* Check the parameters */
;;;1312     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1313     assert_param(IS_ADC_EXT_TRIG(ADC_ExternalTrigConvEvent));
;;;1314     assert_param(IS_EXTERNALTRIG_EDGE(ADC_ExternalTrigEventEdge));
;;;1315   
;;;1316     /* Disable the selected ADC conversion on external event */
;;;1317     ADCx->CFGR &= ~(ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL);
000002  f423637c          BIC      r3,r3,#0xfc0
000006  60c3              STR      r3,[r0,#0xc]
;;;1318     ADCx->CFGR |= (uint32_t)(ADC_ExternalTrigEventEdge | ADC_ExternalTrigConvEvent);
000008  68c3              LDR      r3,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  4313              ORRS     r3,r3,r2
00000e  60c3              STR      r3,[r0,#0xc]
;;;1319   }
000010  4770              BX       lr
;;;1320   
                          ENDP


                          AREA ||i.ADC_GetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationStatus PROC
;;;463      */
;;;464    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;465    {
;;;466      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;467      /* Check the parameters */
;;;468      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;469      /* Check the status of CAL bit */
;;;470      if ((ADCx->CR & ADC_CR_ADCAL) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  2900              CMP      r1,#0
000008  da00              BGE      |L27.12|
;;;471      {
;;;472        /* CAL bit is set: calibration on going */
;;;473        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L27.12|
;;;474      }
;;;475      else
;;;476      {
;;;477        /* CAL bit is reset: end of calibration */
;;;478        bitstatus = RESET;
;;;479      }
;;;480      /* Return the CAL bit status */
;;;481      return  bitstatus;
;;;482    }
00000c  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.ADC_GetCalibrationValue||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationValue PROC
;;;415      */
;;;416    uint32_t ADC_GetCalibrationValue(ADC_TypeDef* ADCx)
000000  f8d000b4          LDR      r0,[r0,#0xb4]
;;;417    {
;;;418      /* Check the parameters */
;;;419      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;420    
;;;421      /* Return the selected ADC calibration value */
;;;422      return (uint32_t)ADCx->CALFACT;
;;;423    }
000004  4770              BX       lr
;;;424    
                          ENDP


                          AREA ||i.ADC_GetCommonFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetCommonFlagStatus PROC
;;;2270     */
;;;2271   FlagStatus ADC_GetCommonFlagStatus(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;2272   {
000002  b510              PUSH     {r4,lr}
;;;2273     uint32_t tmpreg1 = 0;
;;;2274     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2275   
;;;2276     /* Check the parameters */
;;;2277     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2278     assert_param(IS_ADC_GET_COMMONFLAG(ADC_FLAG));
;;;2279   
;;;2280     if((ADCx == ADC1) || (ADCx == ADC2))
000006  f04f43a0          MOV      r3,#0x50000000
00000a  429a              CMP      r2,r3
00000c  d002              BEQ      |L29.20|
00000e  4c06              LDR      r4,|L29.40|
000010  42a2              CMP      r2,r4
000012  d102              BNE      |L29.26|
                  |L29.20|
;;;2281     {
;;;2282       tmpreg1 = ADC1_2->CSR;
000014  f8d32300          LDR      r2,[r3,#0x300]
000018  e001              B        |L29.30|
                  |L29.26|
;;;2283     }
;;;2284     else
;;;2285     {
;;;2286       tmpreg1 = ADC3_4->CSR;
00001a  4a04              LDR      r2,|L29.44|
00001c  6812              LDR      r2,[r2,#0]
                  |L29.30|
;;;2287     }  
;;;2288     /* Check the status of the specified ADC flag */
;;;2289     if ((tmpreg1 & ADC_FLAG) != (uint32_t)RESET)
00001e  420a              TST      r2,r1
000020  d000              BEQ      |L29.36|
;;;2290     {
;;;2291       /* ADC_FLAG is set */
;;;2292       bitstatus = SET;
000022  2001              MOVS     r0,#1
                  |L29.36|
;;;2293     }
;;;2294     else
;;;2295     {
;;;2296       /* ADC_FLAG is reset */
;;;2297       bitstatus = RESET;
;;;2298     }
;;;2299     /* Return the ADC_FLAG status */
;;;2300     return  bitstatus;
;;;2301   }
000024  bd10              POP      {r4,pc}
;;;2302   
                          ENDP

000026  0000              DCW      0x0000
                  |L29.40|
                          DCD      0x50000100
                  |L29.44|
                          DCD      0x50000700

                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;1431     */
;;;1432   uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  6c00              LDR      r0,[r0,#0x40]
;;;1433   {
;;;1434     /* Check the parameters */
;;;1435     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1436     /* Return the selected ADC conversion value */
;;;1437     return (uint16_t) ADCx->DR;
000002  b280              UXTH     r0,r0
;;;1438   }
000004  4770              BX       lr
;;;1439   
                          ENDP


                          AREA ||i.ADC_GetDisableCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetDisableCmdStatus PROC
;;;503      */
;;;504    FlagStatus ADC_GetDisableCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;505    {
;;;506      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;507      /* Check the parameters */
;;;508      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;509    
;;;510      /* Check the status of ADDIS bit */
;;;511      if ((ADCx->CR & ADC_CR_ADDIS) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0789              LSLS     r1,r1,#30
000008  d500              BPL      |L31.12|
;;;512      {
;;;513        /* ADDIS bit is set */
;;;514        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L31.12|
;;;515      }
;;;516      else
;;;517      {
;;;518        /* ADDIS bit is reset */
;;;519        bitstatus = RESET;
;;;520      }
;;;521      /* Return the ADDIS bit status */
;;;522      return  bitstatus;
;;;523    }
00000c  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.ADC_GetDualModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetDualModeConversionValue PROC
;;;1448     */
;;;1449   uint32_t ADC_GetDualModeConversionValue(ADC_TypeDef* ADCx)
000000  f04f41a0          MOV      r1,#0x50000000
;;;1450   {
;;;1451     uint32_t tmpreg1 = 0;
;;;1452   
;;;1453     /* Check the parameters */
;;;1454     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1455   
;;;1456     if((ADCx == ADC1) || (ADCx== ADC2))
000004  4288              CMP      r0,r1
000006  d002              BEQ      |L32.14|
000008  4a04              LDR      r2,|L32.28|
00000a  4290              CMP      r0,r2
00000c  d102              BNE      |L32.20|
                  |L32.14|
;;;1457     {
;;;1458       /* Get the dual mode conversion value */
;;;1459       tmpreg1 = ADC1_2->CDR;
00000e  f8d1030c          LDR      r0,[r1,#0x30c]
;;;1460     }
;;;1461     else
;;;1462     {	
;;;1463       /* Get the dual mode conversion value */
;;;1464       tmpreg1 = ADC3_4->CDR;
;;;1465     }
;;;1466     /* Return the dual mode conversion value */
;;;1467     return (uint32_t) tmpreg1;
;;;1468   }
000012  4770              BX       lr
                  |L32.20|
000014  4802              LDR      r0,|L32.32|
000016  6800              LDR      r0,[r0,#0]            ;1464
000018  4770              BX       lr
;;;1469   
                          ENDP

00001a  0000              DCW      0x0000
                  |L32.28|
                          DCD      0x50000100
                  |L32.32|
                          DCD      0x5000070c

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;2192     */
;;;2193   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;2194   {
;;;2195     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2196     /* Check the parameters */
;;;2197     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2198     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;2199   
;;;2200     /* Check the status of the specified ADC flag */
;;;2201     if ((ADCx->ISR & ADC_FLAG) != (uint32_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L33.12|
;;;2202     {
;;;2203       /* ADC_FLAG is set */
;;;2204       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L33.12|
;;;2205     }
;;;2206     else
;;;2207     {
;;;2208       /* ADC_FLAG is reset */
;;;2209       bitstatus = RESET;
;;;2210     }
;;;2211     /* Return the ADC_FLAG status */
;;;2212     return  bitstatus;
;;;2213   }
00000c  4770              BX       lr
;;;2214   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;2367     */
;;;2368   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint32_t ADC_IT)
000000  b510              PUSH     {r4,lr}
;;;2369   {
000002  4603              MOV      r3,r0
;;;2370     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2371     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2372     /* Check the parameters */
;;;2373     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2374     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;2375      
;;;2376     itstatus = ADCx->ISR & ADC_IT;
000006  681a              LDR      r2,[r3,#0]
000008  b28c              UXTH     r4,r1
;;;2377     
;;;2378     itenable = ADCx->IER & ADC_IT;
00000a  6859              LDR      r1,[r3,#4]
00000c  4222              TST      r2,r4                 ;2376
00000e  ea010104          AND      r1,r1,r4
000012  d002              BEQ      |L34.26|
;;;2379     if ((itstatus != (uint32_t)RESET) && (itenable != (uint32_t)RESET))
000014  2900              CMP      r1,#0
000016  d000              BEQ      |L34.26|
;;;2380     {
;;;2381       bitstatus = SET;
000018  2001              MOVS     r0,#1
                  |L34.26|
;;;2382     }
;;;2383     else
;;;2384     {
;;;2385       bitstatus = RESET;
;;;2386     }
;;;2387     return bitstatus;
;;;2388   }
00001a  bd10              POP      {r4,pc}
;;;2389   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;2022     */
;;;2023   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedSequence)
000000  b508              PUSH     {r3,lr}
;;;2024   {
;;;2025     __IO uint32_t tmp = 0;
;;;2026     
;;;2027     /* Check the parameters */
;;;2028     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2029     assert_param(IS_ADC_INJECTED_SEQUENCE(ADC_InjectedSequence));
;;;2030   
;;;2031     tmp = (uint32_t)ADCx;
;;;2032     tmp += ((ADC_InjectedSequence - 1 )<< 2) + JDR_Offset;
000002  eb000081          ADD      r0,r0,r1,LSL #2
000006  307c              ADDS     r0,r0,#0x7c
;;;2033     
;;;2034     /* Returns the selected injected channel conversion data value */
;;;2035     return (uint16_t) (*(__IO uint32_t*)  tmp);   
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  b280              UXTH     r0,r0
;;;2036   }
00000e  bd08              POP      {r3,pc}
;;;2037   
                          ENDP


                          AREA ||i.ADC_GetStartConversionStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetStartConversionStatus PROC
;;;1339     */
;;;1340   FlagStatus ADC_GetStartConversionStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;1341   {
;;;1342     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1343     /* Check the parameters */
;;;1344     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1345     /* Check the status of ADSTART bit */
;;;1346     if ((ADCx->CR & ADC_CR_ADSTART) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0749              LSLS     r1,r1,#29
000008  d500              BPL      |L36.12|
;;;1347     {
;;;1348       /* ADSTART bit is set */
;;;1349       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L36.12|
;;;1350     }
;;;1351     else
;;;1352     {
;;;1353       /* ADSTART bit is reset */
;;;1354       bitstatus = RESET;
;;;1355     }
;;;1356     /* Return the ADSTART bit status */
;;;1357     return  bitstatus;
;;;1358   }
00000c  4770              BX       lr
;;;1359   
                          ENDP


                          AREA ||i.ADC_GetStartInjectedConversionStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetStartInjectedConversionStatus PROC
;;;1939     */
;;;1940   FlagStatus ADC_GetStartInjectedConversionStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;1941   {
;;;1942     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1943     /* Check the parameters */
;;;1944     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1945   
;;;1946     /* Check the status of JADSTART bit */
;;;1947     if ((ADCx->CR & ADC_CR_JADSTART) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0709              LSLS     r1,r1,#28
000008  d500              BPL      |L37.12|
;;;1948     {
;;;1949       /* JADSTART bit is set */
;;;1950       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L37.12|
;;;1951     }
;;;1952     else
;;;1953     {
;;;1954       /* JADSTART bit is reset */
;;;1955       bitstatus = RESET;
;;;1956     }
;;;1957     /* Return the JADSTART bit status */
;;;1958     return  bitstatus;
;;;1959   }
00000c  4770              BX       lr
;;;1960   
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;2155     */
;;;2156   void ADC_ITConfig(ADC_TypeDef* ADCx, uint32_t ADC_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2157   {
;;;2158     /* Check the parameters */
;;;2159     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;2160     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2161     assert_param(IS_ADC_IT(ADC_IT));
;;;2162   
;;;2163     if (NewState != DISABLE)
;;;2164     {
;;;2165       /* Enable the selected ADC interrupts */
;;;2166       ADCx->IER |= ADC_IT;
;;;2167     }
;;;2168     else
;;;2169     {
;;;2170       /* Disable the selected ADC interrupts */
;;;2171       ADCx->IER &= (~(uint32_t)ADC_IT);
000002  6842              LDR      r2,[r0,#4]
000004  d001              BEQ      |L38.10|
000006  430a              ORRS     r2,r2,r1              ;2166
000008  e000              B        |L38.12|
                  |L38.10|
00000a  438a              BICS     r2,r2,r1
                  |L38.12|
00000c  6042              STR      r2,[r0,#4]            ;2166
;;;2172     }
;;;2173   }
00000e  4770              BX       lr
;;;2174   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;167      */
;;;168    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;169    {
;;;170      uint32_t tmpreg1 = 0;
;;;171      /* Check the parameters */
;;;172      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;173      assert_param(IS_ADC_CONVMODE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;174      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution));
;;;175      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConvEvent)); 
;;;176      assert_param(IS_EXTERNALTRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigEventEdge));  
;;;177      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;178      assert_param(IS_ADC_OVRUNMODE(ADC_InitStruct->ADC_OverrunMode));
;;;179      assert_param(IS_ADC_AUTOINJECMODE(ADC_InitStruct->ADC_AutoInjMode));
;;;180      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfRegChannel));
;;;181    
;;;182      /*---------------------------- ADCx CFGR Configuration -----------------*/
;;;183      /* Get the ADCx CFGR value */
;;;184      tmpreg1 = ADCx->CFGR;
000002  68c3              LDR      r3,[r0,#0xc]
;;;185      /* Clear SCAN bit */
;;;186      tmpreg1 &= CFGR_CLEAR_Mask; 
000004  4a0c              LDR      r2,|L39.56|
000006  4013              ANDS     r3,r3,r2
000008  e9d12400          LDRD     r2,r4,[r1,#0]
;;;187      /* Configure ADCx: scan conversion mode */
;;;188      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;189      tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
00000c  4322              ORRS     r2,r2,r4
00000e  e9d14502          LDRD     r4,r5,[r1,#8]
000012  432c              ORRS     r4,r4,r5
000014  4322              ORRS     r2,r2,r4
000016  690c              LDR      r4,[r1,#0x10]
000018  4322              ORRS     r2,r2,r4
00001a  694c              LDR      r4,[r1,#0x14]
00001c  4322              ORRS     r2,r2,r4
00001e  698c              LDR      r4,[r1,#0x18]
000020  4322              ORRS     r2,r2,r4
000022  431a              ORRS     r2,r2,r3
;;;190      ADC_InitStruct->ADC_Resolution|                 
;;;191      ADC_InitStruct->ADC_ExternalTrigConvEvent|         
;;;192      ADC_InitStruct->ADC_ExternalTrigEventEdge|     
;;;193      ADC_InitStruct->ADC_DataAlign|                 
;;;194      ADC_InitStruct->ADC_OverrunMode|        
;;;195      ADC_InitStruct->ADC_AutoInjMode;
;;;196      
;;;197      /* Write to ADCx CFGR */
;;;198      ADCx->CFGR = tmpreg1;
000024  60c2              STR      r2,[r0,#0xc]
;;;199      
;;;200      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;201      /* Get the ADCx SQR1 value */
;;;202      tmpreg1 = ADCx->SQR1;
000026  6b02              LDR      r2,[r0,#0x30]
;;;203      /* Clear L bits */
;;;204      tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
;;;205      /* Configure ADCx: regular channel sequence length */
;;;206      /* Set L bits according to ADC_NbrOfRegChannel value */
;;;207      tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
000028  7f09              LDRB     r1,[r1,#0x1c]
00002a  f022020f          BIC      r2,r2,#0xf            ;204
00002e  1e49              SUBS     r1,r1,#1
000030  4311              ORRS     r1,r1,r2
;;;208      /* Write to ADCx SQR1 */
;;;209      ADCx->SQR1 = tmpreg1; 
000032  6301              STR      r1,[r0,#0x30]
;;;210       
;;;211    }  
000034  bd30              POP      {r4,r5,pc}
;;;212    
                          ENDP

000036  0000              DCW      0x0000
                  |L39.56|
                          DCD      0xfdffc007

                          AREA ||i.ADC_InjectedChannelSampleTimeConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelSampleTimeConfig PROC
;;;1871     */
;;;1872   void ADC_InjectedChannelSampleTimeConfig(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint8_t ADC_SampleTime)
000000  b510              PUSH     {r4,lr}
;;;1873   {
;;;1874     uint32_t tmpreg1 = 0;
;;;1875     /* Check the parameters */
;;;1876     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1877     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1878     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1879   
;;;1880     /* Channel sampling configuration */
;;;1881     /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
;;;1882     if (ADC_InjectedChannel > ADC_InjectedChannel_9)
000002  2909              CMP      r1,#9
000004  d90c              BLS      |L40.32|
000006  390a              SUBS     r1,r1,#0xa            ;1873
;;;1883     {
;;;1884       /* Calculate the mask to clear */
;;;1885       tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
000008  eb010341          ADD      r3,r1,r1,LSL #1
00000c  2107              MOVS     r1,#7
;;;1886       /* Clear the old channel sample time */
;;;1887   	ADCx->SMPR2 &= ~tmpreg1;
00000e  6984              LDR      r4,[r0,#0x18]
000010  4099              LSLS     r1,r1,r3              ;1885
000012  438c              BICS     r4,r4,r1
000014  6184              STR      r4,[r0,#0x18]
;;;1888       /* Calculate the mask to set */
;;;1889   	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel - 10));
000016  6981              LDR      r1,[r0,#0x18]
000018  409a              LSLS     r2,r2,r3
00001a  4311              ORRS     r1,r1,r2
00001c  6181              STR      r1,[r0,#0x18]
;;;1890   
;;;1891     }
;;;1892     else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
;;;1893     {
;;;1894       /* Calculate the mask to clear */
;;;1895       tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
;;;1896       /* Clear the old channel sample time */
;;;1897   	ADCx->SMPR1 &= ~tmpreg1;
;;;1898       /* Calculate the mask to set */
;;;1899   	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel));
;;;1900     }  
;;;1901   }
00001e  bd10              POP      {r4,pc}
                  |L40.32|
000020  1e4b              SUBS     r3,r1,#1              ;1895
000022  eb030443          ADD      r4,r3,r3,LSL #1       ;1895
000026  2338              MOVS     r3,#0x38              ;1895
000028  40a3              LSLS     r3,r3,r4              ;1895
00002a  6944              LDR      r4,[r0,#0x14]         ;1897
00002c  439c              BICS     r4,r4,r3              ;1897
00002e  6144              STR      r4,[r0,#0x14]         ;1897
000030  6943              LDR      r3,[r0,#0x14]         ;1899
000032  eb010141          ADD      r1,r1,r1,LSL #1       ;1899
000036  408a              LSLS     r2,r2,r1              ;1899
000038  4313              ORRS     r3,r3,r2              ;1899
00003a  6143              STR      r3,[r0,#0x14]         ;1899
00003c  bd10              POP      {r4,pc}
;;;1902   
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;1994     */
;;;1995   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1996   {
;;;1997     /* Check the parameters */
;;;1998     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1999     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2000     if (NewState != DISABLE)
;;;2001     {
;;;2002       /* Enable the selected ADC injected discontinuous mode */
;;;2003       ADCx->CFGR |= ADC_CFGR_JDISCEN;
;;;2004     }
;;;2005     else
;;;2006     {
;;;2007       /* Disable the selected ADC injected discontinuous mode */
;;;2008       ADCx->CFGR &= ~ADC_CFGR_JDISCEN;
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L41.12|
000006  f4411180          ORR      r1,r1,#0x100000       ;2003
00000a  e001              B        |L41.16|
                  |L41.12|
00000c  f4211180          BIC      r1,r1,#0x100000
                  |L41.16|
000010  60c1              STR      r1,[r0,#0xc]          ;2003
;;;2009     }
;;;2010   }
000012  4770              BX       lr
;;;2011   
                          ENDP


                          AREA ||i.ADC_InjectedInit||, CODE, READONLY, ALIGN=1

                  ADC_InjectedInit PROC
;;;238      */
;;;239    void ADC_InjectedInit(ADC_TypeDef* ADCx, ADC_InjectedInitTypeDef* ADC_InjectedInitStruct)
000000  b510              PUSH     {r4,lr}
;;;240    {
;;;241      uint32_t tmpreg1 = 0;
;;;242      /* Check the parameters */
;;;243      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;244      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent)); 
;;;245      assert_param(IS_EXTERNALTRIGINJ_EDGE(ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge));   
;;;246      assert_param(IS_ADC_INJECTED_LENGTH(ADC_InjectedInitStruct->ADC_NbrOfInjecChannel));
;;;247      assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence1));
;;;248      assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence2));
;;;249      assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence3));
;;;250      assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence4));
;;;251      
;;;252      /*---------------------------- ADCx JSQR Configuration -----------------*/
;;;253      /* Get the ADCx JSQR value */
;;;254      tmpreg1 = ADCx->JSQR;
000002  6cc2              LDR      r2,[r0,#0x4c]
000004  e9d12300          LDRD     r2,r3,[r1,#0]
;;;255      /* Clear L bits */
;;;256      tmpreg1 &= JSQR_CLEAR_Mask;
;;;257      /* Configure ADCx: Injected channel sequence length, external trigger, 
;;;258         external trigger edge and sequences
;;;259      */
;;;260      tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
000008  431a              ORRS     r2,r2,r3
00000a  7a0b              LDRB     r3,[r1,#8]
00000c  68cc              LDR      r4,[r1,#0xc]
00000e  1e5b              SUBS     r3,r3,#1
000010  ea432304          ORR      r3,r3,r4,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  690b              LDR      r3,[r1,#0x10]
000018  ea423283          ORR      r2,r2,r3,LSL #14
00001c  8a8b              LDRH     r3,[r1,#0x14]
00001e  7e09              LDRB     r1,[r1,#0x18]
000020  ea425203          ORR      r2,r2,r3,LSL #20
000024  ea426181          ORR      r1,r2,r1,LSL #26
;;;261                             ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
;;;262                             ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
;;;263                             (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
;;;264                             (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
;;;265                             (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
;;;266                             (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
;;;267      /* Write to ADCx SQR1 */
;;;268      ADCx->JSQR = tmpreg1;  
000028  64c1              STR      r1,[r0,#0x4c]
;;;269    }
00002a  bd10              POP      {r4,pc}
;;;270    
                          ENDP


                          AREA ||i.ADC_InjectedStructInit||, CODE, READONLY, ALIGN=1

                  ADC_InjectedStructInit PROC
;;;275      */
;;;276    void ADC_InjectedStructInit(ADC_InjectedInitTypeDef* ADC_InjectedInitStruct)
000000  2100              MOVS     r1,#0
;;;277    {
;;;278      ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;    
;;;279      ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;     
000002  6001              STR      r1,[r0,#0]
;;;280      ADC_InjectedInitStruct->ADC_NbrOfInjecChannel = 1;                                                             
000004  6041              STR      r1,[r0,#4]
000006  2101              MOVS     r1,#1
000008  7201              STRB     r1,[r0,#8]
;;;281      ADC_InjectedInitStruct->ADC_InjecSequence1 = ADC_InjectedChannel_1; 
;;;282      ADC_InjectedInitStruct->ADC_InjecSequence2 = ADC_InjectedChannel_1;
00000a  60c1              STR      r1,[r0,#0xc]
;;;283      ADC_InjectedInitStruct->ADC_InjecSequence3 = ADC_InjectedChannel_1;
00000c  6101              STR      r1,[r0,#0x10]
;;;284      ADC_InjectedInitStruct->ADC_InjecSequence4 = ADC_InjectedChannel_1; 
00000e  6141              STR      r1,[r0,#0x14]
000010  6181              STR      r1,[r0,#0x18]
;;;285    }
000012  4770              BX       lr
;;;286        
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;1161     */
;;;1162   void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;1163   {
;;;1164     uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;1165     /* Check the parameters */
;;;1166     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1167     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1168     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1169   
;;;1170     /* Regular sequence configuration */
;;;1171     /* For Rank 1 to 4 */
;;;1172     if (Rank < 5)
;;;1173     {
;;;1174       /* Get the old register value */
;;;1175       tmpreg1 = ADCx->SQR1;
;;;1176       /* Calculate the mask to clear */
;;;1177       tmpreg2 = 0x1F << (6 * (Rank ));
000002  241f              MOVS     r4,#0x1f
000004  2a05              CMP      r2,#5                 ;1172
000006  d20a              BCS      |L44.30|
000008  6b05              LDR      r5,[r0,#0x30]         ;1175
00000a  eb020242          ADD      r2,r2,r2,LSL #1
00000e  0056              LSLS     r6,r2,#1
000010  40b4              LSLS     r4,r4,r6
;;;1178       /* Clear the old SQx bits for the selected rank */
;;;1179       tmpreg1 &= ~tmpreg2;
000012  43a5              BICS     r5,r5,r4
;;;1180       /* Calculate the mask to set */
;;;1181       tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank));
000014  fa01f206          LSL      r2,r1,r6
;;;1182       /* Set the SQx bits for the selected rank */
;;;1183       tmpreg1 |= tmpreg2;
000018  4315              ORRS     r5,r5,r2
;;;1184       /* Store the new register value */
;;;1185       ADCx->SQR1 = tmpreg1;
00001a  6305              STR      r5,[r0,#0x30]
00001c  e026              B        |L44.108|
                  |L44.30|
;;;1186     }
;;;1187     /* For Rank 5 to 9 */
;;;1188     else if (Rank < 10)
00001e  2a0a              CMP      r2,#0xa
000020  d20b              BCS      |L44.58|
;;;1189     {
;;;1190       /* Get the old register value */
;;;1191       tmpreg1 = ADCx->SQR2;
000022  6b45              LDR      r5,[r0,#0x34]
000024  1f52              SUBS     r2,r2,#5
;;;1192       /* Calculate the mask to clear */
;;;1193       tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
000026  eb020242          ADD      r2,r2,r2,LSL #1
00002a  0056              LSLS     r6,r2,#1
00002c  40b4              LSLS     r4,r4,r6
;;;1194       /* Clear the old SQx bits for the selected rank */
;;;1195       tmpreg1 &= ~tmpreg2;
00002e  43a5              BICS     r5,r5,r4
;;;1196       /* Calculate the mask to set */
;;;1197       tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 5));
000030  fa01f206          LSL      r2,r1,r6
;;;1198       /* Set the SQx bits for the selected rank */
;;;1199       tmpreg1 |= tmpreg2;
000034  4315              ORRS     r5,r5,r2
;;;1200       /* Store the new register value */
;;;1201       ADCx->SQR2 = tmpreg1;
000036  6345              STR      r5,[r0,#0x34]
000038  e018              B        |L44.108|
                  |L44.58|
;;;1202     }
;;;1203     /* For Rank 10 to 14 */
;;;1204     else if (Rank < 15)
00003a  2a0f              CMP      r2,#0xf
00003c  d20b              BCS      |L44.86|
;;;1205     {
;;;1206       /* Get the old register value */
;;;1207       tmpreg1 = ADCx->SQR3;
00003e  6b85              LDR      r5,[r0,#0x38]
000040  3a0a              SUBS     r2,r2,#0xa
;;;1208       /* Calculate the mask to clear */
;;;1209       tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
000042  eb020242          ADD      r2,r2,r2,LSL #1
000046  0056              LSLS     r6,r2,#1
000048  40b4              LSLS     r4,r4,r6
;;;1210       /* Clear the old SQx bits for the selected rank */
;;;1211       tmpreg1 &= ~tmpreg2;
00004a  43a5              BICS     r5,r5,r4
;;;1212       /* Calculate the mask to set */
;;;1213       tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 10));
00004c  fa01f206          LSL      r2,r1,r6
;;;1214       /* Set the SQx bits for the selected rank */
;;;1215       tmpreg1 |= tmpreg2;
000050  4315              ORRS     r5,r5,r2
;;;1216       /* Store the new register value */
;;;1217       ADCx->SQR3 = tmpreg1;
000052  6385              STR      r5,[r0,#0x38]
000054  e00a              B        |L44.108|
                  |L44.86|
;;;1218     }
;;;1219     else 
;;;1220     {
;;;1221       /* Get the old register value */
;;;1222       tmpreg1 = ADCx->SQR4;
000056  6bc5              LDR      r5,[r0,#0x3c]
000058  3a0f              SUBS     r2,r2,#0xf
;;;1223       /* Calculate the mask to clear */
;;;1224       tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
00005a  eb020242          ADD      r2,r2,r2,LSL #1
00005e  0056              LSLS     r6,r2,#1
000060  40b4              LSLS     r4,r4,r6
;;;1225       /* Clear the old SQx bits for the selected rank */
;;;1226       tmpreg1 &= ~tmpreg2;
000062  43a5              BICS     r5,r5,r4
;;;1227       /* Calculate the mask to set */
;;;1228       tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 15));
000064  fa01f206          LSL      r2,r1,r6
;;;1229       /* Set the SQx bits for the selected rank */
;;;1230       tmpreg1 |= tmpreg2;
000068  4315              ORRS     r5,r5,r2
;;;1231       /* Store the new register value */
;;;1232       ADCx->SQR4 = tmpreg1;
00006a  63c5              STR      r5,[r0,#0x3c]
                  |L44.108|
;;;1233     }
;;;1234   
;;;1235     /* Channel sampling configuration */
;;;1236     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1237     if (ADC_Channel > ADC_Channel_9)
00006c  2909              CMP      r1,#9
00006e  d90d              BLS      |L44.140|
;;;1238     {
;;;1239       /* Get the old register value */
;;;1240       tmpreg1 = ADCx->SMPR2;
000070  6982              LDR      r2,[r0,#0x18]
000072  390a              SUBS     r1,r1,#0xa
;;;1241       /* Calculate the mask to clear */
;;;1242       tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
000074  eb010241          ADD      r2,r1,r1,LSL #1
000078  2107              MOVS     r1,#7
;;;1243       /* Clear the old channel sample time */
;;;1244   	ADCx->SMPR2 &= ~tmpreg2;
00007a  6984              LDR      r4,[r0,#0x18]
00007c  4091              LSLS     r1,r1,r2              ;1242
00007e  438c              BICS     r4,r4,r1
000080  6184              STR      r4,[r0,#0x18]
;;;1245       /* Calculate the mask to set */
;;;1246   	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000082  6981              LDR      r1,[r0,#0x18]
000084  4093              LSLS     r3,r3,r2
000086  4319              ORRS     r1,r1,r3
000088  6181              STR      r1,[r0,#0x18]
;;;1247   
;;;1248     }
;;;1249     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1250     {
;;;1251       /* Get the old register value */
;;;1252       tmpreg1 = ADCx->SMPR1;
;;;1253       /* Calculate the mask to clear */
;;;1254       tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
;;;1255       /* Clear the old channel sample time */
;;;1256   	ADCx->SMPR1 &= ~tmpreg2;
;;;1257       /* Calculate the mask to set */
;;;1258   	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel));
;;;1259     }
;;;1260   }
00008a  bd70              POP      {r4-r6,pc}
                  |L44.140|
00008c  6942              LDR      r2,[r0,#0x14]         ;1252
00008e  1e4a              SUBS     r2,r1,#1              ;1254
000090  eb020442          ADD      r4,r2,r2,LSL #1       ;1254
000094  2238              MOVS     r2,#0x38              ;1254
000096  40a2              LSLS     r2,r2,r4              ;1254
000098  6944              LDR      r4,[r0,#0x14]         ;1256
00009a  4394              BICS     r4,r4,r2              ;1256
00009c  6144              STR      r4,[r0,#0x14]         ;1256
00009e  6942              LDR      r2,[r0,#0x14]         ;1258
0000a0  eb010141          ADD      r1,r1,r1,LSL #1       ;1258
0000a4  408b              LSLS     r3,r3,r1              ;1258
0000a6  431a              ORRS     r2,r2,r3              ;1258
0000a8  6142              STR      r2,[r0,#0x14]         ;1258
0000aa  bd70              POP      {r4-r6,pc}
;;;1261   
                          ENDP


                          AREA ||i.ADC_RegularChannelSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelSequencerLengthConfig PROC
;;;1268     */
;;;1269   void ADC_RegularChannelSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t SequencerLength)
000000  6b02              LDR      r2,[r0,#0x30]
;;;1270   {
;;;1271     /* Check the parameters */
;;;1272     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1273   
;;;1274     /* Configure the ADC sequence lenght */  
;;;1275     ADCx->SQR1 &= ~(uint32_t)ADC_SQR1_L;
000002  f022020f          BIC      r2,r2,#0xf
000006  6302              STR      r2,[r0,#0x30]
;;;1276     ADCx->SQR1 |= (uint32_t)(SequencerLength - 1);   
000008  6b02              LDR      r2,[r0,#0x30]
00000a  1e49              SUBS     r1,r1,#1
00000c  430a              ORRS     r2,r2,r1
00000e  6302              STR      r2,[r0,#0x30]
;;;1277   }
000010  4770              BX       lr
;;;1278   
                          ENDP


                          AREA ||i.ADC_SelectCalibrationMode||, CODE, READONLY, ALIGN=1

                  ADC_SelectCalibrationMode PROC
;;;447      */
;;;448    void ADC_SelectCalibrationMode(ADC_TypeDef* ADCx, uint32_t ADC_CalibrationMode)
000000  6882              LDR      r2,[r0,#8]
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;452      assert_param(IS_ADC_CALIBRATION_MODE(ADC_CalibrationMode));
;;;453      /* Set or Reset the ADCALDIF bit */
;;;454      ADCx->CR &= (~ADC_CR_ADCALDIF);
000002  f0224280          BIC      r2,r2,#0x40000000
000006  6082              STR      r2,[r0,#8]
;;;455      ADCx->CR |= ADC_CalibrationMode;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;456    
;;;457    }
00000e  4770              BX       lr
;;;458    
                          ENDP


                          AREA ||i.ADC_SelectDifferentialMode||, CODE, READONLY, ALIGN=1

                  ADC_SelectDifferentialMode PROC
;;;575      */
;;;576    void ADC_SelectDifferentialMode(ADC_TypeDef* ADCx, uint8_t ADC_Channel, FunctionalState NewState)
000000  2301              MOVS     r3,#1
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
;;;580      assert_param(IS_ADC_DIFFCHANNEL(ADC_Channel)); 
;;;581      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;582    
;;;583      if (NewState != DISABLE)
;;;584      {
;;;585        /* Set the DIFSEL bit */
;;;586       ADCx->DIFSEL |= (uint32_t)(1 << ADC_Channel );
000002  408b              LSLS     r3,r3,r1
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Reset the DIFSEL bit */
;;;591       ADCx->DIFSEL &= ~(uint32_t)(1 << ADC_Channel);
000004  f8501fb0          LDR      r1,[r0,#0xb0]!
000008  b10a              CBZ      r2,|L47.14|
00000a  4319              ORRS     r1,r1,r3              ;586
00000c  e000              B        |L47.16|
                  |L47.14|
00000e  4399              BICS     r1,r1,r3
                  |L47.16|
000010  6001              STR      r1,[r0,#0]            ;586
;;;592      }
;;;593    }
000012  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.ADC_SelectQueueOfContextMode||, CODE, READONLY, ALIGN=1

                  ADC_SelectQueueOfContextMode PROC
;;;601      */
;;;602    void ADC_SelectQueueOfContextMode(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607    
;;;608      if (NewState != DISABLE)
;;;609      {
;;;610        /* Set the JQM bit */
;;;611        ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
;;;612      }
;;;613      else
;;;614      {
;;;615        /* Reset the JQM bit */
;;;616        ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_JQM);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L48.12|
000006  f4411100          ORR      r1,r1,#0x200000       ;611
00000a  e001              B        |L48.16|
                  |L48.12|
00000c  f4211100          BIC      r1,r1,#0x200000
                  |L48.16|
000010  60c1              STR      r1,[r0,#0xc]          ;611
;;;617      }
;;;618    }
000012  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.ADC_SetCalibrationValue||, CODE, READONLY, ALIGN=1

                  ADC_SetCalibrationValue PROC
;;;429      */
;;;430    void ADC_SetCalibrationValue(ADC_TypeDef* ADCx, uint32_t ADC_Calibration)
000000  f8c010b4          STR      r1,[r0,#0xb4]
;;;431    {
;;;432      /* Check the parameters */
;;;433      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;434    
;;;435      /* Set the ADC calibration register value */
;;;436      ADCx->CALFACT = ADC_Calibration;
;;;437    }
000004  4770              BX       lr
;;;438    
                          ENDP


                          AREA ||i.ADC_SetChannelOffset1||, CODE, READONLY, ALIGN=1

                  ADC_SetChannelOffset1 PROC
;;;1496     */
;;;1497   void ADC_SetChannelOffset1(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint16_t Offset)
000000  6e03              LDR      r3,[r0,#0x60]
;;;1498   {
;;;1499     /* Check the parameters */
;;;1500     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1501     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1502     assert_param(IS_ADC_OFFSET(Offset));
;;;1503       
;;;1504     /* Select the Channel */
;;;1505     ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1_CH;
000002  f02343f8          BIC      r3,r3,#0x7c000000
000006  6603              STR      r3,[r0,#0x60]
;;;1506     ADCx->OFR1 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
000008  6e03              LDR      r3,[r0,#0x60]
00000a  ea436181          ORR      r1,r3,r1,LSL #26
00000e  6601              STR      r1,[r0,#0x60]
;;;1507   
;;;1508     /* Set the data offset */
;;;1509     ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1;
000010  6e01              LDR      r1,[r0,#0x60]
000012  f36f010b          BFC      r1,#0,#12
000016  6601              STR      r1,[r0,#0x60]
;;;1510     ADCx->OFR1 |= (uint32_t)Offset;
000018  6e01              LDR      r1,[r0,#0x60]
00001a  4311              ORRS     r1,r1,r2
00001c  6601              STR      r1,[r0,#0x60]
;;;1511   }
00001e  4770              BX       lr
;;;1512   
                          ENDP


                          AREA ||i.ADC_SetChannelOffset2||, CODE, READONLY, ALIGN=1

                  ADC_SetChannelOffset2 PROC
;;;1539     */
;;;1540   void ADC_SetChannelOffset2(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint16_t Offset)
000000  6e43              LDR      r3,[r0,#0x64]
;;;1541   {
;;;1542     /* Check the parameters */
;;;1543     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1544     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1545     assert_param(IS_ADC_OFFSET(Offset));
;;;1546       
;;;1547     /* Select the Channel */
;;;1548     ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2_CH;
000002  f02343f8          BIC      r3,r3,#0x7c000000
000006  6643              STR      r3,[r0,#0x64]
;;;1549     ADCx->OFR2 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
000008  6e43              LDR      r3,[r0,#0x64]
00000a  ea436181          ORR      r1,r3,r1,LSL #26
00000e  6641              STR      r1,[r0,#0x64]
;;;1550   
;;;1551     /* Set the data offset */
;;;1552     ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2;
000010  6e41              LDR      r1,[r0,#0x64]
000012  f36f010b          BFC      r1,#0,#12
000016  6641              STR      r1,[r0,#0x64]
;;;1553     ADCx->OFR2 |= (uint32_t)Offset;
000018  6e41              LDR      r1,[r0,#0x64]
00001a  4311              ORRS     r1,r1,r2
00001c  6641              STR      r1,[r0,#0x64]
;;;1554   }
00001e  4770              BX       lr
;;;1555   
                          ENDP


                          AREA ||i.ADC_SetChannelOffset3||, CODE, READONLY, ALIGN=1

                  ADC_SetChannelOffset3 PROC
;;;1582     */
;;;1583   void ADC_SetChannelOffset3(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint16_t Offset)
000000  6e83              LDR      r3,[r0,#0x68]
;;;1584   {
;;;1585     /* Check the parameters */
;;;1586     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1587     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1588     assert_param(IS_ADC_OFFSET(Offset));
;;;1589       
;;;1590     /* Select the Channel */
;;;1591     ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3_CH;
000002  f02343f8          BIC      r3,r3,#0x7c000000
000006  6683              STR      r3,[r0,#0x68]
;;;1592     ADCx->OFR3 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
000008  6e83              LDR      r3,[r0,#0x68]
00000a  ea436181          ORR      r1,r3,r1,LSL #26
00000e  6681              STR      r1,[r0,#0x68]
;;;1593   
;;;1594     /* Set the data offset */
;;;1595     ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3;
000010  6e81              LDR      r1,[r0,#0x68]
000012  f36f010b          BFC      r1,#0,#12
000016  6681              STR      r1,[r0,#0x68]
;;;1596     ADCx->OFR3 |= (uint32_t)Offset;
000018  6e81              LDR      r1,[r0,#0x68]
00001a  4311              ORRS     r1,r1,r2
00001c  6681              STR      r1,[r0,#0x68]
;;;1597   }
00001e  4770              BX       lr
;;;1598   
                          ENDP


                          AREA ||i.ADC_SetChannelOffset4||, CODE, READONLY, ALIGN=1

                  ADC_SetChannelOffset4 PROC
;;;1625     */
;;;1626   void ADC_SetChannelOffset4(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint16_t Offset)
000000  6ec3              LDR      r3,[r0,#0x6c]
;;;1627   {
;;;1628     /* Check the parameters */
;;;1629     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1630     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1631     assert_param(IS_ADC_OFFSET(Offset));
;;;1632       
;;;1633     /* Select the Channel */
;;;1634     ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4_CH;
000002  f02343f8          BIC      r3,r3,#0x7c000000
000006  66c3              STR      r3,[r0,#0x6c]
;;;1635     ADCx->OFR4 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
000008  6ec3              LDR      r3,[r0,#0x6c]
00000a  ea436181          ORR      r1,r3,r1,LSL #26
00000e  66c1              STR      r1,[r0,#0x6c]
;;;1636   
;;;1637     /* Set the data offset */
;;;1638     ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4;
000010  6ec1              LDR      r1,[r0,#0x6c]
000012  f36f010b          BFC      r1,#0,#12
000016  66c1              STR      r1,[r0,#0x6c]
;;;1639     ADCx->OFR4 |= (uint32_t)Offset;
000018  6ec1              LDR      r1,[r0,#0x6c]
00001a  4311              ORRS     r1,r1,r2
00001c  66c1              STR      r1,[r0,#0x6c]
;;;1640   }
00001e  4770              BX       lr
;;;1641   
                          ENDP


                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=1

                  ADC_StartCalibration PROC
;;;401      */
;;;402    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;403    {
;;;404      /* Check the parameters */
;;;405      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;406    
;;;407      /* Set the ADCAL bit */
;;;408      ADCx->CR |= ADC_CR_ADCAL;
000002  f0414100          ORR      r1,r1,#0x80000000
000006  6081              STR      r1,[r0,#8]
;;;409    }
000008  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.ADC_StartConversion||, CODE, READONLY, ALIGN=1

                  ADC_StartConversion PROC
;;;1325     */
;;;1326   void ADC_StartConversion(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1327   {
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1330   
;;;1331     /* Set the ADSTART bit */
;;;1332     ADCx->CR |= ADC_CR_ADSTART;
000002  f0410104          ORR      r1,r1,#4
000006  6081              STR      r1,[r0,#8]
;;;1333   }
000008  4770              BX       lr
;;;1334   
                          ENDP


                          AREA ||i.ADC_StartInjectedConversion||, CODE, READONLY, ALIGN=1

                  ADC_StartInjectedConversion PROC
;;;1910     */
;;;1911   void ADC_StartInjectedConversion(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1912   {
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1915   
;;;1916     /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;1917        ADC injected conversion */
;;;1918     ADCx->CR |= ADC_CR_JADSTART;
000002  f0410108          ORR      r1,r1,#8
000006  6081              STR      r1,[r0,#8]
;;;1919   }
000008  4770              BX       lr
;;;1920   
                          ENDP


                          AREA ||i.ADC_StopConversion||, CODE, READONLY, ALIGN=1

                  ADC_StopConversion PROC
;;;1364     */
;;;1365   void ADC_StopConversion(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1366   {
;;;1367     /* Check the parameters */
;;;1368     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1369   
;;;1370     /* Set the ADSTP bit */
;;;1371      ADCx->CR |= ADC_CR_ADSTP;
000002  f0410110          ORR      r1,r1,#0x10
000006  6081              STR      r1,[r0,#8]
;;;1372   }
000008  4770              BX       lr
;;;1373   
                          ENDP


                          AREA ||i.ADC_StopInjectedConversion||, CODE, READONLY, ALIGN=1

                  ADC_StopInjectedConversion PROC
;;;1925     */
;;;1926   void ADC_StopInjectedConversion(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1927   {
;;;1928     /* Check the parameters */
;;;1929     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1930   
;;;1931     /* Set the JADSTP bit */
;;;1932      ADCx->CR |= ADC_CR_JADSTP;
000002  f0410120          ORR      r1,r1,#0x20
000006  6081              STR      r1,[r0,#8]
;;;1933   }
000008  4770              BX       lr
;;;1934   
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;217      */
;;;218    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;219    {
;;;220      /* Reset ADC init structure parameters values */
;;;221      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
;;;222      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;                 
000002  6001              STR      r1,[r0,#0]
;;;223      ADC_InitStruct->ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;         
000004  6041              STR      r1,[r0,#4]
;;;224      ADC_InitStruct->ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
000006  6081              STR      r1,[r0,#8]
;;;225      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;                 
000008  60c1              STR      r1,[r0,#0xc]
;;;226      ADC_InitStruct->ADC_OverrunMode = DISABLE;   
00000a  6101              STR      r1,[r0,#0x10]
;;;227      ADC_InitStruct->ADC_AutoInjMode = DISABLE;  
00000c  6141              STR      r1,[r0,#0x14]
;;;228      ADC_InitStruct->ADC_NbrOfRegChannel = 1; 
00000e  6181              STR      r1,[r0,#0x18]
000010  2101              MOVS     r1,#1
000012  7701              STRB     r1,[r0,#0x1c]
;;;229    }
000014  4770              BX       lr
;;;230    
                          ENDP


                          AREA ||i.ADC_TempSensorCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorCmd PROC
;;;947      */
;;;948    void ADC_TempSensorCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  f04f42a0          MOV      r2,#0x50000000
;;;949    {
;;;950      /* Check the parameters */
;;;951      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;952      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;953    
;;;954      if((ADCx == ADC1) || (ADCx == ADC2))
000004  4290              CMP      r0,r2
000006  d002              BEQ      |L60.14|
000008  4b0c              LDR      r3,|L60.60|
00000a  4298              CMP      r0,r3
00000c  d10a              BNE      |L60.36|
                  |L60.14|
;;;955      {
;;;956        if (NewState != DISABLE)
;;;957        {
;;;958          /* Enable the temperature sensor channel*/
;;;959          ADC1_2->CCR |= ADC12_CCR_TSEN;
;;;960        }
;;;961        else
;;;962        {
;;;963          /* Disable the temperature sensor channel*/
;;;964          ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_TSEN;
00000e  f8d20308          LDR      r0,[r2,#0x308]
000012  b111              CBZ      r1,|L60.26|
000014  f4400000          ORR      r0,r0,#0x800000       ;959
000018  e001              B        |L60.30|
                  |L60.26|
00001a  f4200000          BIC      r0,r0,#0x800000
                  |L60.30|
00001e  f8c20308          STR      r0,[r2,#0x308]
;;;965        }
;;;966      }
;;;967      else
;;;968      {
;;;969        if (NewState != DISABLE)
;;;970        {
;;;971          /* Enable the temperature sensor channel*/
;;;972          ADC3_4->CCR |= ADC34_CCR_TSEN;
;;;973        }
;;;974        else
;;;975        {
;;;976          /* Disable the temperature sensor channel*/
;;;977          ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_TSEN;
;;;978        }
;;;979      }
;;;980    }
000022  4770              BX       lr
                  |L60.36|
000024  4806              LDR      r0,|L60.64|
000026  2900              CMP      r1,#0                 ;969
000028  6801              LDR      r1,[r0,#0]            ;977
00002a  d002              BEQ      |L60.50|
00002c  f4410100          ORR      r1,r1,#0x800000       ;972
000030  e001              B        |L60.54|
                  |L60.50|
000032  f4210100          BIC      r1,r1,#0x800000       ;977
                  |L60.54|
000036  6001              STR      r1,[r0,#0]            ;977
000038  4770              BX       lr
;;;981    
                          ENDP

00003a  0000              DCW      0x0000
                  |L60.60|
                          DCD      0x50000100
                  |L60.64|
                          DCD      0x50000708

                          AREA ||i.ADC_VbatCmd||, CODE, READONLY, ALIGN=2

                  ADC_VbatCmd PROC
;;;1029     */
;;;1030   void ADC_VbatCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  f04f42a0          MOV      r2,#0x50000000
;;;1031   {
;;;1032     /* Check the parameters */
;;;1033     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1034     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1035   
;;;1036     if((ADCx == ADC1) || (ADCx == ADC2))
000004  4290              CMP      r0,r2
000006  d002              BEQ      |L61.14|
000008  4b0c              LDR      r3,|L61.60|
00000a  4298              CMP      r0,r3
00000c  d10a              BNE      |L61.36|
                  |L61.14|
;;;1037     {
;;;1038       if (NewState != DISABLE)
;;;1039       {
;;;1040         /* Enable the Vbat channel*/
;;;1041         ADC1_2->CCR |= ADC12_CCR_VBATEN;
;;;1042       }
;;;1043       else
;;;1044       {
;;;1045         /* Disable the Vbat channel*/
;;;1046         ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VBATEN;
00000e  f8d20308          LDR      r0,[r2,#0x308]
000012  b111              CBZ      r1,|L61.26|
000014  f0407080          ORR      r0,r0,#0x1000000      ;1041
000018  e001              B        |L61.30|
                  |L61.26|
00001a  f0207080          BIC      r0,r0,#0x1000000
                  |L61.30|
00001e  f8c20308          STR      r0,[r2,#0x308]
;;;1047       }
;;;1048     }
;;;1049     else
;;;1050     {
;;;1051       if (NewState != DISABLE)
;;;1052       {
;;;1053         /* Enable the Vbat channel*/
;;;1054         ADC3_4->CCR |= ADC34_CCR_VBATEN;
;;;1055       }
;;;1056       else
;;;1057       {
;;;1058         /* Disable the Vbat channel*/
;;;1059         ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VBATEN;
;;;1060       }
;;;1061     }
;;;1062   }
000022  4770              BX       lr
                  |L61.36|
000024  4806              LDR      r0,|L61.64|
000026  2900              CMP      r1,#0                 ;1051
000028  6801              LDR      r1,[r0,#0]            ;1059
00002a  d002              BEQ      |L61.50|
00002c  f0417180          ORR      r1,r1,#0x1000000      ;1054
000030  e001              B        |L61.54|
                  |L61.50|
000032  f0217180          BIC      r1,r1,#0x1000000      ;1059
                  |L61.54|
000036  6001              STR      r1,[r0,#0]            ;1059
000038  4770              BX       lr
;;;1063   
                          ENDP

00003a  0000              DCW      0x0000
                  |L61.60|
                          DCD      0x50000100
                  |L61.64|
                          DCD      0x50000708

                          AREA ||i.ADC_VoltageRegulatorCmd||, CODE, READONLY, ALIGN=1

                  ADC_VoltageRegulatorCmd PROC
;;;531      */
;;;532    void ADC_VoltageRegulatorCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  6882              LDR      r2,[r0,#8]
;;;533    {
;;;534      /* Check the parameters */
;;;535      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;536      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;537    
;;;538      /* set the intermediate state before moving the ADC voltage regulator 
;;;539      from enable state to disable state or from disable state to enable state */
;;;540      ADCx->CR &= ~(ADC_CR_ADVREGEN);
000002  f0225240          BIC      r2,r2,#0x30000000
000006  6082              STR      r2,[r0,#8]
;;;541      
;;;542      if (NewState != DISABLE)
000008  2900              CMP      r1,#0
;;;543      {
;;;544        /* Set the ADVREGEN bit 0 */
;;;545        ADCx->CR |= ADC_CR_ADVREGEN_0;
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Set the ADVREGEN bit 1 */
;;;550        ADCx->CR |=ADC_CR_ADVREGEN_1;
00000a  6881              LDR      r1,[r0,#8]
00000c  d002              BEQ      |L62.20|
00000e  f0415180          ORR      r1,r1,#0x10000000     ;545
000012  e001              B        |L62.24|
                  |L62.20|
000014  f0415100          ORR      r1,r1,#0x20000000
                  |L62.24|
000018  6081              STR      r1,[r0,#8]            ;545
;;;551      }
;;;552    }
00001a  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.ADC_VrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_VrefintCmd PROC
;;;988      */
;;;989    void ADC_VrefintCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  f04f42a0          MOV      r2,#0x50000000
;;;990    {
;;;991      /* Check the parameters */
;;;992      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;993      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;994    
;;;995      if((ADCx == ADC1) || (ADCx == ADC2))
000004  4290              CMP      r0,r2
000006  d002              BEQ      |L63.14|
000008  4b0c              LDR      r3,|L63.60|
00000a  4298              CMP      r0,r3
00000c  d10a              BNE      |L63.36|
                  |L63.14|
;;;996      {
;;;997        if (NewState != DISABLE)
;;;998        {
;;;999          /* Enable the Vrefint channel*/
;;;1000         ADC1_2->CCR |= ADC12_CCR_VREFEN;
;;;1001       }
;;;1002       else
;;;1003       {
;;;1004         /* Disable the Vrefint channel*/
;;;1005         ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VREFEN;
00000e  f8d20308          LDR      r0,[r2,#0x308]
000012  b111              CBZ      r1,|L63.26|
000014  f4400080          ORR      r0,r0,#0x400000       ;1000
000018  e001              B        |L63.30|
                  |L63.26|
00001a  f4200080          BIC      r0,r0,#0x400000
                  |L63.30|
00001e  f8c20308          STR      r0,[r2,#0x308]
;;;1006       }
;;;1007     }
;;;1008     else
;;;1009     {
;;;1010       if (NewState != DISABLE)
;;;1011       {
;;;1012         /* Enable the Vrefint channel*/
;;;1013         ADC3_4->CCR |= ADC34_CCR_VREFEN;
;;;1014       }
;;;1015       else
;;;1016       {
;;;1017         /* Disable the Vrefint channel*/
;;;1018         ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VREFEN;
;;;1019       }
;;;1020     }
;;;1021   }
000022  4770              BX       lr
                  |L63.36|
000024  4806              LDR      r0,|L63.64|
000026  2900              CMP      r1,#0                 ;1010
000028  6801              LDR      r1,[r0,#0]            ;1018
00002a  d002              BEQ      |L63.50|
00002c  f4410180          ORR      r1,r1,#0x400000       ;1013
000030  e001              B        |L63.54|
                  |L63.50|
000032  f4210180          BIC      r1,r1,#0x400000       ;1018
                  |L63.54|
000036  6001              STR      r1,[r0,#0]            ;1018
000038  4770              BX       lr
;;;1022   
                          ENDP

00003a  0000              DCW      0x0000
                  |L63.60|
                          DCD      0x50000100
                  |L63.64|
                          DCD      0x50000708

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_adc_c_e11a2ea2____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f30x_adc_c_e11a2ea2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_adc_c_e11a2ea2____REVSH|
#line 128
|__asm___15_stm32f30x_adc_c_e11a2ea2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
