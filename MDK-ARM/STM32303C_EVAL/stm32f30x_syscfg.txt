; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_syscfg.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_syscfg.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_syscfg.c]
                          THUMB

                          AREA ||i.SYSCFG_BreakConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_BreakConfig PROC
;;;374      */
;;;375    void SYSCFG_BreakConfig(uint32_t SYSCFG_Break)
000000  4902              LDR      r1,|L1.12|
;;;376    {
;;;377      /* Check the parameter */
;;;378      assert_param(IS_SYSCFG_LOCK_CONFIG(SYSCFG_Break));
;;;379    
;;;380      SYSCFG->CFGR2 |= (uint32_t) SYSCFG_Break;
000002  698a              LDR      r2,[r1,#0x18]
000004  4302              ORRS     r2,r2,r0
000006  618a              STR      r2,[r1,#0x18]
;;;381    }
000008  4770              BX       lr
;;;382    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_BypassParityCheckDisable||, CODE, READONLY, ALIGN=2

                  SYSCFG_BypassParityCheckDisable PROC
;;;389      */
;;;390    void SYSCFG_BypassParityCheckDisable(void)
000000  4902              LDR      r1,|L2.12|
;;;391    {
;;;392      /* Disable the adddress parity check on RAM */
;;;393      *(__IO uint32_t *) CFGR1_BYPADDRPAR_BB = (uint32_t)0x00000001;
000002  2001              MOVS     r0,#1
000004  f8c10310          STR      r0,[r1,#0x310]
;;;394    }
000008  4770              BX       lr
;;;395    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x42200000

                          AREA ||i.SYSCFG_ClearFlag||, CODE, READONLY, ALIGN=2

                  SYSCFG_ClearFlag PROC
;;;447      */
;;;448    void SYSCFG_ClearFlag(uint32_t SYSCFG_Flag)
000000  4902              LDR      r1,|L3.12|
;;;449    {
;;;450      /* Check the parameter */
;;;451      assert_param(IS_SYSCFG_FLAG(SYSCFG_Flag));
;;;452    
;;;453      SYSCFG->CFGR2 |= (uint32_t) SYSCFG_Flag;
000002  698a              LDR      r2,[r1,#0x18]
000004  4302              ORRS     r2,r2,r0
000006  618a              STR      r2,[r1,#0x18]
;;;454    }
000008  4770              BX       lr
;;;455    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_DMAChannelRemapConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_DMAChannelRemapConfig PROC
;;;174      */
;;;175    void SYSCFG_DMAChannelRemapConfig(uint32_t SYSCFG_DMARemap, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;176    {
;;;177      /* Check the parameters */
;;;178      assert_param(IS_SYSCFG_DMA_REMAP(SYSCFG_DMARemap));
;;;179      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;180    
;;;181      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;182      {
;;;183        /* Remap the DMA channel */
;;;184        SYSCFG->CFGR1 |= (uint32_t)SYSCFG_DMARemap;
;;;185      }
;;;186      else
;;;187      {
;;;188        /* use the default DMA channel mapping */
;;;189        SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_DMARemap);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;184
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6011              STR      r1,[r2,#0]            ;184
;;;190      }
;;;191    }
000010  4770              BX       lr
;;;192    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_DeInit||, CODE, READONLY, ALIGN=2

                  SYSCFG_DeInit PROC
;;;107      */
;;;108    void SYSCFG_DeInit(void)
000000  4808              LDR      r0,|L5.36|
;;;109    {
;;;110      /* Reset SYSCFG_CFGR1 register to reset value without affecting MEM_MODE bits */
;;;111      SYSCFG->CFGR1 &= SYSCFG_CFGR1_MEM_MODE;
000002  6801              LDR      r1,[r0,#0]
000004  f0010103          AND      r1,r1,#3
000008  6001              STR      r1,[r0,#0]
;;;112      /* Set FPU Interrupt Enable bits to default value */
;;;113      SYSCFG->CFGR1 |= 0x7C000000;
00000a  6801              LDR      r1,[r0,#0]
00000c  f04141f8          ORR      r1,r1,#0x7c000000
000010  6001              STR      r1,[r0,#0]
;;;114      /* Reset RAM Write protection bits to default value */
;;;115      SYSCFG->RCR = 0x00000000;
000012  2100              MOVS     r1,#0
000014  6041              STR      r1,[r0,#4]
;;;116      /* Set EXTICRx registers to reset value */
;;;117      SYSCFG->EXTICR[0] = 0;
000016  6081              STR      r1,[r0,#8]
;;;118      SYSCFG->EXTICR[1] = 0;
000018  60c1              STR      r1,[r0,#0xc]
;;;119      SYSCFG->EXTICR[2] = 0;
00001a  6101              STR      r1,[r0,#0x10]
;;;120      SYSCFG->EXTICR[3] = 0;
00001c  6141              STR      r1,[r0,#0x14]
;;;121      /* Set CFGR2 register to reset value */
;;;122      SYSCFG->CFGR2 = 0;
00001e  6181              STR      r1,[r0,#0x18]
;;;123    }
000020  4770              BX       lr
;;;124    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_EXTILineConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_EXTILineConfig PROC
;;;350      */
;;;351    void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
000000  b510              PUSH     {r4,lr}
;;;352    {
;;;353      uint32_t tmp = 0x00;
;;;354    
;;;355      /* Check the parameters */
;;;356      assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
;;;357      assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
;;;358      
;;;359      tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
000002  078a              LSLS     r2,r1,#30
;;;360      SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
000004  f0210403          BIC      r4,r1,#3
000008  4906              LDR      r1,|L6.36|
00000a  0f13              LSRS     r3,r2,#28             ;359
00000c  4421              ADD      r1,r1,r4
00000e  220f              MOVS     r2,#0xf               ;359
000010  688c              LDR      r4,[r1,#8]
000012  409a              LSLS     r2,r2,r3              ;359
000014  4394              BICS     r4,r4,r2
000016  608c              STR      r4,[r1,#8]
;;;361      SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
000018  688a              LDR      r2,[r1,#8]
00001a  4098              LSLS     r0,r0,r3
00001c  4302              ORRS     r2,r2,r0
00001e  608a              STR      r2,[r1,#8]
;;;362    }
000020  bd10              POP      {r4,pc}
;;;363    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_EncoderRemapConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_EncoderRemapConfig PROC
;;;234      */
;;;235    void SYSCFG_EncoderRemapConfig(uint32_t SYSCFG_EncoderRemap)
000000  4904              LDR      r1,|L7.20|
;;;236    {
;;;237      /* Check the parameter */
;;;238      assert_param(IS_SYSCFG_ENCODER_REMAP(SYSCFG_EncoderRemap));
;;;239    
;;;240      /* Reset the encoder mode remapping bits */
;;;241      SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_CFGR1_ENCODER_MODE);
000002  680a              LDR      r2,[r1,#0]
000004  f4220240          BIC      r2,r2,#0xc00000
000008  600a              STR      r2,[r1,#0]
;;;242    
;;;243      /* Set the selected configuration */
;;;244      SYSCFG->CFGR1 |= (uint32_t)(SYSCFG_EncoderRemap);
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;245    }
000010  4770              BX       lr
;;;246    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  SYSCFG_GetFlagStatus PROC
;;;418      */
;;;419    FlagStatus SYSCFG_GetFlagStatus(uint32_t SYSCFG_Flag)
000000  4903              LDR      r1,|L8.16|
;;;420    {
;;;421      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;422    
;;;423      /* Check the parameter */
;;;424      assert_param(IS_SYSCFG_FLAG(SYSCFG_Flag));
;;;425    
;;;426      /* Check the status of the specified SPI flag */
;;;427      if ((SYSCFG->CFGR2 & SYSCFG_CFGR2_SRAM_PE) != (uint32_t)RESET)
000004  6989              LDR      r1,[r1,#0x18]
000006  05c9              LSLS     r1,r1,#23
000008  d500              BPL      |L8.12|
;;;428      {
;;;429        /* SYSCFG_Flag is set */
;;;430        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;431      }
;;;432      else
;;;433      {
;;;434        /* SYSCFG_Flag is reset */
;;;435        bitstatus = RESET;
;;;436      }
;;;437      /* Return the SYSCFG_Flag status */
;;;438      return  bitstatus;
;;;439    }
00000c  4770              BX       lr
;;;440    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_I2CFastModePlusConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_I2CFastModePlusConfig PROC
;;;292      */
;;;293    void SYSCFG_I2CFastModePlusConfig(uint32_t SYSCFG_I2CFastModePlus, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;294    {
;;;295      /* Check the parameters */
;;;296      assert_param(IS_SYSCFG_I2C_FMP(SYSCFG_I2CFastModePlus));
;;;297      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;298    
;;;299      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;300      {
;;;301        /* Enable fast mode plus driving capability for selected I2C pin */
;;;302        SYSCFG->CFGR1 |= (uint32_t)SYSCFG_I2CFastModePlus;
;;;303      }
;;;304      else
;;;305      {
;;;306        /* Disable fast mode plus driving capability for selected I2C pin */
;;;307        SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_I2CFastModePlus);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;302
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;302
;;;308      }
;;;309    }
000010  4770              BX       lr
;;;310    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_ITConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_ITConfig PROC
;;;324      */
;;;325    void SYSCFG_ITConfig(uint32_t SYSCFG_IT, FunctionalState NewState)  
000000  4a04              LDR      r2,|L10.20|
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;329      assert_param(IS_SYSCFG_IT(SYSCFG_IT)); 
;;;330    
;;;331      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;332      {
;;;333        /* Enable the selected SYSCFG interrupts */
;;;334        SYSCFG->CFGR1 |= SYSCFG_IT;
;;;335      }
;;;336      else
;;;337      {
;;;338        /* Disable the selected SYSCFG interrupts */
;;;339        SYSCFG->CFGR1 &= ((uint32_t)~SYSCFG_IT);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;334
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6011              STR      r1,[r2,#0]            ;334
;;;340      }
;;;341    }
000010  4770              BX       lr
;;;342    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_MemoryRemapConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_MemoryRemapConfig PROC
;;;133      */
;;;134    void SYSCFG_MemoryRemapConfig(uint32_t SYSCFG_MemoryRemap)
000000  4a03              LDR      r2,|L11.16|
;;;135    {
;;;136      uint32_t tmpcfgr1 = 0;
;;;137    
;;;138      /* Check the parameter */
;;;139      assert_param(IS_SYSCFG_MEMORY_REMAP(SYSCFG_MemoryRemap));
;;;140    
;;;141      /* Get CFGR1 register value */
;;;142      tmpcfgr1 = SYSCFG->CFGR1;
000002  6811              LDR      r1,[r2,#0]
;;;143    
;;;144      /* Clear MEM_MODE bits */
;;;145      tmpcfgr1 &= (uint32_t) (~SYSCFG_CFGR1_MEM_MODE);
000004  f0210103          BIC      r1,r1,#3
;;;146    
;;;147      /* Set the new MEM_MODE bits value */
;;;148      tmpcfgr1 |= (uint32_t) SYSCFG_MemoryRemap;
000008  4301              ORRS     r1,r1,r0
;;;149    
;;;150      /* Set CFGR1 register with the new memory remap configuration */
;;;151      SYSCFG->CFGR1 = tmpcfgr1;
00000a  6011              STR      r1,[r2,#0]
;;;152    }
00000c  4770              BX       lr
;;;153    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_SRAMWRPEnable||, CODE, READONLY, ALIGN=2

                  SYSCFG_SRAMWRPEnable PROC
;;;402      */
;;;403    void SYSCFG_SRAMWRPEnable(uint32_t SYSCFG_SRAMWRP)
000000  4902              LDR      r1,|L12.12|
;;;404    {
;;;405      /* Check the parameter */
;;;406      assert_param(IS_SYSCFG_PAGE(SYSCFG_SRAMWRP));
;;;407    
;;;408      /* Enable the write-protection on the selected ICODE SRAM page */
;;;409      SYSCFG->RCR |= (uint32_t)SYSCFG_SRAMWRP;
000002  684a              LDR      r2,[r1,#4]
000004  4302              ORRS     r2,r2,r0
000006  604a              STR      r2,[r1,#4]
;;;410    }
000008  4770              BX       lr
;;;411    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_TriggerRemapConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_TriggerRemapConfig PROC
;;;204      */
;;;205    void SYSCFG_TriggerRemapConfig(uint32_t SYSCFG_TriggerRemap, FunctionalState NewState)
000000  4a04              LDR      r2,|L13.20|
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_SYSCFG_TRIGGER_REMAP(SYSCFG_TriggerRemap));
;;;209      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;210    
;;;211      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;212      {
;;;213        /* Remap the trigger */
;;;214        SYSCFG->CFGR1 |= (uint32_t)SYSCFG_TriggerRemap;
;;;215      }
;;;216      else
;;;217      {
;;;218        /* Use the default trigger mapping */
;;;219        SYSCFG->CFGR1 &= (uint32_t)(~SYSCFG_TriggerRemap);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;214
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6011              STR      r1,[r2,#0]            ;214
;;;220      }
;;;221    }
000010  4770              BX       lr
;;;222    
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_USBInterruptLineRemapCmd||, CODE, READONLY, ALIGN=2

                  SYSCFG_USBInterruptLineRemapCmd PROC
;;;260      */
;;;261    void SYSCFG_USBInterruptLineRemapCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L14.8|
;;;262    {
;;;263      /* Check the parameter */
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265    
;;;266      /* Remap the USB interupt lines */
;;;267      *(__IO uint32_t *) CFGR1_USBITRMP_BB = (uint32_t)NewState;
000002  6148              STR      r0,[r1,#0x14]
;;;268    }
000004  4770              BX       lr
;;;269    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      0x42200000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_syscfg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f30x_syscfg_c_57637610____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_stm32f30x_syscfg_c_57637610____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f30x_syscfg_c_57637610____REVSH|
#line 128
|__asm___18_stm32f30x_syscfg_c_57637610____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
