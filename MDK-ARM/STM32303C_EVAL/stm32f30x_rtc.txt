; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_rtc.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_rtc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1271     */
;;;1272   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1273   {
;;;1274     __IO uint32_t alarmcounter = 0x00;
000002  2200              MOVS     r2,#0
;;;1275     uint32_t alarmstatus = 0x00;
;;;1276     ErrorStatus status = ERROR;
;;;1277       
;;;1278     /* Check the parameters */
;;;1279     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1280     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1281   
;;;1282     /* Disable the write protection for RTC registers */
;;;1283     RTC->WPR = 0xCA;
000004  4b12              LDR      r3,|L1.80|
000006  9200              STR      r2,[sp,#0]
000008  22ca              MOVS     r2,#0xca
00000a  601a              STR      r2,[r3,#0]
;;;1284     RTC->WPR = 0x53;
00000c  2253              MOVS     r2,#0x53
00000e  601a              STR      r2,[r3,#0]
;;;1285   
;;;1286     /* Configure the Alarm state */
;;;1287     if (NewState != DISABLE)
;;;1288     {
;;;1289       RTC->CR |= (uint32_t)RTC_Alarm;
000010  4a0f              LDR      r2,|L1.80|
000012  3a1c              SUBS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;1287
;;;1290   
;;;1291       status = SUCCESS;    
;;;1292     }
;;;1293     else
;;;1294     { 
;;;1295       /* Disable the Alarm in RTC_CR register */
;;;1296       RTC->CR &= (uint32_t)~RTC_Alarm;
000016  6811              LDR      r1,[r2,#0]
000018  d002              BEQ      |L1.32|
00001a  4301              ORRS     r1,r1,r0              ;1289
00001c  6011              STR      r1,[r2,#0]            ;1289
00001e  e012              B        |L1.70|
                  |L1.32|
000020  4381              BICS     r1,r1,r0
000022  6011              STR      r1,[r2,#0]
;;;1297      
;;;1298       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1299       do
;;;1300       {
;;;1301         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000024  4a0a              LDR      r2,|L1.80|
000026  3a18              SUBS     r2,r2,#0x18
;;;1302         alarmcounter++;  
;;;1303       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000028  1455              ASRS     r5,r2,#17
                  |L1.42|
00002a  6811              LDR      r1,[r2,#0]            ;1301
00002c  9c00              LDR      r4,[sp,#0]            ;1302
00002e  ea012110          AND      r1,r1,r0,LSR #8       ;1301
000032  1c64              ADDS     r4,r4,#1              ;1302
000034  9400              STR      r4,[sp,#0]
000036  42ac              CMP      r4,r5
000038  d001              BEQ      |L1.62|
00003a  2900              CMP      r1,#0
00003c  d0f5              BEQ      |L1.42|
                  |L1.62|
;;;1304       
;;;1305       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
00003e  6811              LDR      r1,[r2,#0]
000040  ea112010          ANDS     r0,r1,r0,LSR #8
000044  d000              BEQ      |L1.72|
                  |L1.70|
;;;1306       {
;;;1307         status = ERROR;
;;;1308       } 
;;;1309       else
;;;1310       {
;;;1311         status = SUCCESS;
000046  2001              MOVS     r0,#1
                  |L1.72|
;;;1312       }        
;;;1313     } 
;;;1314   
;;;1315     /* Enable the write protection for RTC registers */
;;;1316     RTC->WPR = 0xFF;
000048  21ff              MOVS     r1,#0xff
00004a  6019              STR      r1,[r3,#0]
;;;1317     
;;;1318     return status;
;;;1319   }
00004c  bd38              POP      {r3-r5,pc}
;;;1320   
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1187     */
;;;1188   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1189   {
;;;1190     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1191     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1192     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1193     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1194     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1195   
;;;1196     /* Alarm Date Settings : Date = 1st day of the month */
;;;1197     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1198     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000a  2201              MOVS     r2,#1
00000c  6081              STR      r1,[r0,#8]
00000e  7302              STRB     r2,[r0,#0xc]
;;;1199   
;;;1200     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1201     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  6041              STR      r1,[r0,#4]
;;;1202   }
000012  4770              BX       lr
;;;1203   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1365     */
;;;1366   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  b510              PUSH     {r4,lr}
;;;1367   {
;;;1368     uint32_t tmpreg = 0;
;;;1369   
;;;1370     /* Check the parameters */
;;;1371     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1372     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1373     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1374     
;;;1375     /* Disable the write protection for RTC registers */
;;;1376     RTC->WPR = 0xCA;
000002  4b09              LDR      r3,|L3.40|
000004  24ca              MOVS     r4,#0xca
000006  601c              STR      r4,[r3,#0]
;;;1377     RTC->WPR = 0x53;
000008  2453              MOVS     r4,#0x53
00000a  601c              STR      r4,[r3,#0]
;;;1378     
;;;1379     /* Configure the Alarm A or Alarm B SubSecond registers */
;;;1380     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
00000c  4311              ORRS     r1,r1,r2
;;;1381     
;;;1382     if (RTC_Alarm == RTC_Alarm_A)
00000e  f5b07f80          CMP      r0,#0x100
000012  d005              BEQ      |L3.32|
;;;1383     {
;;;1384       /* Configure the AlarmA SubSecond register */
;;;1385       RTC->ALRMASSR = tmpreg;
;;;1386     }
;;;1387     else
;;;1388     {
;;;1389       /* Configure the Alarm B SubSecond register */
;;;1390       RTC->ALRMBSSR = tmpreg;
000014  4804              LDR      r0,|L3.40|
000016  3024              ADDS     r0,r0,#0x24
                  |L3.24|
000018  6001              STR      r1,[r0,#0]
;;;1391     }
;;;1392   
;;;1393     /* Enable the write protection for RTC registers */
;;;1394     RTC->WPR = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  6018              STR      r0,[r3,#0]
;;;1395   
;;;1396   }
00001e  bd10              POP      {r4,pc}
                  |L3.32|
000020  4801              LDR      r0,|L3.40|
000022  3020              ADDS     r0,r0,#0x20           ;1385
000024  e7f8              B        |L3.24|
;;;1397   
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40002824

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2578     */
;;;2579   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;2580   {
;;;2581     uint8_t tmp = 0;
;;;2582     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000002  eb010181          ADD      r1,r1,r1,LSL #2
;;;2583     return (tmp + (Value & (uint8_t)0x0F));
000006  f000000f          AND      r0,r0,#0xf
00000a  eb000041          ADD      r0,r0,r1,LSL #1
00000e  b2c0              UXTB     r0,r0
;;;2584   }
000010  4770              BX       lr
;;;2585   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;671    */
;;;672    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L5.40|
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;676    
;;;677      /* Disable the write protection for RTC registers */
;;;678      RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;679      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;680      
;;;681      if (NewState != DISABLE)
;;;682      {
;;;683        /* Set the BYPSHAD bit */
;;;684        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000a  4907              LDR      r1,|L5.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;681
;;;685      }
;;;686      else
;;;687      {
;;;688        /* Reset the BYPSHAD bit */
;;;689        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L5.26|
000014  f0400020          ORR      r0,r0,#0x20           ;684
000018  e001              B        |L5.30|
                  |L5.26|
00001a  f00000df          AND      r0,r0,#0xdf
                  |L5.30|
00001e  6008              STR      r0,[r1,#0]
;;;690      }
;;;691    
;;;692      /* Enable the write protection for RTC registers */
;;;693      RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;694    }
000024  4770              BX       lr
;;;695    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40002824

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2560     */
;;;2561   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2562   {
000002  e003              B        |L6.12|
                  |L6.4|
000004  1c49              ADDS     r1,r1,#1
;;;2563     uint8_t bcdhigh = 0;
;;;2564     
;;;2565     while (Value >= 10)
;;;2566     {
;;;2567       bcdhigh++;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c9              UXTB     r1,r1
;;;2568       Value -= 10;
00000a  b2c0              UXTB     r0,r0
                  |L6.12|
00000c  280a              CMP      r0,#0xa               ;2565
00000e  d2f9              BCS      |L6.4|
;;;2569     }
;;;2570     
;;;2571     return  ((uint8_t)(bcdhigh << 4) | Value);
000010  0709              LSLS     r1,r1,#28
000012  ea406011          ORR      r0,r0,r1,LSR #24
;;;2572   }
000016  4770              BX       lr
;;;2573   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1698     */
;;;1699   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L7.40|
;;;1700   {
;;;1701     /* Check the parameters */
;;;1702     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1703     
;;;1704     /* Disable the write protection for RTC registers */
;;;1705     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1706     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1707     
;;;1708     if (NewState != DISABLE)
;;;1709     {
;;;1710       /* Enable the RTC clock output */
;;;1711       RTC->CR |= (uint32_t)RTC_CR_COE;
00000a  4907              LDR      r1,|L7.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;1708
;;;1712     }
;;;1713     else
;;;1714     { 
;;;1715       /* Disable the RTC clock output */
;;;1716       RTC->CR &= (uint32_t)~RTC_CR_COE;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L7.26|
000014  f4400000          ORR      r0,r0,#0x800000       ;1711
000018  e001              B        |L7.30|
                  |L7.26|
00001a  f4200000          BIC      r0,r0,#0x800000
                  |L7.30|
00001e  6008              STR      r0,[r1,#0]
;;;1717     }
;;;1718     
;;;1719     /* Enable the write protection for RTC registers */
;;;1720     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;1721   }
000024  4770              BX       lr
;;;1722   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40002824

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1730   */
;;;1731   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  4a08              LDR      r2,|L8.36|
;;;1732   {
;;;1733     /* Check the parameters */
;;;1734     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1735   
;;;1736     /* Disable the write protection for RTC registers */
;;;1737     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1738     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1739     
;;;1740     /*clear flags before config*/
;;;1741     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
00000a  4906              LDR      r1,|L8.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f4232300          BIC      r3,r3,#0x80000
000014  600b              STR      r3,[r1,#0]
;;;1742   
;;;1743     /* Configure the RTC_CR register */
;;;1744     RTC->CR |= (uint32_t)RTC_CalibOutput;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1745   
;;;1746     /* Enable the write protection for RTC registers */
;;;1747     RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1748   }
000020  4770              BX       lr
;;;1749   
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2473     */
;;;2474   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  f3c00010          UBFX     r0,r0,#0,#17
;;;2475   {
;;;2476     /* Check the parameters */
;;;2477     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2478   
;;;2479     /* Clear the Flags in the RTC_ISR register */
;;;2480     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));    
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L9.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2481   }
000016  4770              BX       lr
;;;2482   
                          ENDP

                  |L9.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2537     */
;;;2538   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  f3c0100f          UBFX     r0,r0,#4,#16
;;;2539   {
;;;2540     uint32_t tmpreg = 0;
;;;2541   
;;;2542     /* Check the parameters */
;;;2543     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2544   
;;;2545     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2546     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2547   
;;;2548     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2549     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L10.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2550   }
000016  4770              BX       lr
;;;2551   
                          ENDP

                  |L10.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;997      */
;;;998    void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;999    {
;;;1000     /* Monday, January 01 xx00 */
;;;1001     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;1002     RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;1003     RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;1004     RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;1005   }
00000c  4770              BX       lr
;;;1006   
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1590     */
;;;1591   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  4b09              LDR      r3,|L12.40|
;;;1592   {
000002  b510              PUSH     {r4,lr}
;;;1593     /* Check the parameters */
;;;1594     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1595     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1596   
;;;1597     /* Disable the write protection for RTC registers */
;;;1598     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1599     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1600   
;;;1601     /* Clear the bits to be configured */
;;;1602     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000c  4a06              LDR      r2,|L12.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f4242480          BIC      r4,r4,#0x40000
000016  6014              STR      r4,[r2,#0]
;;;1603   
;;;1604     /* Configure the RTC_CR register */
;;;1605     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1606   
;;;1607     /* Enable the write protection for RTC registers */
;;;1608     RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1609   }
000024  bd10              POP      {r4,pc}
;;;1610   
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;327      */
;;;328    ErrorStatus RTC_DeInit(void)
000000  b578              PUSH     {r3-r6,lr}
;;;329    {
;;;330      __IO uint32_t wutcounter = 0x00;
000002  2400              MOVS     r4,#0
;;;331      uint32_t wutwfstatus = 0x00;
;;;332      ErrorStatus status = ERROR;
;;;333      
;;;334      /* Disable the write protection for RTC registers */
;;;335      RTC->WPR = 0xCA;
000004  4e27              LDR      r6,|L13.164|
000006  20ca              MOVS     r0,#0xca
000008  9400              STR      r4,[sp,#0]
00000a  4625              MOV      r5,r4                 ;332
00000c  6030              STR      r0,[r6,#0]
;;;336      RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6030              STR      r0,[r6,#0]
;;;337    
;;;338      /* Set Initialization mode */
;;;339      if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b3e8              CBZ      r0,|L13.148|
;;;340      {
;;;341        status = ERROR;
;;;342      }  
;;;343      else
;;;344      {
;;;345        /* Reset TR, DR and CR registers */
;;;346        RTC->TR = (uint32_t)0x00000000;
000018  4822              LDR      r0,|L13.164|
00001a  3824              SUBS     r0,r0,#0x24
00001c  6004              STR      r4,[r0,#0]
;;;347        RTC->DR = (uint32_t)0x00002101;
00001e  4921              LDR      r1,|L13.164|
000020  f2421001          MOV      r0,#0x2101
000024  3920              SUBS     r1,r1,#0x20
000026  6008              STR      r0,[r1,#0]
;;;348        
;;;349        /* Reset All CR bits except CR[2:0] */
;;;350        RTC->CR &= (uint32_t)0x00000007;
000028  1d09              ADDS     r1,r1,#4
00002a  6808              LDR      r0,[r1,#0]
00002c  f0000007          AND      r0,r0,#7
000030  6008              STR      r0,[r1,#0]
;;;351      
;;;352        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;353        do
;;;354        {
;;;355          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
;;;356          wutcounter++;  
;;;357        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000032  144d              ASRS     r5,r1,#17
000034  1d08              ADDS     r0,r1,#4              ;355
                  |L13.54|
000036  6802              LDR      r2,[r0,#0]            ;355
000038  9b00              LDR      r3,[sp,#0]            ;356
00003a  f0020204          AND      r2,r2,#4              ;355
00003e  1c5b              ADDS     r3,r3,#1              ;356
000040  9300              STR      r3,[sp,#0]
000042  42ab              CMP      r3,r5
000044  d001              BEQ      |L13.74|
000046  2a00              CMP      r2,#0
000048  d0f5              BEQ      |L13.54|
                  |L13.74|
;;;358        
;;;359        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00004a  6802              LDR      r2,[r0,#0]
00004c  0752              LSLS     r2,r2,#29
00004e  d527              BPL      |L13.160|
;;;360        {
;;;361          status = ERROR;
;;;362        }
;;;363        else
;;;364        {
;;;365          /* Reset all RTC CR register bits */
;;;366          RTC->CR        &= (uint32_t)0x00000000;
000050  680a              LDR      r2,[r1,#0]
000052  600c              STR      r4,[r1,#0]
;;;367          RTC->WUTR      = (uint32_t)0x0000FFFF;
000054  4a13              LDR      r2,|L13.164|
000056  f64f71ff          MOV      r1,#0xffff
00005a  3a10              SUBS     r2,r2,#0x10
00005c  6011              STR      r1,[r2,#0]
;;;368          RTC->PRER      = (uint32_t)0x007F00FF;
00005e  1f12              SUBS     r2,r2,#4
000060  4911              LDR      r1,|L13.168|
000062  6011              STR      r1,[r2,#0]
;;;369          RTC->ALRMAR    = (uint32_t)0x00000000;
000064  490f              LDR      r1,|L13.164|
000066  3908              SUBS     r1,r1,#8
000068  600c              STR      r4,[r1,#0]
;;;370          RTC->ALRMBR    = (uint32_t)0x00000000;
00006a  1d09              ADDS     r1,r1,#4
00006c  600c              STR      r4,[r1,#0]
;;;371          RTC->SHIFTR    = (uint32_t)0x00000000;
00006e  490d              LDR      r1,|L13.164|
000070  3108              ADDS     r1,r1,#8
000072  600c              STR      r4,[r1,#0]
;;;372          RTC->CALR       = (uint32_t)0x00000000;
000074  490b              LDR      r1,|L13.164|
000076  3118              ADDS     r1,r1,#0x18
000078  600c              STR      r4,[r1,#0]
;;;373          RTC->ALRMASSR  = (uint32_t)0x00000000;
00007a  490a              LDR      r1,|L13.164|
00007c  3120              ADDS     r1,r1,#0x20
00007e  600c              STR      r4,[r1,#0]
;;;374          RTC->ALRMBSSR  = (uint32_t)0x00000000;
000080  1d09              ADDS     r1,r1,#4
000082  600c              STR      r4,[r1,#0]
;;;375    
;;;376          /* Reset ISR register and exit initialization mode */
;;;377          RTC->ISR = (uint32_t)0x00000000;
000084  6004              STR      r4,[r0,#0]
;;;378          
;;;379          /* Reset Tamper and alternate functions configuration register */
;;;380          RTC->TAFCR = 0x00000000;
000086  4807              LDR      r0,|L13.164|
000088  301c              ADDS     r0,r0,#0x1c
00008a  6004              STR      r4,[r0,#0]
;;;381          
;;;382          /* Wait till the RTC RSF flag is set */
;;;383          if (RTC_WaitForSynchro() == ERROR)
00008c  f7fffffe          BL       RTC_WaitForSynchro
000090  b130              CBZ      r0,|L13.160|
;;;384          {
;;;385            status = ERROR;
;;;386          }
;;;387          else
;;;388          {
;;;389            status = SUCCESS;
000092  e000              B        |L13.150|
                  |L13.148|
000094  e000              B        |L13.152|
                  |L13.150|
000096  2501              MOVS     r5,#1
                  |L13.152|
;;;390          }
;;;391        }
;;;392      }
;;;393      
;;;394      /* Enable the write protection for RTC registers */
;;;395      RTC->WPR = 0xFF;  
000098  20ff              MOVS     r0,#0xff
00009a  6030              STR      r0,[r6,#0]
;;;396      
;;;397      return status;
00009c  4628              MOV      r0,r5
;;;398    }
00009e  bd78              POP      {r3-r6,pc}
                  |L13.160|
0000a0  2500              MOVS     r5,#0                 ;385
0000a2  e7f9              B        |L13.152|
;;;399    
                          ENDP

                  |L13.164|
                          DCD      0x40002824
                  |L13.168|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;505      */
;;;506    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;507    {
;;;508      __IO uint32_t initcounter = 0x00;
000002  2000              MOVS     r0,#0
;;;509      ErrorStatus status = ERROR;
;;;510      uint32_t initstatus = 0x00;
;;;511         
;;;512      /* Check if the Initialization mode is set */
;;;513      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000004  9000              STR      r0,[sp,#0]
000006  480c              LDR      r0,|L14.56|
000008  6801              LDR      r1,[r0,#0]
00000a  0649              LSLS     r1,r1,#25
00000c  d412              BMI      |L14.52|
;;;514      {
;;;515        /* Set the Initialization mode */
;;;516        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00000e  f04f31ff          MOV      r1,#0xffffffff
000012  6001              STR      r1,[r0,#0]
;;;517        
;;;518        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;519        do
;;;520        {
;;;521          initstatus = RTC->ISR & RTC_ISR_INITF;
;;;522          initcounter++;  
;;;523        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000014  1443              ASRS     r3,r0,#17
                  |L14.22|
000016  6801              LDR      r1,[r0,#0]            ;521
000018  9a00              LDR      r2,[sp,#0]            ;522
00001a  f0010140          AND      r1,r1,#0x40           ;521
00001e  1c52              ADDS     r2,r2,#1              ;522
000020  9200              STR      r2,[sp,#0]
000022  429a              CMP      r2,r3
000024  d001              BEQ      |L14.42|
000026  2900              CMP      r1,#0
000028  d0f5              BEQ      |L14.22|
                  |L14.42|
;;;524        
;;;525        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00002a  6800              LDR      r0,[r0,#0]
00002c  0640              LSLS     r0,r0,#25
00002e  d401              BMI      |L14.52|
;;;526        {
;;;527          status = SUCCESS;
;;;528        }
;;;529        else
;;;530        {
;;;531          status = ERROR;
000030  2000              MOVS     r0,#0
;;;532        }        
;;;533      }
;;;534      else
;;;535      {
;;;536        status = SUCCESS;  
;;;537      } 
;;;538        
;;;539      return (status);  
;;;540    }
000032  bd08              POP      {r3,pc}
                  |L14.52|
000034  2001              MOVS     r0,#1                 ;536
000036  bd08              POP      {r3,pc}
;;;541    
                          ENDP

                  |L14.56|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;550      */
;;;551    void RTC_ExitInitMode(void)
000000  4802              LDR      r0,|L15.12|
;;;552    {
;;;553      /* Exit Initialization mode */
;;;554      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;555    }
00000a  4770              BX       lr
;;;556    
                          ENDP

                  |L15.12|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1217     */
;;;1218   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b510              PUSH     {r4,lr}
;;;1219   {
000002  4614              MOV      r4,r2
;;;1220     uint32_t tmpreg = 0;
;;;1221   
;;;1222     /* Check the parameters */
;;;1223     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1224     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1225   
;;;1226     /* Get the RTC_ALRMxR register */
;;;1227     if (RTC_Alarm == RTC_Alarm_A)
000004  f5b17f80          CMP      r1,#0x100
000008  d02a              BEQ      |L16.96|
;;;1228     {
;;;1229       tmpreg = (uint32_t)(RTC->ALRMAR);
;;;1230     }
;;;1231     else
;;;1232     {
;;;1233       tmpreg = (uint32_t)(RTC->ALRMBR);
00000a  4917              LDR      r1,|L16.104|
                  |L16.12|
00000c  6809              LDR      r1,[r1,#0]
;;;1234     }
;;;1235   
;;;1236     /* Fill the structure with the read parameters */
;;;1237     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00000e  f3c14205          UBFX     r2,r1,#16,#6
000012  7022              STRB     r2,[r4,#0]
;;;1238                                                        RTC_ALRMAR_HU)) >> 16);
;;;1239     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000014  f3c12306          UBFX     r3,r1,#8,#7
000018  7063              STRB     r3,[r4,#1]
;;;1240                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1241     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00001a  f001037f          AND      r3,r1,#0x7f
00001e  70a3              STRB     r3,[r4,#2]
;;;1242                                                        RTC_ALRMAR_SU));
;;;1243     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000020  2340              MOVS     r3,#0x40
000022  ea034311          AND      r3,r3,r1,LSR #16
000026  70e3              STRB     r3,[r4,#3]
;;;1244     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000028  f3c16305          UBFX     r3,r1,#24,#6
00002c  7323              STRB     r3,[r4,#0xc]
;;;1245     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00002e  f0014380          AND      r3,r1,#0x40000000
;;;1246     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000032  f0013180          AND      r1,r1,#0x80808080
000036  e9c41301          STRD     r1,r3,[r4,#4]
00003a  2800              CMP      r0,#0
00003c  d10f              BNE      |L16.94|
00003e  4610              MOV      r0,r2
;;;1247   
;;;1248     if (RTC_Format == RTC_Format_BIN)
;;;1249     {
;;;1250       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  7020              STRB     r0,[r4,#0]
;;;1251                                                           RTC_AlarmTime.RTC_Hours);
;;;1252       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000046  7860              LDRB     r0,[r4,#1]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  7060              STRB     r0,[r4,#1]
;;;1253                                                           RTC_AlarmTime.RTC_Minutes);
;;;1254       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004e  78a0              LDRB     r0,[r4,#2]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  70a0              STRB     r0,[r4,#2]
;;;1255                                                           RTC_AlarmTime.RTC_Seconds);
;;;1256       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000056  7b20              LDRB     r0,[r4,#0xc]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7320              STRB     r0,[r4,#0xc]
                  |L16.94|
;;;1257     }  
;;;1258   }
00005e  bd10              POP      {r4,pc}
                  |L16.96|
000060  4901              LDR      r1,|L16.104|
000062  1f09              SUBS     r1,r1,#4              ;1229
000064  e7d2              B        |L16.12|
;;;1259   
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
                          DCD      0x40002820

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1406     */
;;;1407   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  f5b07f80          CMP      r0,#0x100
;;;1408   {
000004  d004              BEQ      |L17.16|
;;;1409     uint32_t tmpreg = 0;
;;;1410     
;;;1411     /* Get the RTC_ALRMxR register */
;;;1412     if (RTC_Alarm == RTC_Alarm_A)
;;;1413     {
;;;1414       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1415     }
;;;1416     else
;;;1417     {
;;;1418       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000006  4804              LDR      r0,|L17.24|
                  |L17.8|
000008  6800              LDR      r0,[r0,#0]            ;1414
00000a  f3c0000e          UBFX     r0,r0,#0,#15          ;1414
;;;1419     } 
;;;1420     
;;;1421     return (tmpreg);
;;;1422   }
00000e  4770              BX       lr
                  |L17.16|
000010  4801              LDR      r0,|L17.24|
000012  1f00              SUBS     r0,r0,#4              ;1414
000014  e7f8              B        |L17.8|
;;;1423   
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x40002848

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;1016     */
;;;1017   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b510              PUSH     {r4,lr}
;;;1018   {
000002  460c              MOV      r4,r1
;;;1019     uint32_t tmpreg = 0;
;;;1020   
;;;1021     /* Check the parameters */
;;;1022     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1023     
;;;1024     /* Get the RTC_TR register */
;;;1025     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000004  490e              LDR      r1,|L18.64|
000006  6809              LDR      r1,[r1,#0]
000008  4a0e              LDR      r2,|L18.68|
00000a  4011              ANDS     r1,r1,r2
;;;1026   
;;;1027     /* Fill the structure fields with the read parameters */
;;;1028     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
00000c  0c0a              LSRS     r2,r1,#16
00000e  70e2              STRB     r2,[r4,#3]
;;;1029     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000010  f3c12304          UBFX     r3,r1,#8,#5
000014  7063              STRB     r3,[r4,#1]
;;;1030     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
000016  f001033f          AND      r3,r1,#0x3f
00001a  70a3              STRB     r3,[r4,#2]
;;;1031     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
00001c  f3c13142          UBFX     r1,r1,#13,#3
000020  7021              STRB     r1,[r4,#0]
000022  2800              CMP      r0,#0                 ;1018
000024  d10b              BNE      |L18.62|
000026  4610              MOV      r0,r2                 ;1018
;;;1032   
;;;1033     /* Check the input parameters format */
;;;1034     if (RTC_Format == RTC_Format_BIN)
;;;1035     {
;;;1036       /* Convert the structure parameters to Binary format */
;;;1037       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  70e0              STRB     r0,[r4,#3]
;;;1038       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  7060              STRB     r0,[r4,#1]
;;;1039       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000036  78a0              LDRB     r0,[r4,#2]
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  70a0              STRB     r0,[r4,#2]
                  |L18.62|
;;;1040       RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
;;;1041     }
;;;1042   }
00003e  bd10              POP      {r4,pc}
;;;1043   
                          ENDP

                  |L18.64|
                          DCD      0x40002804
                  |L18.68|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2435     */
;;;2436   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  4904              LDR      r1,|L19.20|
;;;2437   {
000002  4602              MOV      r2,r0
;;;2438     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2439     uint32_t tmpreg = 0;
;;;2440     
;;;2441     /* Check the parameters */
;;;2442     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2443     
;;;2444     /* Get all the flags */
;;;2445     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000006  6809              LDR      r1,[r1,#0]
000008  4b03              LDR      r3,|L19.24|
00000a  4019              ANDS     r1,r1,r3
;;;2446     
;;;2447     /* Return the status of the flag */
;;;2448     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00000c  4211              TST      r1,r2
00000e  d000              BEQ      |L19.18|
;;;2449     {
;;;2450       bitstatus = SET;
000010  2001              MOVS     r0,#1
                  |L19.18|
;;;2451     }
;;;2452     else
;;;2453     {
;;;2454       bitstatus = RESET;
;;;2455     }
;;;2456     return bitstatus;
;;;2457   }
000012  4770              BX       lr
;;;2458   
                          ENDP

                  |L19.20|
                          DCD      0x4000280c
                  |L19.24|
                          DCD      0x0001ff7f

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2495     */
;;;2496   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  4a0d              LDR      r2,|L20.56|
;;;2497   {
000002  b510              PUSH     {r4,lr}
;;;2498     ITStatus bitstatus = RESET;
;;;2499     uint32_t tmpreg = 0, enablestatus = 0;
;;;2500    
;;;2501     /* Check the parameters */
;;;2502     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2503     
;;;2504     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2505     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
000004  6812              LDR      r2,[r2,#0]
000006  2100              MOVS     r1,#0                 ;2498
000008  f0020304          AND      r3,r2,#4
;;;2506    
;;;2507     /* Get the Interrupt enable Status */
;;;2508     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
00000c  4a0a              LDR      r2,|L20.56|
00000e  3a38              SUBS     r2,r2,#0x38
000010  6812              LDR      r2,[r2,#0]
000012  0c84              LSRS     r4,r0,#18
000014  fa20f404          LSR      r4,r0,r4
000018  4002              ANDS     r2,r2,r0
00001a  ea0333d4          AND      r3,r3,r4,LSR #15
00001e  431a              ORRS     r2,r2,r3
;;;2509     
;;;2510     /* Get the Interrupt pending bit */
;;;2511     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000020  4b06              LDR      r3,|L20.60|
000022  681b              LDR      r3,[r3,#0]
000024  ea031010          AND      r0,r3,r0,LSR #4
000028  d003              BEQ      |L20.50|
;;;2512     
;;;2513     /* Get the status of the Interrupt */
;;;2514     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
00002a  0400              LSLS     r0,r0,#16
00002c  0c00              LSRS     r0,r0,#16
00002e  d000              BEQ      |L20.50|
;;;2515     {
;;;2516       bitstatus = SET;
000030  2101              MOVS     r1,#1
                  |L20.50|
;;;2517     }
;;;2518     else
;;;2519     {
;;;2520       bitstatus = RESET;
;;;2521     }
;;;2522     return bitstatus;
000032  4608              MOV      r0,r1
;;;2523   }
000034  bd10              POP      {r4,pc}
;;;2524   
                          ENDP

000036  0000              DCW      0x0000
                  |L20.56|
                          DCD      0x40002840
                  |L20.60|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1617     */
;;;1618   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L21.12|
;;;1619   {
;;;1620     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1621   }
000008  4770              BX       lr
;;;1622   
                          ENDP

00000a  0000              DCW      0x0000
                  |L21.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;881      */
;;;882    uint32_t RTC_GetSubSecond(void)
000000  4802              LDR      r0,|L22.12|
;;;883    {
;;;884      uint32_t tmpreg = 0;
;;;885      
;;;886      /* Get subseconds values from the correspondent registers*/
;;;887      tmpreg = (uint32_t)(RTC->SSR);
000002  6800              LDR      r0,[r0,#0]
;;;888      
;;;889      /* Read DR register to unfroze calendar registers */
;;;890      (void) (RTC->DR);
000004  4901              LDR      r1,|L22.12|
000006  3924              SUBS     r1,r1,#0x24
000008  6809              LDR      r1,[r1,#0]
;;;891      
;;;892      return (tmpreg);
;;;893    }
00000a  4770              BX       lr
;;;894    
                          ENDP

                  |L22.12|
                          DCD      0x40002828

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;848      */
;;;849    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b510              PUSH     {r4,lr}
;;;850    {
000002  460c              MOV      r4,r1
;;;851      uint32_t tmpreg = 0;
;;;852    
;;;853      /* Check the parameters */
;;;854      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;855    
;;;856      /* Get the RTC_TR register */
;;;857      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000004  490f              LDR      r1,|L23.68|
000006  6809              LDR      r1,[r1,#0]
000008  4a0f              LDR      r2,|L23.72|
00000a  4011              ANDS     r1,r1,r2
;;;858      
;;;859      /* Fill the structure fields with the read parameters */
;;;860      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00000c  f3c14205          UBFX     r2,r1,#16,#6
000010  7022              STRB     r2,[r4,#0]
;;;861      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000012  f3c12306          UBFX     r3,r1,#8,#7
000016  7063              STRB     r3,[r4,#1]
;;;862      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000018  f001037f          AND      r3,r1,#0x7f
00001c  70a3              STRB     r3,[r4,#2]
;;;863      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
00001e  2340              MOVS     r3,#0x40
000020  ea034111          AND      r1,r3,r1,LSR #16
000024  70e1              STRB     r1,[r4,#3]
000026  2800              CMP      r0,#0                 ;850
000028  d10b              BNE      |L23.66|
00002a  4610              MOV      r0,r2                 ;850
;;;864    
;;;865      /* Check the input parameters format */
;;;866      if (RTC_Format == RTC_Format_BIN)
;;;867      {
;;;868        /* Convert the structure parameters to Binary format */
;;;869        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002c  f7fffffe          BL       RTC_Bcd2ToByte
000030  7020              STRB     r0,[r4,#0]
;;;870        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000032  7860              LDRB     r0,[r4,#1]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  7060              STRB     r0,[r4,#1]
;;;871        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  70a0              STRB     r0,[r4,#2]
                  |L23.66|
;;;872      }
;;;873    }
000042  bd10              POP      {r4,pc}
;;;874    
                          ENDP

                  |L23.68|
                          DCD      0x40002800
                  |L23.72|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;1886     */
;;;1887   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  b570              PUSH     {r4-r6,lr}
;;;1888                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;1889   {
000002  460d              MOV      r5,r1
;;;1890     uint32_t tmptime = 0, tmpdate = 0;
;;;1891   
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1894   
;;;1895     /* Get the TimeStamp time and date registers values */
;;;1896     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000004  491e              LDR      r1,|L24.128|
000006  4614              MOV      r4,r2                 ;1889
000008  6809              LDR      r1,[r1,#0]
00000a  4a1e              LDR      r2,|L24.132|
00000c  4011              ANDS     r1,r1,r2
;;;1897     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
00000e  4a1c              LDR      r2,|L24.128|
000010  1d12              ADDS     r2,r2,#4
000012  6812              LDR      r2,[r2,#0]
000014  f64f733f          MOV      r3,#0xff3f
000018  401a              ANDS     r2,r2,r3
;;;1898   
;;;1899     /* Fill the Time structure fields with the read parameters */
;;;1900     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00001a  f3c14305          UBFX     r3,r1,#16,#6
00001e  702b              STRB     r3,[r5,#0]
;;;1901     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000020  f3c12306          UBFX     r3,r1,#8,#7
000024  706b              STRB     r3,[r5,#1]
;;;1902     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000026  f001037f          AND      r3,r1,#0x7f
00002a  70ab              STRB     r3,[r5,#2]
;;;1903     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
00002c  2340              MOVS     r3,#0x40
00002e  ea034111          AND      r1,r3,r1,LSR #16
000032  70e9              STRB     r1,[r5,#3]
;;;1904   
;;;1905     /* Fill the Date structure fields with the read parameters */
;;;1906     RTC_StampDateStruct->RTC_Year = 0;
000034  2100              MOVS     r1,#0
000036  70e1              STRB     r1,[r4,#3]
;;;1907     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000038  f3c22104          UBFX     r1,r2,#8,#5
00003c  7061              STRB     r1,[r4,#1]
;;;1908     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00003e  f002013f          AND      r1,r2,#0x3f
000042  70a1              STRB     r1,[r4,#2]
;;;1909     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000044  f3c23142          UBFX     r1,r2,#13,#3
000048  7021              STRB     r1,[r4,#0]
00004a  2800              CMP      r0,#0                 ;1889
00004c  d117              BNE      |L24.126|
;;;1910   
;;;1911     /* Check the input parameters format */
;;;1912     if (RTC_Format == RTC_Format_BIN)
;;;1913     {
;;;1914       /* Convert the Time structure parameters to Binary format */
;;;1915       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
00004e  7828              LDRB     r0,[r5,#0]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  7028              STRB     r0,[r5,#0]
;;;1916       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000056  7868              LDRB     r0,[r5,#1]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7068              STRB     r0,[r5,#1]
;;;1917       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
00005e  78a8              LDRB     r0,[r5,#2]
000060  f7fffffe          BL       RTC_Bcd2ToByte
000064  70a8              STRB     r0,[r5,#2]
;;;1918   
;;;1919       /* Convert the Date structure parameters to Binary format */
;;;1920       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000066  7860              LDRB     r0,[r4,#1]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7060              STRB     r0,[r4,#1]
;;;1921       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00006e  78a0              LDRB     r0,[r4,#2]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  70a0              STRB     r0,[r4,#2]
;;;1922       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000076  7820              LDRB     r0,[r4,#0]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  7020              STRB     r0,[r4,#0]
                  |L24.126|
;;;1923     }
;;;1924   }
00007e  bd70              POP      {r4-r6,pc}
;;;1925   
                          ENDP

                  |L24.128|
                          DCD      0x40002830
                  |L24.132|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;1930     */
;;;1931   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L25.8|
;;;1932   {
;;;1933     /* Get timestamp subseconds values from the correspondent registers */
;;;1934     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;1935   }
000004  4770              BX       lr
;;;1936   
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1502     */
;;;1503   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L26.8|
;;;1504   {
;;;1505     /* Get the counter value */
;;;1506     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1507   }
000006  4770              BX       lr
;;;1508   
                          ENDP

                  |L26.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2385     */
;;;2386   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;2387   {
;;;2388     /* Check the parameters */
;;;2389     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2390     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2391   
;;;2392     /* Disable the write protection for RTC registers */
;;;2393     RTC->WPR = 0xCA;
000002  4d0e              LDR      r5,|L27.60|
000004  22ca              MOVS     r2,#0xca
000006  602a              STR      r2,[r5,#0]
;;;2394     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  602a              STR      r2,[r5,#0]
;;;2395   
;;;2396     if (NewState != DISABLE)
;;;2397     {
;;;2398       /* Configure the Interrupts in the RTC_CR register */
;;;2399       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4b0b              LDR      r3,|L27.60|
;;;2400       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2401       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00000e  4a0b              LDR      r2,|L27.60|
000010  3b1c              SUBS     r3,r3,#0x1c           ;2399
000012  321c              ADDS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;2396
000016  f0200404          BIC      r4,r0,#4              ;2399
;;;2402     }
;;;2403     else
;;;2404     {
;;;2405       /* Configure the Interrupts in the RTC_CR register */
;;;2406       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
00001a  6819              LDR      r1,[r3,#0]
00001c  f0000004          AND      r0,r0,#4              ;2401
000020  d004              BEQ      |L27.44|
000022  4321              ORRS     r1,r1,r4              ;2399
000024  6019              STR      r1,[r3,#0]            ;2399
000026  6811              LDR      r1,[r2,#0]            ;2401
000028  4301              ORRS     r1,r1,r0              ;2401
00002a  e003              B        |L27.52|
                  |L27.44|
00002c  43a1              BICS     r1,r1,r4
00002e  6019              STR      r1,[r3,#0]
;;;2407       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2408       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000030  6811              LDR      r1,[r2,#0]
000032  4381              BICS     r1,r1,r0
                  |L27.52|
000034  6011              STR      r1,[r2,#0]
;;;2409     }
;;;2410     /* Enable the write protection for RTC registers */
;;;2411     RTC->WPR = 0xFF; 
000036  20ff              MOVS     r0,#0xff
000038  6028              STR      r0,[r5,#0]
;;;2412   }
00003a  bd30              POP      {r4,r5,pc}
;;;2413   
                          ENDP

                  |L27.60|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;410      */
;;;411    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;412    {
;;;413      ErrorStatus status = ERROR;
;;;414      
;;;415      /* Check the parameters */
;;;416      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;417      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;418      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;419    
;;;420      /* Disable the write protection for RTC registers */
;;;421      RTC->WPR = 0xCA;
000002  4d12              LDR      r5,|L28.76|
000004  4604              MOV      r4,r0                 ;412
000006  2600              MOVS     r6,#0                 ;413
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;422      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;423    
;;;424      /* Set Initialization mode */
;;;425      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b1a8              CBZ      r0,|L28.66|
;;;426      {
;;;427        status = ERROR;
;;;428      } 
;;;429      else
;;;430      {
;;;431        /* Clear RTC CR FMT Bit */
;;;432        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000016  480d              LDR      r0,|L28.76|
000018  381c              SUBS     r0,r0,#0x1c
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210140          BIC      r1,r1,#0x40
000020  6001              STR      r1,[r0,#0]
;;;433        /* Set RTC_CR register */
;;;434        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000022  6801              LDR      r1,[r0,#0]
000024  6822              LDR      r2,[r4,#0]
000026  4311              ORRS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;435      
;;;436        /* Configure the RTC PRER */
;;;437        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
00002a  4808              LDR      r0,|L28.76|
00002c  68a1              LDR      r1,[r4,#8]
00002e  3814              SUBS     r0,r0,#0x14
000030  6001              STR      r1,[r0,#0]
;;;438        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000032  6801              LDR      r1,[r0,#0]
000034  88a2              LDRH     r2,[r4,#4]
000036  ea414102          ORR      r1,r1,r2,LSL #16
00003a  6001              STR      r1,[r0,#0]
;;;439    
;;;440        /* Exit Initialization mode */
;;;441        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;442    
;;;443        status = SUCCESS;    
000040  2601              MOVS     r6,#1
                  |L28.66|
;;;444      }
;;;445      /* Enable the write protection for RTC registers */
;;;446      RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  6028              STR      r0,[r5,#0]
;;;447      
;;;448      return status;
000046  4630              MOV      r0,r6
;;;449    }
000048  bd70              POP      {r4-r6,pc}
;;;450    
                          ENDP

00004a  0000              DCW      0x0000
                  |L28.76|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1655     */
;;;1656   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  4b09              LDR      r3,|L29.40|
;;;1657   {
000002  b510              PUSH     {r4,lr}
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1660     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1661   
;;;1662     /* Disable the write protection for RTC registers */
;;;1663     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1664     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1665   
;;;1666     /* Clear the bits to be configured */
;;;1667     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000c  4a06              LDR      r2,|L29.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f42404e0          BIC      r4,r4,#0x700000
000016  6014              STR      r4,[r2,#0]
;;;1668   
;;;1669     /* Configure the output selection and polarity */
;;;1670     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1671   
;;;1672     /* Enable the write protection for RTC registers */
;;;1673     RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1674   }
000024  bd10              POP      {r4,pc}
;;;1675   
                          ENDP

000026  0000              DCW      0x0000
                  |L29.40|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2231     */
;;;2232   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4904              LDR      r1,|L30.20|
;;;2233   {
;;;2234     /* Check the parameters */
;;;2235     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2236     
;;;2237     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  680a              LDR      r2,[r1,#0]
000004  f4222280          BIC      r2,r2,#0x40000
000008  600a              STR      r2,[r1,#0]
;;;2238     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2239   }
000010  4770              BX       lr
;;;2240   
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2191     */
;;;2192   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b508              PUSH     {r3,lr}
;;;2193   {
;;;2194     __IO uint32_t tmp = 0;
;;;2195     
;;;2196     /* Check the parameters */
;;;2197     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2198   
;;;2199     tmp = RTC_BASE + 0x50;
000002  4903              LDR      r1,|L31.16|
;;;2200     tmp += (RTC_BKP_DR * 4);
000004  eb010080          ADD      r0,r1,r0,LSL #2
;;;2201     
;;;2202     /* Read the specified register */
;;;2203     return (*(__IO uint32_t *)tmp);
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
;;;2204   }
00000c  bd08              POP      {r3,pc}
;;;2205   
                          ENDP

00000e  0000              DCW      0x0000
                  |L31.16|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;623      */
;;;624    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;625    {
;;;626      ErrorStatus status = ERROR;
;;;627    
;;;628      /* Check the parameters */
;;;629      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;630    
;;;631      /* Disable the write protection for RTC registers */
;;;632      RTC->WPR = 0xCA;
000002  4c0d              LDR      r4,|L32.56|
000004  4606              MOV      r6,r0                 ;625
000006  2500              MOVS     r5,#0                 ;626
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;633      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;634    
;;;635      /* Set Initialization mode */
;;;636      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L32.48|
;;;637      {
;;;638        status = ERROR;
;;;639      }
;;;640      else
;;;641      {
;;;642        if (NewState != DISABLE)
;;;643        {
;;;644          /* Enable the RTC reference clock detection */
;;;645          RTC->CR |= RTC_CR_REFCKON;   
000016  4808              LDR      r0,|L32.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;646        }
;;;647        else
;;;648        {
;;;649          /* Disable the RTC reference clock detection */
;;;650          RTC->CR &= ~RTC_CR_REFCKON;    
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L32.36|
00001e  f0410110          ORR      r1,r1,#0x10           ;645
000022  e001              B        |L32.40|
                  |L32.36|
000024  f0210110          BIC      r1,r1,#0x10
                  |L32.40|
000028  6001              STR      r1,[r0,#0]
;;;651        }
;;;652        /* Exit Initialization mode */
;;;653        RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;654    
;;;655        status = SUCCESS;
00002e  2501              MOVS     r5,#1
                  |L32.48|
;;;656      }
;;;657    
;;;658      /* Enable the write protection for RTC registers */
;;;659      RTC->WPR = 0xFF;
000030  20ff              MOVS     r0,#0xff
000032  6020              STR      r0,[r4,#0]
;;;660    
;;;661      return status;
000034  4628              MOV      r0,r5
;;;662    }
000036  bd70              POP      {r4-r6,pc}
;;;663    
                          ENDP

                  |L32.56|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1076     */
;;;1077   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1078   {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;1079     uint32_t tmpreg = 0;
;;;1080     
;;;1081     /* Check the parameters */
;;;1082     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1083     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1084     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1085     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1086   
;;;1087     if (RTC_Format == RTC_Format_BIN)
;;;1088     {
;;;1089       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4a26              LDR      r2,|L33.160|
000008  2100              MOVS     r1,#0                 ;1078
00000a  2800              CMP      r0,#0                 ;1087
;;;1090       {
;;;1091         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1092         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1093       } 
;;;1094       else
;;;1095       {
;;;1096         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1097         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1098       }
;;;1099       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1100       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1101       
;;;1102       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1103       {
;;;1104         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1105       }
;;;1106       else
;;;1107       {
;;;1108         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1109       }
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000c  6810              LDR      r0,[r2,#0]
00000e  ea4f6040          LSL      r0,r0,#25
000012  d005              BEQ      |L33.32|
000014  2800              CMP      r0,#0
000016  da1c              BGE      |L33.82|
;;;1114       {
;;;1115         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000018  7820              LDRB     r0,[r4,#0]
00001a  f7fffffe          BL       RTC_Bcd2ToByte
;;;1116         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1117         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00001e  e019              B        |L33.84|
                  |L33.32|
000020  2800              CMP      r0,#0                 ;1089
000022  db00              BLT      |L33.38|
000024  70e1              STRB     r1,[r4,#3]            ;1096
                  |L33.38|
;;;1118       } 
;;;1119       else
;;;1120       {
;;;1121         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1122         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1123       }
;;;1124       
;;;1125       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1126       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1127       
;;;1128       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1129       {
;;;1130         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1131         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1136         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1137       }    
;;;1138     }
;;;1139   
;;;1140     /* Check the input parameters format */
;;;1141     if (RTC_Format != RTC_Format_BIN)
;;;1142     {
;;;1143       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
;;;1144                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1145                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1146                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1147                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1148                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1149                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1150     }  
;;;1151     else
;;;1152     {
;;;1153       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000026  7820              LDRB     r0,[r4,#0]
000028  f7fffffe          BL       RTC_ByteToBcd2
00002c  0406              LSLS     r6,r0,#16
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_ByteToBcd2
000034  ea462600          ORR      r6,r6,r0,LSL #8
000038  78a0              LDRB     r0,[r4,#2]
00003a  f7fffffe          BL       RTC_ByteToBcd2
00003e  4306              ORRS     r6,r6,r0
000040  78e0              LDRB     r0,[r4,#3]
000042  ea464600          ORR      r6,r6,r0,LSL #16
000046  7b20              LDRB     r0,[r4,#0xc]
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  ea466000          ORR      r0,r6,r0,LSL #24
000050  e010              B        |L33.116|
                  |L33.82|
000052  70e1              STRB     r1,[r4,#3]            ;1121
                  |L33.84|
000054  7b20              LDRB     r0,[r4,#0xc]          ;1130
000056  f7fffffe          BL       RTC_Bcd2ToByte
00005a  78a0              LDRB     r0,[r4,#2]            ;1143
00005c  7821              LDRB     r1,[r4,#0]            ;1143
00005e  78e2              LDRB     r2,[r4,#3]            ;1143
000060  ea404001          ORR      r0,r0,r1,LSL #16      ;1143
000064  7861              LDRB     r1,[r4,#1]            ;1143
000066  0209              LSLS     r1,r1,#8              ;1143
000068  ea414102          ORR      r1,r1,r2,LSL #16      ;1143
00006c  4308              ORRS     r0,r0,r1              ;1143
00006e  7b21              LDRB     r1,[r4,#0xc]          ;1143
000070  ea406001          ORR      r0,r0,r1,LSL #24      ;1143
                  |L33.116|
000074  68a1              LDR      r1,[r4,#8]
;;;1154                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1155                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1156                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1157                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1158                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1159                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1160     } 
;;;1161   
;;;1162     /* Disable the write protection for RTC registers */
;;;1163     RTC->WPR = 0xCA;
000076  4a0a              LDR      r2,|L33.160|
000078  4308              ORRS     r0,r0,r1              ;1153
00007a  6861              LDR      r1,[r4,#4]            ;1153
00007c  4308              ORRS     r0,r0,r1              ;1153
00007e  21ca              MOVS     r1,#0xca
000080  321c              ADDS     r2,r2,#0x1c
000082  6011              STR      r1,[r2,#0]
;;;1164     RTC->WPR = 0x53;
000084  2153              MOVS     r1,#0x53
000086  6011              STR      r1,[r2,#0]
;;;1165   
;;;1166     /* Configure the Alarm register */
;;;1167     if (RTC_Alarm == RTC_Alarm_A)
000088  f5b57f80          CMP      r5,#0x100
00008c  d004              BEQ      |L33.152|
;;;1168     {
;;;1169       RTC->ALRMAR = (uint32_t)tmpreg;
;;;1170     }
;;;1171     else
;;;1172     {
;;;1173       RTC->ALRMBR = (uint32_t)tmpreg;
00008e  1f11              SUBS     r1,r2,#4
                  |L33.144|
000090  6008              STR      r0,[r1,#0]
;;;1174     }
;;;1175   
;;;1176     /* Enable the write protection for RTC registers */
;;;1177     RTC->WPR = 0xFF;   
000092  20ff              MOVS     r0,#0xff
000094  6010              STR      r0,[r2,#0]
;;;1178   }
000096  bd70              POP      {r4-r6,pc}
                  |L33.152|
000098  4901              LDR      r1,|L33.160|
00009a  3114              ADDS     r1,r1,#0x14           ;1169
00009c  e7f8              B        |L33.144|
;;;1179   
                          ENDP

00009e  0000              DCW      0x0000
                  |L33.160|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;906      */
;;;907    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;908    {
000002  460c              MOV      r4,r1
000004  0001              MOVS     r1,r0
;;;909      uint32_t tmpreg = 0;
;;;910      ErrorStatus status = ERROR;
;;;911      
;;;912      /* Check the parameters */
;;;913      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;914    
;;;915      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
000006  7860              LDRB     r0,[r4,#1]
000008  f04f0600          MOV      r6,#0                 ;910
00000c  d02a              BEQ      |L34.100|
;;;916      {
;;;917        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;918      }  
;;;919      if (RTC_Format == RTC_Format_BIN)
;;;920      {
;;;921        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;922        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;923        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;924      }
;;;925      else
;;;926      {
;;;927        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;928        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00000e  f7fffffe          BL       RTC_Bcd2ToByte
;;;929        assert_param(IS_RTC_MONTH(tmpreg));
;;;930        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000012  78a0              LDRB     r0,[r4,#2]
000014  f7fffffe          BL       RTC_Bcd2ToByte
;;;931        assert_param(IS_RTC_DATE(tmpreg));
;;;932      }
;;;933      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;934    
;;;935      /* Check the input parameters format */
;;;936      if (RTC_Format != RTC_Format_BIN)
;;;937      {
;;;938        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000018  78a0              LDRB     r0,[r4,#2]
00001a  78e1              LDRB     r1,[r4,#3]
00001c  ea404501          ORR      r5,r0,r1,LSL #16
000020  7860              LDRB     r0,[r4,#1]
000022  7821              LDRB     r1,[r4,#0]
000024  0200              LSLS     r0,r0,#8
000026  ea403041          ORR      r0,r0,r1,LSL #13
00002a  4305              ORRS     r5,r5,r0
                  |L34.44|
;;;939                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;940                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;941                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;942      }  
;;;943      else
;;;944      {
;;;945        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
;;;946                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;947                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;948                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;949      }
;;;950    
;;;951      /* Disable the write protection for RTC registers */
;;;952      RTC->WPR = 0xCA;
00002c  4c19              LDR      r4,|L34.148|
00002e  20ca              MOVS     r0,#0xca
000030  6020              STR      r0,[r4,#0]
;;;953      RTC->WPR = 0x53;
000032  2053              MOVS     r0,#0x53
000034  6020              STR      r0,[r4,#0]
;;;954    
;;;955      /* Set Initialization mode */
;;;956      if (RTC_EnterInitMode() == ERROR)
000036  f7fffffe          BL       RTC_EnterInitMode
00003a  b178              CBZ      r0,|L34.92|
;;;957      {
;;;958        status = ERROR;
;;;959      } 
;;;960      else
;;;961      {
;;;962        /* Set the RTC_DR register */
;;;963        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00003c  4816              LDR      r0,|L34.152|
00003e  4005              ANDS     r5,r5,r0
000040  4814              LDR      r0,|L34.148|
000042  3820              SUBS     r0,r0,#0x20
000044  6005              STR      r5,[r0,#0]
;;;964    
;;;965        /* Exit Initialization mode */
;;;966        RTC_ExitInitMode(); 
000046  f7fffffe          BL       RTC_ExitInitMode
;;;967    
;;;968        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;969        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
00004a  4812              LDR      r0,|L34.148|
00004c  381c              SUBS     r0,r0,#0x1c
00004e  6800              LDR      r0,[r0,#0]
000050  0680              LSLS     r0,r0,#26
000052  d402              BMI      |L34.90|
;;;970        {
;;;971          if (RTC_WaitForSynchro() == ERROR)
000054  f7fffffe          BL       RTC_WaitForSynchro
000058  b100              CBZ      r0,|L34.92|
                  |L34.90|
;;;972          {
;;;973            status = ERROR;
;;;974          }
;;;975          else
;;;976          {
;;;977            status = SUCCESS;
;;;978          }
;;;979        }
;;;980        else
;;;981        {
;;;982          status = SUCCESS;
00005a  2601              MOVS     r6,#1
                  |L34.92|
;;;983        }
;;;984      }
;;;985      /* Enable the write protection for RTC registers */
;;;986      RTC->WPR = 0xFF;
00005c  20ff              MOVS     r0,#0xff
00005e  6020              STR      r0,[r4,#0]
;;;987      
;;;988      return status;
000060  4630              MOV      r0,r6
;;;989    }
000062  bd70              POP      {r4-r6,pc}
                  |L34.100|
000064  06c1              LSLS     r1,r0,#27             ;915
000066  d503              BPL      |L34.112|
000068  f0200010          BIC      r0,r0,#0x10           ;917
00006c  300a              ADDS     r0,r0,#0xa            ;917
00006e  7060              STRB     r0,[r4,#1]            ;917
                  |L34.112|
000070  78e0              LDRB     r0,[r4,#3]            ;945
000072  f7fffffe          BL       RTC_ByteToBcd2
000076  0405              LSLS     r5,r0,#16             ;945
000078  7860              LDRB     r0,[r4,#1]            ;945
00007a  f7fffffe          BL       RTC_ByteToBcd2
00007e  ea452500          ORR      r5,r5,r0,LSL #8       ;945
000082  78a0              LDRB     r0,[r4,#2]            ;945
000084  f7fffffe          BL       RTC_ByteToBcd2
000088  4305              ORRS     r5,r5,r0              ;945
00008a  7820              LDRB     r0,[r4,#0]            ;945
00008c  ea453540          ORR      r5,r5,r0,LSL #13      ;945
000090  e7cc              B        |L34.44|
;;;990    
                          ENDP

000092  0000              DCW      0x0000
                  |L34.148|
                          DCD      0x40002824
                  |L34.152|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;725      */
;;;726    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;727    {
;;;728      uint32_t tmpreg = 0;
;;;729      ErrorStatus status = ERROR;
;;;730        
;;;731      /* Check the parameters */
;;;732      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;733      
;;;734      if (RTC_Format == RTC_Format_BIN)
;;;735      {
;;;736        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000004  4f24              LDR      r7,|L35.152|
000006  460c              MOV      r4,r1                 ;727
000008  0002              MOVS     r2,r0                 ;727
00000a  f04f0600          MOV      r6,#0                 ;729
;;;737        {
;;;738          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;739          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;740        } 
;;;741        else
;;;742        {
;;;743          RTC_TimeStruct->RTC_H12 = 0x00;
;;;744          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;745        }
;;;746        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;747        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;748      }
;;;749      else
;;;750      {
;;;751        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;752        {
;;;753          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00000e  7820              LDRB     r0,[r4,#0]
000010  683a              LDR      r2,[r7,#0]            ;751
000012  4631              MOV      r1,r6                 ;729
000014  ea4f6242          LSL      r2,r2,#25             ;751
000018  d004              BEQ      |L35.36|
00001a  2a00              CMP      r2,#0                 ;751
00001c  da15              BGE      |L35.74|
00001e  f7fffffe          BL       RTC_Bcd2ToByte
;;;754          assert_param(IS_RTC_HOUR12(tmpreg));
;;;755          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
000022  e013              B        |L35.76|
                  |L35.36|
000024  2a00              CMP      r2,#0                 ;736
000026  db00              BLT      |L35.42|
000028  70e1              STRB     r1,[r4,#3]            ;743
                  |L35.42|
;;;756        } 
;;;757        else
;;;758        {
;;;759          RTC_TimeStruct->RTC_H12 = 0x00;
;;;760          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;761        }
;;;762        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;763        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;764      }
;;;765      
;;;766      /* Check the input parameters format */
;;;767      if (RTC_Format != RTC_Format_BIN)
;;;768      {
;;;769        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;770                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;771                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;772                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;773      }  
;;;774      else
;;;775      {
;;;776        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
00002a  f7fffffe          BL       RTC_ByteToBcd2
00002e  0405              LSLS     r5,r0,#16
000030  7860              LDRB     r0,[r4,#1]
000032  f7fffffe          BL       RTC_ByteToBcd2
000036  ea452500          ORR      r5,r5,r0,LSL #8
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_ByteToBcd2
000040  4305              ORRS     r5,r5,r0
000042  78e0              LDRB     r0,[r4,#3]
000044  ea454500          ORR      r5,r5,r0,LSL #16
000048  e00a              B        |L35.96|
                  |L35.74|
00004a  70e1              STRB     r1,[r4,#3]            ;759
                  |L35.76|
00004c  78a0              LDRB     r0,[r4,#2]            ;769
00004e  7821              LDRB     r1,[r4,#0]            ;769
000050  ea404501          ORR      r5,r0,r1,LSL #16      ;769
000054  7860              LDRB     r0,[r4,#1]            ;769
000056  78e1              LDRB     r1,[r4,#3]            ;769
000058  0200              LSLS     r0,r0,#8              ;769
00005a  ea404001          ORR      r0,r0,r1,LSL #16      ;769
00005e  4305              ORRS     r5,r5,r0              ;769
                  |L35.96|
;;;777                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;778                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;779                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;780      }  
;;;781    
;;;782      /* Disable the write protection for RTC registers */
;;;783      RTC->WPR = 0xCA;
000060  4c0d              LDR      r4,|L35.152|
000062  20ca              MOVS     r0,#0xca
000064  341c              ADDS     r4,r4,#0x1c
000066  6020              STR      r0,[r4,#0]
;;;784      RTC->WPR = 0x53;
000068  2053              MOVS     r0,#0x53
00006a  6020              STR      r0,[r4,#0]
;;;785    
;;;786      /* Set Initialization mode */
;;;787      if (RTC_EnterInitMode() == ERROR)
00006c  f7fffffe          BL       RTC_EnterInitMode
000070  b168              CBZ      r0,|L35.142|
;;;788      {
;;;789        status = ERROR;
;;;790      } 
;;;791      else
;;;792      {
;;;793        /* Set the RTC_TR register */
;;;794        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000072  480a              LDR      r0,|L35.156|
000074  4005              ANDS     r5,r5,r0
000076  4808              LDR      r0,|L35.152|
000078  3808              SUBS     r0,r0,#8
00007a  6005              STR      r5,[r0,#0]
;;;795    
;;;796        /* Exit Initialization mode */
;;;797        RTC_ExitInitMode(); 
00007c  f7fffffe          BL       RTC_ExitInitMode
;;;798    
;;;799        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;800        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000080  6838              LDR      r0,[r7,#0]
000082  0680              LSLS     r0,r0,#26
000084  d402              BMI      |L35.140|
;;;801        {
;;;802          if (RTC_WaitForSynchro() == ERROR)
000086  f7fffffe          BL       RTC_WaitForSynchro
00008a  b100              CBZ      r0,|L35.142|
                  |L35.140|
;;;803          {
;;;804            status = ERROR;
;;;805          }
;;;806          else
;;;807          {
;;;808            status = SUCCESS;
;;;809          }
;;;810        }
;;;811        else
;;;812        {
;;;813          status = SUCCESS;
00008c  2601              MOVS     r6,#1
                  |L35.142|
;;;814        }
;;;815      
;;;816      }
;;;817      /* Enable the write protection for RTC registers */
;;;818      RTC->WPR = 0xFF;
00008e  20ff              MOVS     r0,#0xff
000090  6020              STR      r0,[r4,#0]
;;;819        
;;;820      return status;
000092  4630              MOV      r0,r6
;;;821    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;822    
                          ENDP

                  |L35.152|
                          DCD      0x40002808
                  |L35.156|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1481     */
;;;1482   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  4905              LDR      r1,|L36.24|
;;;1483   {
;;;1484     /* Check the parameters */
;;;1485     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1486     
;;;1487     /* Disable the write protection for RTC registers */
;;;1488     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  600a              STR      r2,[r1,#0]
;;;1489     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  600a              STR      r2,[r1,#0]
;;;1490     
;;;1491     /* Configure the Wakeup Timer counter */
;;;1492     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4a03              LDR      r2,|L36.24|
00000c  3a10              SUBS     r2,r2,#0x10
00000e  6010              STR      r0,[r2,#0]
;;;1493     
;;;1494     /* Enable the write protection for RTC registers */
;;;1495     RTC->WPR = 0xFF;
000010  20ff              MOVS     r0,#0xff
000012  6008              STR      r0,[r1,#0]
;;;1496   }
000014  4770              BX       lr
;;;1497   
                          ENDP

000016  0000              DCW      0x0000
                  |L36.24|
                          DCD      0x40002824

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1766   */
;;;1767   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1768                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1769                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1770   {
;;;1771     ErrorStatus status = ERROR;
;;;1772     uint32_t recalpfcount = 0;
;;;1773   
;;;1774     /* Check the parameters */
;;;1775     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1776     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1777     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1778   
;;;1779     /* Disable the write protection for RTC registers */
;;;1780     RTC->WPR = 0xCA;
000002  4b10              LDR      r3,|L37.68|
000004  2400              MOVS     r4,#0                 ;1772
000006  25ca              MOVS     r5,#0xca
000008  601d              STR      r5,[r3,#0]
;;;1781     RTC->WPR = 0x53;
00000a  2553              MOVS     r5,#0x53
00000c  601d              STR      r5,[r3,#0]
;;;1782     
;;;1783     /* check if a calibration is pending*/
;;;1784     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
00000e  4d0d              LDR      r5,|L37.68|
000010  3d18              SUBS     r5,r5,#0x18
000012  682e              LDR      r6,[r5,#0]
000014  03f6              LSLS     r6,r6,#15
000016  d507              BPL      |L37.40|
;;;1785     {
;;;1786       /* wait until the Calibration is completed*/
;;;1787       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000018  149e              ASRS     r6,r3,#18
                  |L37.26|
00001a  682f              LDR      r7,[r5,#0]
00001c  03ff              LSLS     r7,r7,#15
00001e  d503              BPL      |L37.40|
000020  42b4              CMP      r4,r6
000022  d001              BEQ      |L37.40|
000024  1c64              ADDS     r4,r4,#1
;;;1788       {
;;;1789         recalpfcount++;
000026  e7f8              B        |L37.26|
                  |L37.40|
;;;1790       }
;;;1791     }
;;;1792   
;;;1793     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1794     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000028  682c              LDR      r4,[r5,#0]
00002a  03e4              LSLS     r4,r4,#15
00002c  d406              BMI      |L37.60|
;;;1795     {
;;;1796       /* Configure the Smooth calibration settings */
;;;1797       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
00002e  4308              ORRS     r0,r0,r1
000030  4904              LDR      r1,|L37.68|
000032  4310              ORRS     r0,r0,r2
000034  3118              ADDS     r1,r1,#0x18
000036  6008              STR      r0,[r1,#0]
;;;1798   
;;;1799       status = SUCCESS;
000038  2001              MOVS     r0,#1
00003a  e000              B        |L37.62|
                  |L37.60|
;;;1800     }
;;;1801     else
;;;1802     {
;;;1803       status = ERROR;
00003c  2000              MOVS     r0,#0
                  |L37.62|
;;;1804     }
;;;1805   
;;;1806     /* Enable the write protection for RTC registers */
;;;1807     RTC->WPR = 0xFF;
00003e  21ff              MOVS     r1,#0xff
000040  6019              STR      r1,[r3,#0]
;;;1808     
;;;1809     return (ErrorStatus)(status);
;;;1810   }
000042  bdf0              POP      {r4-r7,pc}
;;;1811   
                          ENDP

                  |L37.68|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;456      */
;;;457    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;458    {
;;;459      /* Initialize the RTC_HourFormat member */
;;;460      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;461        
;;;462      /* Initialize the RTC_AsynchPrediv member */
;;;463      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000002  6001              STR      r1,[r0,#0]
000004  217f              MOVS     r1,#0x7f
;;;464    
;;;465      /* Initialize the RTC_SynchPrediv member */
;;;466      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000006  6041              STR      r1,[r0,#4]
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;467    }
00000c  4770              BX       lr
;;;468    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2269   */
;;;2270   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b570              PUSH     {r4-r6,lr}
;;;2271   {
;;;2272     ErrorStatus status = ERROR;
;;;2273     uint32_t shpfcount = 0;
;;;2274   
;;;2275     /* Check the parameters */
;;;2276     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2277     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2278   
;;;2279     /* Disable the write protection for RTC registers */
;;;2280     RTC->WPR = 0xCA;
000002  4c14              LDR      r4,|L39.84|
000004  2200              MOVS     r2,#0                 ;2273
000006  23ca              MOVS     r3,#0xca
000008  6023              STR      r3,[r4,#0]
;;;2281     RTC->WPR = 0x53;
00000a  2353              MOVS     r3,#0x53
00000c  6023              STR      r3,[r4,#0]
;;;2282     
;;;2283     /* Check if a Shift is pending*/
;;;2284     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
00000e  4b11              LDR      r3,|L39.84|
000010  3b18              SUBS     r3,r3,#0x18
000012  681d              LDR      r5,[r3,#0]
000014  072d              LSLS     r5,r5,#28
000016  d507              BPL      |L39.40|
;;;2285     {
;;;2286       /* Wait until the shift is completed*/
;;;2287       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000018  145d              ASRS     r5,r3,#17
                  |L39.26|
00001a  681e              LDR      r6,[r3,#0]
00001c  0736              LSLS     r6,r6,#28
00001e  d503              BPL      |L39.40|
000020  42aa              CMP      r2,r5
000022  d001              BEQ      |L39.40|
000024  1c52              ADDS     r2,r2,#1
;;;2288       {
;;;2289         shpfcount++;
000026  e7f8              B        |L39.26|
                  |L39.40|
;;;2290       }
;;;2291     }
;;;2292   
;;;2293     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2294     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000028  681a              LDR      r2,[r3,#0]
00002a  0712              LSLS     r2,r2,#28
00002c  d40d              BMI      |L39.74|
;;;2295     {
;;;2296       /* check if the reference clock detection is disabled */
;;;2297       if((RTC->CR & RTC_CR_REFCKON) == RESET)
00002e  4a09              LDR      r2,|L39.84|
000030  3a1c              SUBS     r2,r2,#0x1c
000032  6812              LDR      r2,[r2,#0]
000034  06d2              LSLS     r2,r2,#27
000036  d408              BMI      |L39.74|
;;;2298       {
;;;2299         /* Configure the Shift settings */
;;;2300         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
000038  4301              ORRS     r1,r1,r0
00003a  4806              LDR      r0,|L39.84|
00003c  3008              ADDS     r0,r0,#8
00003e  6001              STR      r1,[r0,#0]
;;;2301       
;;;2302         if(RTC_WaitForSynchro() == ERROR)
000040  f7fffffe          BL       RTC_WaitForSynchro
000044  b110              CBZ      r0,|L39.76|
;;;2303         {
;;;2304           status = ERROR;
;;;2305         }
;;;2306         else
;;;2307         {
;;;2308           status = SUCCESS;
000046  2001              MOVS     r0,#1
000048  e000              B        |L39.76|
                  |L39.74|
;;;2309         }
;;;2310       }
;;;2311       else
;;;2312       {
;;;2313         status = ERROR;
00004a  2000              MOVS     r0,#0
                  |L39.76|
;;;2314       }
;;;2315     }
;;;2316     else
;;;2317     {
;;;2318       status = ERROR;
;;;2319     }
;;;2320   
;;;2321     /* Enable the write protection for RTC registers */
;;;2322     RTC->WPR = 0xFF;
00004c  21ff              MOVS     r1,#0xff
00004e  6021              STR      r1,[r4,#0]
;;;2323     
;;;2324     return (ErrorStatus)(status);
;;;2325   }
000050  bd70              POP      {r4-r6,pc}
;;;2326   
                          ENDP

000052  0000              DCW      0x0000
                  |L39.84|
                          DCD      0x40002824

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;1998     */
;;;1999   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  4a04              LDR      r2,|L40.20|
;;;2000   {
;;;2001     /* Check the parameters */
;;;2002     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2003     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2004     
;;;2005     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2006     {
;;;2007       /* Enable the selected Tamper pin */
;;;2008       RTC->TAFCR |= (uint32_t)RTC_Tamper;
;;;2009     }
;;;2010     else
;;;2011     {
;;;2012       /* Disable the selected Tamper pin */
;;;2013       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L40.12|
000008  4301              ORRS     r1,r1,r0              ;2008
00000a  e000              B        |L40.14|
                  |L40.12|
00000c  4381              BICS     r1,r1,r0
                  |L40.14|
00000e  6011              STR      r1,[r2,#0]            ;2008
;;;2014     }  
;;;2015   }
000010  4770              BX       lr
;;;2016   
                          ENDP

000012  0000              DCW      0x0000
                  |L40.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2029     */
;;;2030   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4904              LDR      r1,|L41.20|
;;;2031   {
;;;2032     /* Check the parameters */
;;;2033     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2034      
;;;2035     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2036     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  680a              LDR      r2,[r1,#0]
000004  f42252c0          BIC      r2,r2,#0x1800
000008  600a              STR      r2,[r1,#0]
;;;2037   
;;;2038     /* Configure the RTC_TAFCR register */
;;;2039     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2040   }
000010  4770              BX       lr
;;;2041   
                          ENDP

000012  0000              DCW      0x0000
                  |L41.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2086     */
;;;2087   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4904              LDR      r1,|L42.20|
;;;2088   {
;;;2089     /* Check the parameters */
;;;2090     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2091      
;;;2092     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2093     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  680a              LDR      r2,[r1,#0]
000004  f42242c0          BIC      r2,r2,#0x6000
000008  600a              STR      r2,[r1,#0]
;;;2094   
;;;2095     /* Configure the RTC_TAFCR register */
;;;2096     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2097   }
000010  4770              BX       lr
;;;2098   
                          ENDP

000012  0000              DCW      0x0000
                  |L42.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2129     */
;;;2130   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L43.24|
;;;2131   {
;;;2132     /* Check the parameters */
;;;2133     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2134     
;;;2135    if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2136     {
;;;2137       /* Enable precharge of the selected Tamper pin */
;;;2138       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
;;;2139     }
;;;2140     else
;;;2141     {
;;;2142       /* Disable precharge of the selected Tamper pin */
;;;2143       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L43.14|
000008  f4204000          BIC      r0,r0,#0x8000         ;2138
00000c  e001              B        |L43.18|
                  |L43.14|
00000e  f4404000          ORR      r0,r0,#0x8000
                  |L43.18|
000012  6008              STR      r0,[r1,#0]            ;2138
;;;2144     } 
;;;2145   }
000014  4770              BX       lr
;;;2146   
                          ENDP

000016  0000              DCW      0x0000
                  |L43.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2063     */
;;;2064   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4904              LDR      r1,|L44.20|
;;;2065   {
;;;2066     /* Check the parameters */
;;;2067     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2068    
;;;2069     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2070     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  680a              LDR      r2,[r1,#0]
000004  f42262e0          BIC      r2,r2,#0x700
000008  600a              STR      r2,[r1,#0]
;;;2071   
;;;2072     /* Configure the RTC_TAFCR register */
;;;2073     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2074   }
000010  4770              BX       lr
;;;2075   
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;1968     */
;;;1969   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  4a05              LDR      r2,|L45.24|
;;;1970   {
;;;1971     /* Check the parameters */
;;;1972     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;1973     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;1974    
;;;1975     /* Check if the  active level for Tamper is rising edge (Low level)*/
;;;1976     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
000002  2900              CMP      r1,#0
;;;1977     {  
;;;1978       /* Configure the RTC_TAFCR register */
;;;1979       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
;;;1980     }
;;;1981     else
;;;1982     { 
;;;1983       /* Configure the RTC_TAFCR register */
;;;1984       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000004  6811              LDR      r1,[r2,#0]
000006  d003              BEQ      |L45.16|
000008  ea410040          ORR      r0,r1,r0,LSL #1
                  |L45.12|
00000c  6010              STR      r0,[r2,#0]            ;1979
;;;1985     }  
;;;1986   }
00000e  4770              BX       lr
                  |L45.16|
000010  ea210040          BIC      r0,r1,r0,LSL #1       ;1979
000014  e7fa              B        |L45.12|
;;;1987   
                          ENDP

000016  0000              DCW      0x0000
                  |L45.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1842     */
;;;1843   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  4b0a              LDR      r3,|L46.44|
;;;1844   {
000002  b510              PUSH     {r4,lr}
;;;1845     uint32_t tmpreg = 0;
;;;1846   
;;;1847     /* Check the parameters */
;;;1848     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1849     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1850   
;;;1851     /* Get the RTC_CR register and clear the bits to be configured */
;;;1852     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000004  681a              LDR      r2,[r3,#0]
000006  f6400408          MOV      r4,#0x808
00000a  43a2              BICS     r2,r2,r4
;;;1853   
;;;1854     /* Get the new configuration */
;;;1855     if (NewState != DISABLE)
;;;1856     {
;;;1857       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1858     }
;;;1859     else
;;;1860     {
;;;1861       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00000c  ea420200          ORR      r2,r2,r0
000010  b109              CBZ      r1,|L46.22|
000012  f4426200          ORR      r2,r2,#0x800          ;1857
                  |L46.22|
;;;1862     }
;;;1863   
;;;1864     /* Disable the write protection for RTC registers */
;;;1865     RTC->WPR = 0xCA;
000016  4805              LDR      r0,|L46.44|
000018  21ca              MOVS     r1,#0xca
00001a  301c              ADDS     r0,r0,#0x1c
00001c  6001              STR      r1,[r0,#0]
;;;1866     RTC->WPR = 0x53;
00001e  2153              MOVS     r1,#0x53
000020  6001              STR      r1,[r0,#0]
;;;1867   
;;;1868     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1869     RTC->CR = (uint32_t)tmpreg;
000022  601a              STR      r2,[r3,#0]
;;;1870   
;;;1871     /* Enable the write protection for RTC registers */
;;;1872     RTC->WPR = 0xFF;
000024  21ff              MOVS     r1,#0xff
000026  6001              STR      r1,[r0,#0]
;;;1873   }
000028  bd10              POP      {r4,pc}
;;;1874   
                          ENDP

00002a  0000              DCW      0x0000
                  |L46.44|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2106     */
;;;2107   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L47.24|
;;;2108   {
;;;2109     /* Check the parameters */
;;;2110     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2111      
;;;2112     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2113     {
;;;2114       /* Save timestamp on tamper detection event */
;;;2115       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
;;;2116     }
;;;2117     else
;;;2118     {
;;;2119       /* Tamper detection does not cause a timestamp to be saved */
;;;2120       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L47.14|
000008  f0400080          ORR      r0,r0,#0x80           ;2115
00000c  e001              B        |L47.18|
                  |L47.14|
00000e  f0200080          BIC      r0,r0,#0x80
                  |L47.18|
000012  6008              STR      r0,[r1,#0]            ;2115
;;;2121     }
;;;2122   }
000014  4770              BX       lr
;;;2123   
                          ENDP

000016  0000              DCW      0x0000
                  |L47.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;829      */
;;;830    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;831    {
;;;832      /* Time = 00h:00min:00sec */
;;;833      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;834      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;835      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;836      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;837    }
00000a  4770              BX       lr
;;;838    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;572      */
;;;573    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;574    {
;;;575      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;576      ErrorStatus status = ERROR;
;;;577      uint32_t synchrostatus = 0x00;
;;;578    
;;;579      if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
000004  9000              STR      r0,[sp,#0]
000006  4813              LDR      r0,|L49.84|
000008  6800              LDR      r0,[r0,#0]
00000a  0680              LSLS     r0,r0,#26
00000c  d501              BPL      |L49.18|
;;;580      {
;;;581        /* Bypass shadow mode */
;;;582        status = SUCCESS;
00000e  2001              MOVS     r0,#1
;;;583      }
;;;584      else
;;;585      {
;;;586        /* Disable the write protection for RTC registers */
;;;587        RTC->WPR = 0xCA;
;;;588        RTC->WPR = 0x53;
;;;589        
;;;590        /* Clear RSF flag */
;;;591        RTC->ISR &= (uint32_t)RTC_RSF_MASK;
;;;592        
;;;593        /* Wait the registers to be synchronised */
;;;594        do
;;;595        {
;;;596          synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;597          synchrocounter++;  
;;;598        } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
;;;599        
;;;600        if ((RTC->ISR & RTC_ISR_RSF) != RESET)
;;;601        {
;;;602          status = SUCCESS;
;;;603        }
;;;604        else
;;;605        {
;;;606          status = ERROR;
;;;607        }
;;;608    
;;;609        /* Enable the write protection for RTC registers */
;;;610        RTC->WPR = 0xFF;
;;;611      } 
;;;612      
;;;613      return (status);
;;;614    }
000010  bd18              POP      {r3,r4,pc}
                  |L49.18|
000012  4910              LDR      r1,|L49.84|
000014  20ca              MOVS     r0,#0xca              ;587
000016  311c              ADDS     r1,r1,#0x1c           ;587
000018  6008              STR      r0,[r1,#0]            ;587
00001a  2053              MOVS     r0,#0x53              ;588
00001c  6008              STR      r0,[r1,#0]            ;588
00001e  480d              LDR      r0,|L49.84|
000020  1d00              ADDS     r0,r0,#4              ;591
000022  6802              LDR      r2,[r0,#0]            ;591
000024  f02202a0          BIC      r2,r2,#0xa0           ;591
000028  6002              STR      r2,[r0,#0]            ;591
00002a  13c4              ASRS     r4,r0,#15             ;598
                  |L49.44|
00002c  6802              LDR      r2,[r0,#0]            ;596
00002e  9b00              LDR      r3,[sp,#0]            ;597
000030  f0020220          AND      r2,r2,#0x20           ;596
000034  1c5b              ADDS     r3,r3,#1              ;597
000036  9300              STR      r3,[sp,#0]            ;598
000038  42a3              CMP      r3,r4                 ;598
00003a  d001              BEQ      |L49.64|
00003c  2a00              CMP      r2,#0                 ;598
00003e  d0f5              BEQ      |L49.44|
                  |L49.64|
000040  6800              LDR      r0,[r0,#0]            ;600
000042  0680              LSLS     r0,r0,#26             ;600
000044  d501              BPL      |L49.74|
000046  2001              MOVS     r0,#1                 ;602
000048  e000              B        |L49.76|
                  |L49.74|
00004a  2000              MOVS     r0,#0                 ;606
                  |L49.76|
00004c  22ff              MOVS     r2,#0xff              ;610
00004e  600a              STR      r2,[r1,#0]            ;610
000050  bd18              POP      {r3,r4,pc}
;;;615    
                          ENDP

000052  0000              DCW      0x0000
                  |L49.84|
                          DCD      0x40002808

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1454     */
;;;1455   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  4a08              LDR      r2,|L50.36|
;;;1456   {
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1459   
;;;1460     /* Disable the write protection for RTC registers */
;;;1461     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1462     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1463   
;;;1464     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1465     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4906              LDR      r1,|L50.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f0230307          BIC      r3,r3,#7
000014  600b              STR      r3,[r1,#0]
;;;1466   
;;;1467     /* Configure the clock source */
;;;1468     RTC->CR |= (uint32_t)RTC_WakeUpClock;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1469     
;;;1470     /* Enable the write protection for RTC registers */
;;;1471     RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1472   }
000020  4770              BX       lr
;;;1473   
                          ENDP

000022  0000              DCW      0x0000
                  |L50.36|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1514     */
;;;1515   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;1516   {
;;;1517     __IO uint32_t wutcounter = 0x00;
000002  2100              MOVS     r1,#0
;;;1518     uint32_t wutwfstatus = 0x00;
;;;1519     ErrorStatus status = ERROR;
;;;1520     
;;;1521     /* Check the parameters */
;;;1522     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1523   
;;;1524     /* Disable the write protection for RTC registers */
;;;1525     RTC->WPR = 0xCA;
000004  4a13              LDR      r2,|L51.84|
000006  9100              STR      r1,[sp,#0]
000008  21ca              MOVS     r1,#0xca
00000a  6011              STR      r1,[r2,#0]
;;;1526     RTC->WPR = 0x53;
00000c  2153              MOVS     r1,#0x53
00000e  6011              STR      r1,[r2,#0]
;;;1527   
;;;1528     if (NewState != DISABLE)
;;;1529     {
;;;1530       /* Enable the Wakeup Timer */
;;;1531       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000010  4910              LDR      r1,|L51.84|
000012  391c              SUBS     r1,r1,#0x1c
000014  2800              CMP      r0,#0                 ;1528
;;;1532       status = SUCCESS;    
;;;1533     }
;;;1534     else
;;;1535     {
;;;1536       /* Disable the Wakeup Timer */
;;;1537       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
000016  6808              LDR      r0,[r1,#0]
000018  d003              BEQ      |L51.34|
00001a  f4406080          ORR      r0,r0,#0x400          ;1531
00001e  6008              STR      r0,[r1,#0]            ;1531
000020  e014              B        |L51.76|
                  |L51.34|
000022  f4206080          BIC      r0,r0,#0x400
000026  6008              STR      r0,[r1,#0]
;;;1538       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1539       do
;;;1540       {
;;;1541         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000028  480a              LDR      r0,|L51.84|
00002a  3818              SUBS     r0,r0,#0x18
;;;1542         wutcounter++;  
;;;1543       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00002c  1444              ASRS     r4,r0,#17
                  |L51.46|
00002e  6801              LDR      r1,[r0,#0]            ;1541
000030  9b00              LDR      r3,[sp,#0]            ;1542
000032  f0010104          AND      r1,r1,#4              ;1541
000036  1c5b              ADDS     r3,r3,#1              ;1542
000038  9300              STR      r3,[sp,#0]
00003a  42a3              CMP      r3,r4
00003c  d001              BEQ      |L51.66|
00003e  2900              CMP      r1,#0
000040  d0f5              BEQ      |L51.46|
                  |L51.66|
;;;1544       
;;;1545       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000042  6800              LDR      r0,[r0,#0]
000044  0740              LSLS     r0,r0,#29
000046  d401              BMI      |L51.76|
;;;1546       {
;;;1547         status = ERROR;
000048  2000              MOVS     r0,#0
00004a  e000              B        |L51.78|
                  |L51.76|
;;;1548       }
;;;1549       else
;;;1550       {
;;;1551         status = SUCCESS;
00004c  2001              MOVS     r0,#1
                  |L51.78|
;;;1552       }    
;;;1553     }
;;;1554   
;;;1555     /* Enable the write protection for RTC registers */
;;;1556     RTC->WPR = 0xFF;
00004e  21ff              MOVS     r1,#0xff
000050  6011              STR      r1,[r2,#0]
;;;1557     
;;;1558     return status;
;;;1559   }
000052  bd18              POP      {r3,r4,pc}
;;;1560   
                          ENDP

                  |L51.84|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2170     */
;;;2171   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;2172   {
;;;2173     __IO uint32_t tmp = 0;
;;;2174     
;;;2175     /* Check the parameters */
;;;2176     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2177   
;;;2178     tmp = RTC_BASE + 0x50;
000002  4a03              LDR      r2,|L52.16|
;;;2179     tmp += (RTC_BKP_DR * 4);
000004  eb020080          ADD      r0,r2,r0,LSL #2
;;;2180   
;;;2181     /* Write the specified register */
;;;2182     *(__IO uint32_t *)tmp = (uint32_t)Data;
000008  9000              STR      r0,[sp,#0]
00000a  6001              STR      r1,[r0,#0]
;;;2183   }
00000c  bd08              POP      {r3,pc}
;;;2184   
                          ENDP

00000e  0000              DCW      0x0000
                  |L52.16|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;478      */
;;;479    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L53.20|
;;;480    {
000002  b108              CBZ      r0,|L53.8|
;;;481      /* Check the parameters */
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483        
;;;484      if (NewState != DISABLE)
;;;485      {
;;;486        /* Enable the write protection for RTC registers */
;;;487        RTC->WPR = 0xFF;   
000004  20ff              MOVS     r0,#0xff
000006  e002              B        |L53.14|
                  |L53.8|
;;;488      }
;;;489      else
;;;490      {
;;;491        /* Disable the write protection for RTC registers */
;;;492        RTC->WPR = 0xCA;
000008  20ca              MOVS     r0,#0xca
00000a  6008              STR      r0,[r1,#0]
;;;493        RTC->WPR = 0x53;    
00000c  2053              MOVS     r0,#0x53
                  |L53.14|
00000e  6008              STR      r0,[r1,#0]            ;487
;;;494      }
;;;495    }
000010  4770              BX       lr
;;;496    
                          ENDP

000012  0000              DCW      0x0000
                  |L53.20|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_rtc_c_81435638____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f30x_rtc_c_81435638____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_rtc_c_81435638____REVSH|
#line 128
|__asm___15_stm32f30x_rtc_c_81435638____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
