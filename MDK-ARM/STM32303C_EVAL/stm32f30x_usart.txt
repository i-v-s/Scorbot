; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_usart.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_usart.c]
                          THUMB

                          AREA ||i.USART_AddressDetectionConfig||, CODE, READONLY, ALIGN=1

                  USART_AddressDetectionConfig PROC
;;;1047     */
;;;1048   void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
000000  6842              LDR      r2,[r0,#4]
;;;1049   {
;;;1050     /* Check the parameters */
;;;1051     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1052     assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
;;;1053   
;;;1054     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
000002  f0220210          BIC      r2,r2,#0x10
000006  6042              STR      r2,[r0,#4]
;;;1055     USARTx->CR2 |= USART_AddressLength;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;1056   }
00000e  4770              BX       lr
;;;1057   
                          ENDP


                          AREA ||i.USART_AutoBaudRateCmd||, CODE, READONLY, ALIGN=1

                  USART_AutoBaudRateCmd PROC
;;;837      */
;;;838    void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;839    {
;;;840      /* Check the parameters */
;;;841      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;842      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;843    
;;;844      if (NewState != DISABLE)
;;;845      {
;;;846        /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
;;;847           register */
;;;848        USARTx->CR2 |= USART_CR2_ABREN;
;;;849      }
;;;850      else
;;;851      {
;;;852        /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
;;;853           register */
;;;854        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L2.12|
000006  f4411180          ORR      r1,r1,#0x100000       ;848
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4211180          BIC      r1,r1,#0x100000
                  |L2.16|
000010  6041              STR      r1,[r0,#4]            ;848
;;;855      }
;;;856    }
000012  4770              BX       lr
;;;857    
                          ENDP


                          AREA ||i.USART_AutoBaudRateConfig||, CODE, READONLY, ALIGN=1

                  USART_AutoBaudRateConfig PROC
;;;871      */
;;;872    void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
000000  6842              LDR      r2,[r0,#4]
;;;873    {
;;;874      /* Check the parameters */
;;;875      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;876      assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
;;;877    
;;;878      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
000002  f42202c0          BIC      r2,r2,#0x600000
000006  6042              STR      r2,[r0,#4]
;;;879      USARTx->CR2 |= USART_AutoBaudRate;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;880    }
00000e  4770              BX       lr
;;;881    
                          ENDP


                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;1952     */
;;;1953   void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000000  6201              STR      r1,[r0,#0x20]
;;;1954   {
;;;1955     /* Check the parameters */
;;;1956     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1957     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1958        
;;;1959     USARTx->ICR = USART_FLAG;
;;;1960   }
000002  4770              BX       lr
;;;1961   
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;2055     */
;;;2056   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
000000  0c0a              LSRS     r2,r1,#16
;;;2057   {
;;;2058     uint32_t bitpos = 0, itmask = 0;
;;;2059     /* Check the parameters */
;;;2060     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;2061     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;2062     
;;;2063     bitpos = USART_IT >> 0x10;
;;;2064     itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
000002  2101              MOVS     r1,#1
000004  4091              LSLS     r1,r1,r2
;;;2065     USARTx->ICR = (uint32_t)itmask;
000006  6201              STR      r1,[r0,#0x20]
;;;2066   }
000008  4770              BX       lr
;;;2067   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;358      */
;;;359    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;360    {
;;;361      uint32_t tmpreg = 0;
;;;362      /* Check the parameters */
;;;363      assert_param(IS_USART_123_PERIPH(USARTx));
;;;364      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;365      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;366      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;367      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;368    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;369      tmpreg = USARTx->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;370      /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
;;;371      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
000004  f4226370          BIC      r3,r2,#0xf00
000008  e9d12400          LDRD     r2,r4,[r1,#0]
;;;372      /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
;;;373      /* Set CLKEN bit according to USART_Clock value */
;;;374      /* Set CPOL bit according to USART_CPOL value */
;;;375      /* Set CPHA bit according to USART_CPHA value */
;;;376      /* Set LBCL bit according to USART_LastBit value */
;;;377      tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000c  4322              ORRS     r2,r2,r4
00000e  e9d14102          LDRD     r4,r1,[r1,#8]
000012  430c              ORRS     r4,r4,r1
000014  4322              ORRS     r2,r2,r4
000016  431a              ORRS     r2,r2,r3
;;;378                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
;;;379      /* Write to USART CR2 */
;;;380      USARTx->CR2 = tmpreg;
000018  6042              STR      r2,[r0,#4]
;;;381    }
00001a  bd10              POP      {r4,pc}
;;;382    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;388      */
;;;389    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;390    {
;;;391      /* USART_ClockInitStruct members default value */
;;;392      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
;;;393      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000002  6001              STR      r1,[r0,#0]
;;;394      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000004  6041              STR      r1,[r0,#4]
;;;395      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;396    }
00000a  4770              BX       lr
;;;397    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;405      */
;;;406    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;407    {
;;;408      /* Check the parameters */
;;;409      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;410      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;411      
;;;412      if (NewState != DISABLE)
;;;413      {
;;;414        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;415        USARTx->CR1 |= USART_CR1_UE;
;;;416      }
;;;417      else
;;;418      {
;;;419        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;420        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L8.12|
000006  f0410101          ORR      r1,r1,#1              ;415
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L8.16|
000010  6001              STR      r1,[r0,#0]            ;415
;;;421      }
;;;422    }
000012  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.USART_DECmd||, CODE, READONLY, ALIGN=1

                  USART_DECmd PROC
;;;1494     */
;;;1495   void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1496   {
;;;1497     /* Check the parameters */
;;;1498     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1499     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1500     if (NewState != DISABLE)
;;;1501     {
;;;1502       /* Enable the DE functionality by setting the DEM bit in the CR3 register */
;;;1503       USARTx->CR3 |= USART_CR3_DEM;
;;;1504     }
;;;1505     else
;;;1506     {
;;;1507       /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
;;;1508       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L9.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;1503
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L9.16|
000010  6081              STR      r1,[r0,#8]            ;1503
;;;1509     }
;;;1510   }
000012  4770              BX       lr
;;;1511   
                          ENDP


                          AREA ||i.USART_DEPolarityConfig||, CODE, READONLY, ALIGN=1

                  USART_DEPolarityConfig PROC
;;;1521     */
;;;1522   void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
000000  6882              LDR      r2,[r0,#8]
;;;1523   {
;;;1524     /* Check the parameters */
;;;1525     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1526     assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
;;;1527   
;;;1528     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
000002  f4224200          BIC      r2,r2,#0x8000
000006  6082              STR      r2,[r0,#8]
;;;1529     USARTx->CR3 |= USART_DEPolarity;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1530   }
00000e  4770              BX       lr
;;;1531   
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;1606     */
;;;1607   void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1608   {
;;;1609     /* Check the parameters */
;;;1610     assert_param(IS_USART_1234_PERIPH(USARTx));
;;;1611     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1612     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1613   
;;;1614     if (NewState != DISABLE)
;;;1615     {
;;;1616       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1617          DMAR bits in the USART CR3 register */
;;;1618       USARTx->CR3 |= USART_DMAReq;
;;;1619     }
;;;1620     else
;;;1621     {
;;;1622       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1623          DMAR bits in the USART CR3 register */
;;;1624       USARTx->CR3 &= (uint32_t)~USART_DMAReq;
000002  6882              LDR      r2,[r0,#8]
000004  d001              BEQ      |L11.10|
000006  430a              ORRS     r2,r2,r1              ;1618
000008  e000              B        |L11.12|
                  |L11.10|
00000a  438a              BICS     r2,r2,r1
                  |L11.12|
00000c  6082              STR      r2,[r0,#8]            ;1618
;;;1625     }
;;;1626   }
00000e  4770              BX       lr
;;;1627   
                          ENDP


                          AREA ||i.USART_DMAReceptionErrorConfig||, CODE, READONLY, ALIGN=1

                  USART_DMAReceptionErrorConfig PROC
;;;1639     */
;;;1640   void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
000000  6882              LDR      r2,[r0,#8]
;;;1641   {
;;;1642     /* Check the parameters */
;;;1643     assert_param(IS_USART_1234_PERIPH(USARTx));
;;;1644     assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
;;;1645     
;;;1646     /* Clear the DMA Reception error detection bit */
;;;1647     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
000002  f4225200          BIC      r2,r2,#0x2000
000006  6082              STR      r2,[r0,#8]
;;;1648     /* Set the new value for the DMA Reception error detection bit */
;;;1649     USARTx->CR3 |= USART_DMAOnError;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1650   }
00000e  4770              BX       lr
;;;1651   
                          ENDP


                          AREA ||i.USART_DataInvCmd||, CODE, READONLY, ALIGN=1

                  USART_DataInvCmd PROC
;;;559      */
;;;560    void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;561    {
;;;562      /* Check the parameters */
;;;563      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;564      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;565    
;;;566      if (NewState != DISABLE)
;;;567      {
;;;568        /* Enable the binary data inversion feature by setting the DATAINV bit in
;;;569           the CR2 register */
;;;570        USARTx->CR2 |= USART_CR2_DATAINV;
;;;571      }
;;;572      else
;;;573      {
;;;574        /* Disable the binary data inversion feature by clearing the DATAINV bit in
;;;575           the CR2 register */
;;;576        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L13.12|
000006  f4412180          ORR      r1,r1,#0x40000        ;570
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f4212180          BIC      r1,r1,#0x40000
                  |L13.16|
000010  6041              STR      r1,[r0,#4]            ;570
;;;577      }
;;;578    }
000012  4770              BX       lr
;;;579    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;172      */
;;;173    void USART_DeInit(USART_TypeDef* USARTx)
000000  4917              LDR      r1,|L14.96|
;;;174    {
000002  b510              PUSH     {r4,lr}
;;;175      /* Check the parameters */
;;;176      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;177    
;;;178      if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L14.30|
;;;179      {
;;;180        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  038c              LSLS     r4,r1,#14
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;181        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L14.30|
;;;182      }
;;;183      else if (USARTx == USART2)
00001e  4911              LDR      r1,|L14.100|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L14.42|
;;;184      {
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  044c              LSLS     r4,r1,#17
;;;186        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000028  e010              B        |L14.76|
                  |L14.42|
;;;187      }
;;;188      else if (USARTx == USART3)
00002a  490f              LDR      r1,|L14.104|
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L14.54|
;;;189      {
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000030  2101              MOVS     r1,#1
000032  048c              LSLS     r4,r1,#18
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000034  e00a              B        |L14.76|
                  |L14.54|
;;;192      }
;;;193      else if (USARTx == UART4)
000036  490d              LDR      r1,|L14.108|
000038  4288              CMP      r0,r1
00003a  d102              BNE      |L14.66|
;;;194      {
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  04cc              LSLS     r4,r1,#19
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000040  e004              B        |L14.76|
                  |L14.66|
;;;197      }
;;;198      else
;;;199      {
;;;200        if  (USARTx == UART5)
000042  490b              LDR      r1,|L14.112|
000044  4288              CMP      r0,r1
000046  d10a              BNE      |L14.94|
;;;201        {
;;;202          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000048  2101              MOVS     r1,#1
00004a  050c              LSLS     r4,r1,#20
                  |L14.76|
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;203          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000052  4620              MOV      r0,r4
000054  e8bd4010          POP      {r4,lr}
000058  2100              MOVS     r1,#0
00005a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L14.94|
;;;204        }
;;;205      }
;;;206    }
00005e  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L14.96|
                          DCD      0x40013800
                  |L14.100|
                          DCD      0x40004400
                  |L14.104|
                          DCD      0x40004800
                  |L14.108|
                          DCD      0x40004c00
                  |L14.112|
                          DCD      0x40005000

                          AREA ||i.USART_DirectionModeCmd||, CODE, READONLY, ALIGN=1

                  USART_DirectionModeCmd PROC
;;;435      */
;;;436    void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;437    {
;;;438      /* Check the parameters */
;;;439      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;440      assert_param(IS_USART_MODE(USART_DirectionMode));
;;;441      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;442    
;;;443      if (NewState != DISABLE)
;;;444      {
;;;445        /* Enable the USART's transfer interface by setting the TE and/or RE bits 
;;;446           in the USART CR1 register */
;;;447        USARTx->CR1 |= USART_DirectionMode;
;;;448      }
;;;449      else
;;;450      {
;;;451        /* Disable the USART's transfer interface by clearing the TE and/or RE bits
;;;452           in the USART CR3 register */
;;;453        USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L15.10|
000006  430a              ORRS     r2,r2,r1              ;447
000008  e000              B        |L15.12|
                  |L15.10|
00000a  438a              BICS     r2,r2,r1
                  |L15.12|
00000c  6002              STR      r2,[r0,#0]            ;447
;;;454      }
;;;455    }
00000e  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;1901     */
;;;1902   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;1903   {
;;;1904     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1905     /* Check the parameters */
;;;1906     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1907     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1908     
;;;1909     if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
000004  69d2              LDR      r2,[r2,#0x1c]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L16.12|
;;;1910     {
;;;1911       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L16.12|
;;;1912     }
;;;1913     else
;;;1914     {
;;;1915       bitstatus = RESET;
;;;1916     }
;;;1917     return bitstatus;
;;;1918   }
00000c  4770              BX       lr
;;;1919   
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;1983     */
;;;1984   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1985   {
;;;1986     uint32_t bitpos = 0, itmask = 0, usartreg = 0;
;;;1987     ITStatus bitstatus = RESET;
;;;1988     /* Check the parameters */
;;;1989     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1990     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1991     
;;;1992     /* Get the USART register index */
;;;1993     usartreg = (((uint16_t)USART_IT) >> 0x08);
;;;1994     /* Get the interrupt position */
;;;1995     itmask = USART_IT & IT_MASK;
;;;1996     itmask = (uint32_t)0x01 << itmask;
000002  2201              MOVS     r2,#1
000004  2500              MOVS     r5,#0                 ;1987
000006  f3c12307          UBFX     r3,r1,#8,#8           ;1993
00000a  fa02f401          LSL      r4,r2,r1
;;;1997     
;;;1998     if (usartreg == 0x01) /* The IT  is in CR1 register */
00000e  2b01              CMP      r3,#1
000010  d00f              BEQ      |L17.50|
;;;1999     {
;;;2000       itmask &= USARTx->CR1;
;;;2001     }
;;;2002     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000012  2b02              CMP      r3,#2
000014  d00f              BEQ      |L17.54|
;;;2003     {
;;;2004       itmask &= USARTx->CR2;
;;;2005     }
;;;2006     else /* The IT  is in CR3 register */
;;;2007     {
;;;2008       itmask &= USARTx->CR3;
000016  6883              LDR      r3,[r0,#8]
                  |L17.24|
;;;2009     }
;;;2010     
;;;2011     bitpos = USART_IT >> 0x10;
000018  ea4f4111          LSR      r1,r1,#16
;;;2012     bitpos = (uint32_t)0x01 << bitpos;
;;;2013     bitpos &= USARTx->ISR;
00001c  69c0              LDR      r0,[r0,#0x1c]
00001e  4223              TST      r3,r4                 ;2004
000020  fa02f201          LSL      r2,r2,r1              ;2012
000024  ea000002          AND      r0,r0,r2
000028  d001              BEQ      |L17.46|
;;;2014     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00002a  b100              CBZ      r0,|L17.46|
;;;2015     {
;;;2016       bitstatus = SET;
00002c  2501              MOVS     r5,#1
                  |L17.46|
;;;2017     }
;;;2018     else
;;;2019     {
;;;2020       bitstatus = RESET;
;;;2021     }
;;;2022     
;;;2023     return bitstatus;  
00002e  4628              MOV      r0,r5
;;;2024   }
000030  bd30              POP      {r4,r5,pc}
                  |L17.50|
000032  6803              LDR      r3,[r0,#0]            ;2000
000034  e7f0              B        |L17.24|
                  |L17.54|
000036  6843              LDR      r3,[r0,#4]            ;2004
000038  e7ee              B        |L17.24|
;;;2025   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;1188     */
;;;1189   void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1190   {
;;;1191     /* Check the parameters */
;;;1192     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1193     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1194     
;;;1195     if (NewState != DISABLE)
;;;1196     {
;;;1197       /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;1198       USARTx->CR3 |= USART_CR3_HDSEL;
;;;1199     }
;;;1200     else
;;;1201     {
;;;1202       /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;1203       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L18.12|
000006  f0410108          ORR      r1,r1,#8              ;1198
00000a  e001              B        |L18.16|
                  |L18.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L18.16|
000010  6081              STR      r1,[r0,#8]            ;1198
;;;1204     }
;;;1205   }
000012  4770              BX       lr
;;;1206   
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;1772     */
;;;1773   void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1774   {
;;;1775     uint32_t usartreg = 0, itpos = 0, itmask = 0;
;;;1776     uint32_t usartxbase = 0;
;;;1777     /* Check the parameters */
;;;1778     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1779     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1780     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1781     
;;;1782     usartxbase = (uint32_t)USARTx;
;;;1783   
;;;1784     /* Get the USART register index */
;;;1785     usartreg = (((uint16_t)USART_IT) >> 0x08);
;;;1786   
;;;1787     /* Get the interrupt position */
;;;1788     itpos = USART_IT & IT_MASK;
;;;1789     itmask = (((uint32_t)0x01) << itpos);
000002  2301              MOVS     r3,#1
000004  f3c12407          UBFX     r4,r1,#8,#8           ;1785
000008  408b              LSLS     r3,r3,r1
;;;1790   
;;;1791     if (usartreg == 0x02) /* The IT is in CR2 register */
00000a  2c02              CMP      r4,#2
00000c  d002              BEQ      |L19.20|
;;;1792     {
;;;1793       usartxbase += 0x04;
;;;1794     }
;;;1795     else if (usartreg == 0x03) /* The IT is in CR3 register */
00000e  2c03              CMP      r4,#3
000010  d002              BEQ      |L19.24|
000012  e002              B        |L19.26|
                  |L19.20|
000014  1d00              ADDS     r0,r0,#4
000016  e000              B        |L19.26|
                  |L19.24|
000018  3008              ADDS     r0,r0,#8              ;1793
                  |L19.26|
;;;1796     {
;;;1797       usartxbase += 0x08;
;;;1798     }
;;;1799     else /* The IT is in CR1 register */
;;;1800     {
;;;1801     }
;;;1802     if (NewState != DISABLE)
;;;1803     {
;;;1804       *(__IO uint32_t*)usartxbase  |= itmask;
;;;1805     }
;;;1806     else
;;;1807     {
;;;1808       *(__IO uint32_t*)usartxbase &= ~itmask;
00001a  6801              LDR      r1,[r0,#0]
00001c  b10a              CBZ      r2,|L19.34|
00001e  4319              ORRS     r1,r1,r3              ;1804
000020  e000              B        |L19.36|
                  |L19.34|
000022  4399              BICS     r1,r1,r3
                  |L19.36|
000024  6001              STR      r1,[r0,#0]            ;1804
;;;1809     }
;;;1810   }
000026  bd10              POP      {r4,pc}
;;;1811   
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;216      */
;;;217    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;218    {
000002  4604              MOV      r4,r0
;;;219      uint32_t divider = 0, apbclock = 0, tmpreg = 0;
;;;220      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;221      
;;;222      /* Check the parameters */
;;;223      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;224      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));
;;;225      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;226      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;227      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;228      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;229      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;230      
;;;231      /* Disable USART */
;;;232      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
000004  6800              LDR      r0,[r0,#0]
000006  b08f              SUB      sp,sp,#0x3c           ;218
000008  460d              MOV      r5,r1                 ;218
00000a  f0200001          BIC      r0,r0,#1
00000e  6020              STR      r0,[r4,#0]
;;;233      
;;;234      /*---------------------------- USART CR2 Configuration -----------------------*/
;;;235      tmpreg = USARTx->CR2;
000010  6860              LDR      r0,[r4,#4]
;;;236      /* Clear STOP[13:12] bits */
;;;237      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
000012  f4205140          BIC      r1,r0,#0x3000
;;;238      
;;;239      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;240      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;241      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000016  68a8              LDR      r0,[r5,#8]
000018  4308              ORRS     r0,r0,r1
;;;242      
;;;243      /* Write to USART CR2 */
;;;244      USARTx->CR2 = tmpreg;
00001a  6060              STR      r0,[r4,#4]
;;;245      
;;;246      /*---------------------------- USART CR1 Configuration -----------------------*/
;;;247      tmpreg = USARTx->CR1;
00001c  6820              LDR      r0,[r4,#0]
;;;248      /* Clear M, PCE, PS, TE and RE bits */
;;;249      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
00001e  f241610c          MOV      r1,#0x160c
000022  4388              BICS     r0,r0,r1
;;;250      
;;;251      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;252      /* Set the M bits according to USART_WordLength value */
;;;253      /* Set PCE and PS bits according to USART_Parity value */
;;;254      /* Set TE and RE bits according to USART_Mode value */
;;;255      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000024  68ea              LDR      r2,[r5,#0xc]
000026  6869              LDR      r1,[r5,#4]
000028  4311              ORRS     r1,r1,r2
00002a  692a              LDR      r2,[r5,#0x10]
00002c  4302              ORRS     r2,r2,r0
00002e  4311              ORRS     r1,r1,r2
;;;256        USART_InitStruct->USART_Mode;
;;;257      
;;;258      /* Write to USART CR1 */
;;;259      USARTx->CR1 = tmpreg;
000030  6021              STR      r1,[r4,#0]
;;;260      
;;;261      /*---------------------------- USART CR3 Configuration -----------------------*/
;;;262      tmpreg = USARTx->CR3;
000032  68a0              LDR      r0,[r4,#8]
;;;263      /* Clear CTSE and RTSE bits */
;;;264      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
000034  f4207140          BIC      r1,r0,#0x300
;;;265      
;;;266      /* Configure the USART HFC -------------------------------------------------*/
;;;267      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;268      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000038  6968              LDR      r0,[r5,#0x14]
00003a  4308              ORRS     r0,r0,r1
;;;269      
;;;270      /* Write to USART CR3 */
;;;271      USARTx->CR3 = tmpreg;
00003c  60a0              STR      r0,[r4,#8]
;;;272      
;;;273      /*---------------------------- USART BRR Configuration -----------------------*/
;;;274      /* Configure the USART Baud Rate -------------------------------------------*/
;;;275      RCC_GetClocksFreq(&RCC_ClocksStatus);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       RCC_GetClocksFreq
;;;276      
;;;277      if (USARTx == USART1)
000044  481c              LDR      r0,|L20.184|
000046  4284              CMP      r4,r0
000048  d101              BNE      |L20.78|
;;;278      {
;;;279        apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
00004a  990a              LDR      r1,[sp,#0x28]
00004c  e00f              B        |L20.110|
                  |L20.78|
;;;280      }
;;;281      else if (USARTx == USART2)
00004e  481b              LDR      r0,|L20.188|
000050  4284              CMP      r4,r0
000052  d101              BNE      |L20.88|
;;;282      {
;;;283        apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
000054  990b              LDR      r1,[sp,#0x2c]
000056  e00a              B        |L20.110|
                  |L20.88|
;;;284      }
;;;285      else if (USARTx == USART3)
000058  4819              LDR      r0,|L20.192|
00005a  4284              CMP      r4,r0
00005c  d101              BNE      |L20.98|
;;;286      {
;;;287        apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
00005e  990c              LDR      r1,[sp,#0x30]
000060  e005              B        |L20.110|
                  |L20.98|
;;;288      }
;;;289      else if (USARTx == UART4)
000062  4818              LDR      r0,|L20.196|
000064  4284              CMP      r4,r0
000066  d101              BNE      |L20.108|
;;;290      {
;;;291        apbclock = RCC_ClocksStatus.UART4CLK_Frequency;
000068  990d              LDR      r1,[sp,#0x34]
00006a  e000              B        |L20.110|
                  |L20.108|
;;;292      }
;;;293      else 
;;;294      {
;;;295        apbclock = RCC_ClocksStatus.UART5CLK_Frequency;
00006c  990e              LDR      r1,[sp,#0x38]
                  |L20.110|
;;;296      }  
;;;297      
;;;298      /* Determine the integer part */
;;;299      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00006e  6820              LDR      r0,[r4,#0]
000070  0400              LSLS     r0,r0,#16
000072  d508              BPL      |L20.134|
;;;300      {
;;;301        /* (divider * 10) computing in case Oversampling mode is 8 Samples */
;;;302        divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
000074  004a              LSLS     r2,r1,#1
000076  6829              LDR      r1,[r5,#0]
000078  fbb2f0f1          UDIV     r0,r2,r1
;;;303        tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
00007c  fbb2f3f1          UDIV     r3,r2,r1
000080  fb012113          MLS      r1,r1,r3,r2
000084  e006              B        |L20.148|
                  |L20.134|
;;;304      }
;;;305      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;306      {
;;;307        /* (divider * 10) computing in case Oversampling mode is 16 Samples */
;;;308        divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
000086  682a              LDR      r2,[r5,#0]
000088  fbb1f0f2          UDIV     r0,r1,r2
;;;309        tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
00008c  fbb1f3f2          UDIV     r3,r1,r2
000090  fb021113          MLS      r1,r2,r3,r1
                  |L20.148|
;;;310      }
;;;311      
;;;312      /* round the divider : if fractional part i greater than 0.5 increment divider */
;;;313      if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
000094  682a              LDR      r2,[r5,#0]
000096  ebb10f52          CMP      r1,r2,LSR #1
00009a  d300              BCC      |L20.158|
00009c  1c40              ADDS     r0,r0,#1
                  |L20.158|
;;;314      {
;;;315        divider++;
;;;316      } 
;;;317      
;;;318      /* Implement the divider in case Oversampling mode is 8 Samples */
;;;319      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00009e  6821              LDR      r1,[r4,#0]
0000a0  0409              LSLS     r1,r1,#16
0000a2  d505              BPL      |L20.176|
;;;320      {
;;;321        /* get the LSB of divider and shift it to the right by 1 bit */
;;;322        tmpreg = (divider & (uint16_t)0x000F) >> 1;
0000a4  f3c00142          UBFX     r1,r0,#1,#3
;;;323        
;;;324        /* update the divider value */
;;;325        divider = (divider & (uint16_t)0xFFF0) | tmpreg;
0000a8  f64f72f0          MOV      r2,#0xfff0
0000ac  4010              ANDS     r0,r0,r2
0000ae  4308              ORRS     r0,r0,r1
                  |L20.176|
;;;326      }
;;;327      
;;;328      /* Write to USART BRR */
;;;329      USARTx->BRR = (uint16_t)divider;
0000b0  81a0              STRH     r0,[r4,#0xc]
;;;330    }
0000b2  b00f              ADD      sp,sp,#0x3c
0000b4  bd30              POP      {r4,r5,pc}
;;;331    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L20.184|
                          DCD      0x40013800
                  |L20.188|
                          DCD      0x40004400
                  |L20.192|
                          DCD      0x40004800
                  |L20.196|
                          DCD      0x40004c00

                          AREA ||i.USART_InvPinCmd||, CODE, READONLY, ALIGN=1

                  USART_InvPinCmd PROC
;;;595      */
;;;596    void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;597    {
;;;598      /* Check the parameters */
;;;599      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;600      assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));
;;;601      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;602    
;;;603      if (NewState != DISABLE)
;;;604      {
;;;605        /* Enable the active level inversion for selected pins by setting the TXINV 
;;;606           and/or RXINV bits in the USART CR2 register */
;;;607        USARTx->CR2 |= USART_InvPin;
;;;608      }
;;;609      else
;;;610      {
;;;611        /* Disable the active level inversion for selected requests by clearing the 
;;;612           TXINV and/or RXINV bits in the USART CR2 register */
;;;613        USARTx->CR2 &= (uint32_t)~USART_InvPin;
000002  6842              LDR      r2,[r0,#4]
000004  d001              BEQ      |L21.10|
000006  430a              ORRS     r2,r2,r1              ;607
000008  e000              B        |L21.12|
                  |L21.10|
00000a  438a              BICS     r2,r2,r1
                  |L21.12|
00000c  6042              STR      r2,[r0,#4]            ;607
;;;614      }
;;;615    }
00000e  4770              BX       lr
;;;616    
                          ENDP


                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;1436     */
;;;1437   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1438   {
;;;1439     /* Check the parameters */
;;;1440     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1441     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1442   
;;;1443     if (NewState != DISABLE)
;;;1444     {
;;;1445       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1446       USARTx->CR3 |= USART_CR3_IREN;
;;;1447     }
;;;1448     else
;;;1449     {
;;;1450       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1451       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L22.12|
000006  f0410102          ORR      r1,r1,#2              ;1446
00000a  e001              B        |L22.16|
                  |L22.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L22.16|
000010  6081              STR      r1,[r0,#8]            ;1446
;;;1452     }
;;;1453   }
000012  4770              BX       lr
;;;1454   /**
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;1418     */
;;;1419   void USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode)
000000  6882              LDR      r2,[r0,#8]
;;;1420   {
;;;1421     /* Check the parameters */
;;;1422     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1423     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1424   
;;;1425     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
000002  f0220204          BIC      r2,r2,#4
000006  6082              STR      r2,[r0,#8]
;;;1426     USARTx->CR3 |= USART_IrDAMode;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1427   }
00000e  4770              BX       lr
;;;1428   
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;1112     */
;;;1113   void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength)
000000  6842              LDR      r2,[r0,#4]
;;;1114   {
;;;1115     /* Check the parameters */
;;;1116     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1117     assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;1118   
;;;1119     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
000002  f0220220          BIC      r2,r2,#0x20
000006  6042              STR      r2,[r0,#4]
;;;1120     USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;1121   }
00000e  4770              BX       lr
;;;1122   
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;1130     */
;;;1131   void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1132   {
;;;1133     /* Check the parameters */
;;;1134     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1135     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1136   
;;;1137     if (NewState != DISABLE)
;;;1138     {
;;;1139       /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;1140       USARTx->CR2 |= USART_CR2_LINEN;
;;;1141     }
;;;1142     else
;;;1143     {
;;;1144       /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;1145       USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L25.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;1140
00000a  e001              B        |L25.16|
                  |L25.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L25.16|
000010  6041              STR      r1,[r0,#4]            ;1140
;;;1146     }
;;;1147   }
000012  4770              BX       lr
;;;1148   
                          ENDP


                          AREA ||i.USART_MSBFirstCmd||, CODE, READONLY, ALIGN=1

                  USART_MSBFirstCmd PROC
;;;525      */
;;;526    void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;527    {
;;;528      /* Check the parameters */
;;;529      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;530      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;531    
;;;532      if (NewState != DISABLE)
;;;533      {
;;;534        /* Enable the most significant bit first transmitted/received following the
;;;535           start bit by setting the MSBFIRST bit in the CR2 register */
;;;536        USARTx->CR2 |= USART_CR2_MSBFIRST;
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Disable the most significant bit first transmitted/received following the
;;;541           start bit by clearing the MSBFIRST bit in the CR2 register */
;;;542        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L26.12|
000006  f4412100          ORR      r1,r1,#0x80000        ;536
00000a  e001              B        |L26.16|
                  |L26.12|
00000c  f4212100          BIC      r1,r1,#0x80000
                  |L26.16|
000010  6041              STR      r1,[r0,#4]            ;536
;;;543      }
;;;544    }
000012  4770              BX       lr
;;;545    
                          ENDP


                          AREA ||i.USART_MuteModeCmd||, CODE, READONLY, ALIGN=1

                  USART_MuteModeCmd PROC
;;;999      */
;;;1000   void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1001   {
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1004     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1005   
;;;1006     if (NewState != DISABLE)
;;;1007     {
;;;1008       /* Enable the USART mute mode by setting the MME bit in the CR1 register */
;;;1009       USARTx->CR1 |= USART_CR1_MME;
;;;1010     }
;;;1011     else
;;;1012     {
;;;1013       /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
;;;1014       USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L27.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;1009
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L27.16|
000010  6001              STR      r1,[r0,#0]            ;1009
;;;1015     }
;;;1016   }
000012  4770              BX       lr
;;;1017   
                          ENDP


                          AREA ||i.USART_MuteModeWakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_MuteModeWakeUpConfig PROC
;;;1027     */
;;;1028   void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
000000  6802              LDR      r2,[r0,#0]
;;;1029   {
;;;1030     /* Check the parameters */
;;;1031     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1032     assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
;;;1033   
;;;1034     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
000002  f4226200          BIC      r2,r2,#0x800
000006  6002              STR      r2,[r0,#0]
;;;1035     USARTx->CR1 |= USART_WakeUp;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1036   }
00000e  4770              BX       lr
;;;1037   
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;495      */
;;;496    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;497    {
;;;498      /* Check the parameters */
;;;499      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;500      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;501    
;;;502      if (NewState != DISABLE)
;;;503      {
;;;504        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;505        USARTx->CR3 |= USART_CR3_ONEBIT;
;;;506      }
;;;507      else
;;;508      {
;;;509        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;510        USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L29.12|
000006  f4416100          ORR      r1,r1,#0x800          ;505
00000a  e001              B        |L29.16|
                  |L29.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L29.16|
000010  6081              STR      r1,[r0,#8]            ;505
;;;511      }
;;;512    }
000012  4770              BX       lr
;;;513    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;467      */
;;;468    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473      
;;;474      if (NewState != DISABLE)
;;;475      {
;;;476        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;477        USARTx->CR1 |= USART_CR1_OVER8;
;;;478      }
;;;479      else
;;;480      {
;;;481        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;482        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L30.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;477
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L30.16|
000010  6001              STR      r1,[r0,#0]            ;477
;;;483      }
;;;484    }
000012  4770              BX       lr
;;;485    
                          ENDP


                          AREA ||i.USART_OverrunDetectionConfig||, CODE, READONLY, ALIGN=1

                  USART_OverrunDetectionConfig PROC
;;;1859     */
;;;1860   void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
000000  6882              LDR      r2,[r0,#8]
;;;1861   {
;;;1862     /* Check the parameters */
;;;1863     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1864     assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
;;;1865     
;;;1866     /* Clear the OVR detection bit */
;;;1867     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
000002  f4225280          BIC      r2,r2,#0x1000
000006  6082              STR      r2,[r0,#8]
;;;1868     /* Set the new value for the OVR detection bit */
;;;1869     USARTx->CR3 |= USART_OVRDetection;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1870   }
00000e  4770              BX       lr
;;;1871   
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;930      */
;;;931    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  8c80              LDRH     r0,[r0,#0x24]
;;;932    {
;;;933      /* Check the parameters */
;;;934      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;935    
;;;936      /* Receive Data */
;;;937      return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;938    }
000006  4770              BX       lr
;;;939    
                          ENDP


                          AREA ||i.USART_ReceiverTimeOutCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverTimeOutCmd PROC
;;;654      */
;;;655    void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;656    {
;;;657      /* Check the parameters */
;;;658      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;659      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;660    
;;;661      if (NewState != DISABLE)
;;;662      {
;;;663        /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
;;;664           register */
;;;665        USARTx->CR2 |= USART_CR2_RTOEN;
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
;;;670           register */
;;;671        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L33.12|
000006  f4410100          ORR      r1,r1,#0x800000       ;665
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4210100          BIC      r1,r1,#0x800000
                  |L33.16|
000010  6041              STR      r1,[r0,#4]            ;665
;;;672      }
;;;673    }
000012  4770              BX       lr
;;;674    
                          ENDP


                          AREA ||i.USART_RequestCmd||, CODE, READONLY, ALIGN=1

                  USART_RequestCmd PROC
;;;1826     */
;;;1827   void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1828   {
;;;1829     /* Check the parameters */
;;;1830     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1831     assert_param(IS_USART_REQUEST(USART_Request));
;;;1832     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1833   
;;;1834     if (NewState != DISABLE)
;;;1835     {
;;;1836       /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
;;;1837          register.*/
;;;1838       USARTx->RQR |= USART_Request;
;;;1839     }
;;;1840     else
;;;1841     {
;;;1842       /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
;;;1843          register.*/
;;;1844       USARTx->RQR &= (uint32_t)~USART_Request;
000002  8b02              LDRH     r2,[r0,#0x18]
000004  d001              BEQ      |L34.10|
000006  430a              ORRS     r2,r2,r1              ;1838
000008  e000              B        |L34.12|
                  |L34.10|
00000a  438a              BICS     r2,r2,r1
                  |L34.12|
00000c  8302              STRH     r2,[r0,#0x18]         ;1838
;;;1845     }
;;;1846   }
00000e  4770              BX       lr
;;;1847   
                          ENDP


                          AREA ||i.USART_STOPModeCmd||, CODE, READONLY, ALIGN=1

                  USART_STOPModeCmd PROC
;;;753      */
;;;754    void USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;755    {
;;;756      /* Check the parameters */
;;;757      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;758      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;759      
;;;760      if (NewState != DISABLE)
;;;761      {
;;;762        /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
;;;763           register */
;;;764        USARTx->CR1 |= USART_CR1_UESM;
;;;765      }
;;;766      else
;;;767      {
;;;768        /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
;;;769           register */
;;;770        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L35.12|
000006  f0410102          ORR      r1,r1,#2              ;764
00000a  e001              B        |L35.16|
                  |L35.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L35.16|
000010  6001              STR      r1,[r0,#0]            ;764
;;;771      }
;;;772    }
000012  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.USART_SWAPPinCmd||, CODE, READONLY, ALIGN=1

                  USART_SWAPPinCmd PROC
;;;628      */
;;;629    void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;630    {
;;;631      /* Check the parameters */
;;;632      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;633      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;634    
;;;635      if (NewState != DISABLE)
;;;636      {
;;;637        /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
;;;638        USARTx->CR2 |= USART_CR2_SWAP;
;;;639      }
;;;640      else
;;;641      {
;;;642        /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
;;;643        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L36.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;638
00000a  e001              B        |L36.16|
                  |L36.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L36.16|
000010  6041              STR      r1,[r0,#4]            ;638
;;;644      }
;;;645    }
000012  4770              BX       lr
;;;646    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;914      */
;;;915    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;916    {
;;;917      /* Check the parameters */
;;;918      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;919      assert_param(IS_USART_DATA(Data)); 
;;;920    
;;;921      /* Transmit Data */
;;;922      USARTx->TDR = (Data & (uint16_t)0x01FF);
000004  8501              STRH     r1,[r0,#0x28]
;;;923    }
000006  4770              BX       lr
;;;924    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;980      */
;;;981    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  6842              LDR      r2,[r0,#4]
;;;982    {
;;;983      /* Check the parameters */
;;;984      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;985    
;;;986      /* Clear the USART address */
;;;987      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
000002  f022427f          BIC      r2,r2,#0xff000000
000006  6042              STR      r2,[r0,#4]
;;;988      /* Set the USART address node */
;;;989      USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
000008  6842              LDR      r2,[r0,#4]
00000a  ea426101          ORR      r1,r2,r1,LSL #24
00000e  6041              STR      r1,[r0,#4]
;;;990    }
000010  4770              BX       lr
;;;991    
                          ENDP


                          AREA ||i.USART_SetAutoRetryCount||, CODE, READONLY, ALIGN=1

                  USART_SetAutoRetryCount PROC
;;;1337     */
;;;1338   void USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount)
000000  6882              LDR      r2,[r0,#8]
;;;1339   {    
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_USART_123_PERIPH(USARTx));
;;;1342     assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
;;;1343     /* Clear the USART auto retry count */
;;;1344     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
000002  f4222260          BIC      r2,r2,#0xe0000
000006  6082              STR      r2,[r0,#8]
;;;1345     /* Set the USART auto retry count*/
;;;1346     USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
000008  6882              LDR      r2,[r0,#8]
00000a  ea424141          ORR      r1,r2,r1,LSL #17
00000e  6081              STR      r1,[r0,#8]
;;;1347   }
000010  4770              BX       lr
;;;1348   
                          ENDP


                          AREA ||i.USART_SetBlockLength||, CODE, READONLY, ALIGN=1

                  USART_SetBlockLength PROC
;;;1355     */
;;;1356   void USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength)
000000  6942              LDR      r2,[r0,#0x14]
;;;1357   {    
;;;1358     /* Check the parameters */
;;;1359     assert_param(IS_USART_123_PERIPH(USARTx));
;;;1360   
;;;1361     /* Clear the Smart card block length */
;;;1362     USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
000002  f022427f          BIC      r2,r2,#0xff000000
000006  6142              STR      r2,[r0,#0x14]
;;;1363     /* Set the Smart Card block length */
;;;1364     USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
000008  6942              LDR      r2,[r0,#0x14]
00000a  ea426101          ORR      r1,r2,r1,LSL #24
00000e  6141              STR      r1,[r0,#0x14]
;;;1365   }
000010  4770              BX       lr
;;;1366   
                          ENDP


                          AREA ||i.USART_SetDEAssertionTime||, CODE, READONLY, ALIGN=1

                  USART_SetDEAssertionTime PROC
;;;1539     */
;;;1540   void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
000000  6802              LDR      r2,[r0,#0]
;;;1541   {
;;;1542     /* Check the parameters */
;;;1543     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1544     assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
;;;1545   
;;;1546     /* Clear the DE assertion time */
;;;1547     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
000002  f0227278          BIC      r2,r2,#0x3e00000
000006  6002              STR      r2,[r0,#0]
;;;1548     /* Set the new value for the DE assertion time */
;;;1549     USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
000008  6802              LDR      r2,[r0,#0]
00000a  ea425141          ORR      r1,r2,r1,LSL #21
00000e  6001              STR      r1,[r0,#0]
;;;1550   }
000010  4770              BX       lr
;;;1551   
                          ENDP


                          AREA ||i.USART_SetDEDeassertionTime||, CODE, READONLY, ALIGN=1

                  USART_SetDEDeassertionTime PROC
;;;1559     */
;;;1560   void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
000000  6802              LDR      r2,[r0,#0]
;;;1561   {
;;;1562     /* Check the parameters */
;;;1563     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1564     assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
;;;1565   
;;;1566     /* Clear the DE deassertion time */
;;;1567     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
000002  f42212f8          BIC      r2,r2,#0x1f0000
000006  6002              STR      r2,[r0,#0]
;;;1568     /* Set the new value for the DE deassertion time */
;;;1569     USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
000008  6802              LDR      r2,[r0,#0]
00000a  ea424101          ORR      r1,r2,r1,LSL #16
00000e  6001              STR      r1,[r0,#0]
;;;1570   }
000010  4770              BX       lr
;;;1571   
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;1269     */
;;;1270   void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;1271   {    
;;;1272     /* Check the parameters */
;;;1273     assert_param(IS_USART_123_PERIPH(USARTx));
;;;1274   
;;;1275     /* Clear the USART Guard time */
;;;1276     USARTx->GTPR &= USART_GTPR_PSC;
000002  b2d2              UXTB     r2,r2
000004  8202              STRH     r2,[r0,#0x10]
;;;1277     /* Set the USART guard time */
;;;1278     USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8a02              LDRH     r2,[r0,#0x10]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8201              STRH     r1,[r0,#0x10]
;;;1279   }
00000e  4770              BX       lr
;;;1280   
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;704      */
;;;705    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;706    {
;;;707      /* Check the parameters */
;;;708      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;709    
;;;710      /* Clear the USART prescaler */
;;;711      USARTx->GTPR &= USART_GTPR_GT;
000002  f402427f          AND      r2,r2,#0xff00
000006  8202              STRH     r2,[r0,#0x10]
;;;712      /* Set the USART prescaler */
;;;713      USARTx->GTPR |= USART_Prescaler;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;714    }
00000e  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.USART_SetReceiverTimeOut||, CODE, READONLY, ALIGN=1

                  USART_SetReceiverTimeOut PROC
;;;681      */
;;;682    void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
000000  6942              LDR      r2,[r0,#0x14]
;;;683    {    
;;;684      /* Check the parameters */
;;;685      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;686      assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
;;;687    
;;;688      /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
;;;689         register  */
;;;690      USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
000002  f002427f          AND      r2,r2,#0xff000000
000006  6142              STR      r2,[r0,#0x14]
;;;691      /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
;;;692         register  */
;;;693      USARTx->RTOR |= USART_ReceiverTimeOut;
000008  6942              LDR      r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  6142              STR      r2,[r0,#0x14]
;;;694    }
00000e  4770              BX       lr
;;;695    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;1288     */
;;;1289   void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1290   {
;;;1291     /* Check the parameters */
;;;1292     assert_param(IS_USART_123_PERIPH(USARTx));
;;;1293     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1294     if (NewState != DISABLE)
;;;1295     {
;;;1296       /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;1297       USARTx->CR3 |= USART_CR3_SCEN;
;;;1298     }
;;;1299     else
;;;1300     {
;;;1301       /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;1302       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L46.12|
000006  f0410120          ORR      r1,r1,#0x20           ;1297
00000a  e001              B        |L46.16|
                  |L46.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L46.16|
000010  6081              STR      r1,[r0,#8]            ;1297
;;;1303     }
;;;1304   }
000012  4770              BX       lr
;;;1305   
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;1313     */
;;;1314   void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1315   {
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_USART_123_PERIPH(USARTx)); 
;;;1318     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1319     if (NewState != DISABLE)
;;;1320     {
;;;1321       /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;1322       USARTx->CR3 |= USART_CR3_NACK;
;;;1323     }
;;;1324     else
;;;1325     {
;;;1326       /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;1327       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L47.12|
000006  f0410110          ORR      r1,r1,#0x10           ;1322
00000a  e001              B        |L47.16|
                  |L47.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L47.16|
000010  6081              STR      r1,[r0,#8]            ;1322
;;;1328     }
;;;1329   }
000012  4770              BX       lr
;;;1330   
                          ENDP


                          AREA ||i.USART_StopModeWakeUpSourceConfig||, CODE, READONLY, ALIGN=1

                  USART_StopModeWakeUpSourceConfig PROC
;;;786      */
;;;787    void USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource)
000000  6882              LDR      r2,[r0,#8]
;;;788    {
;;;789      /* Check the parameters */
;;;790      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;791      assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));
;;;792    
;;;793      USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
000002  f4221240          BIC      r2,r2,#0x300000
000006  6082              STR      r2,[r0,#8]
;;;794      USARTx->CR3 |= USART_WakeUpSource;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;795    }
00000e  4770              BX       lr
;;;796    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;337      */
;;;338    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;339    {
;;;340      /* USART_InitStruct members default value */
;;;341      USART_InitStruct->USART_BaudRate = 9600;
;;;342      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
;;;343      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000008  6041              STR      r1,[r0,#4]
;;;344      USART_InitStruct->USART_Parity = USART_Parity_No ;
;;;345      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000a  220c              MOVS     r2,#0xc
00000c  6081              STR      r1,[r0,#8]
00000e  e9c01203          STRD     r1,r2,[r0,#0xc]
;;;346      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000012  6141              STR      r1,[r0,#0x14]
;;;347    }
000014  4770              BX       lr
;;;348    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f30x_usart_c_9565154b____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f30x_usart_c_9565154b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f30x_usart_c_9565154b____REVSH|
#line 128
|__asm___17_stm32f30x_usart_c_9565154b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
