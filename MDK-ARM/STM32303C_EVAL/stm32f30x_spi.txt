; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_spi.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_spi.c]
                          THUMB

                          AREA ||i.I2S_Cmd||, CODE, READONLY, ALIGN=1

                  I2S_Cmd PROC
;;;549      */
;;;550    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;551    {
;;;552      /* Check the parameters */
;;;553      assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
;;;554      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;555      if (NewState != DISABLE)
;;;556      {
;;;557        /* Enable the selected SPI peripheral in I2S mode */
;;;558        SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
;;;559      }
;;;560      else
;;;561      {
;;;562        /* Disable the selected SPI peripheral in I2S mode */
;;;563        SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
000002  8b81              LDRH     r1,[r0,#0x1c]
000004  d002              BEQ      |L1.12|
000006  f4416180          ORR      r1,r1,#0x400          ;558
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L1.16|
000010  8381              STRH     r1,[r0,#0x1c]         ;558
;;;564      }
;;;565    }
000012  4770              BX       lr
;;;566    
                          ENDP


                          AREA ||i.I2S_FullDuplexConfig||, CODE, READONLY, ALIGN=1

                  I2S_FullDuplexConfig PROC
;;;700      */
;;;701    void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;702    {
;;;703      uint16_t tmpreg = 0, tmp = 0;
;;;704      
;;;705      /* Check the I2S parameters */
;;;706      assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
;;;707      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;708      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;709      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;710      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;711    
;;;712    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;713      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;714      I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
000002  8b83              LDRH     r3,[r0,#0x1c]
000004  2200              MOVS     r2,#0                 ;703
000006  f24f0440          MOV      r4,#0xf040
00000a  4023              ANDS     r3,r3,r4
00000c  8383              STRH     r3,[r0,#0x1c]
;;;715      I2Sxext->I2SPR = 0x0002;
00000e  2302              MOVS     r3,#2
000010  8403              STRH     r3,[r0,#0x20]
;;;716      
;;;717      /* Get the I2SCFGR register value */
;;;718      tmpreg = I2Sxext->I2SCFGR;
000012  8b84              LDRH     r4,[r0,#0x1c]
;;;719      
;;;720      /* Get the mode to be configured for the extended I2S */
;;;721      if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
000014  880b              LDRH     r3,[r1,#0]
;;;722      {
;;;723        tmp = I2S_Mode_SlaveRx;
000016  f44f7580          MOV      r5,#0x100
00001a  f5b37f00          CMP      r3,#0x200             ;721
00001e  d000              BEQ      |L2.34|
000020  b903              CBNZ     r3,|L2.36|
                  |L2.34|
000022  462a              MOV      r2,r5
                  |L2.36|
;;;724      }
;;;725      else
;;;726      {
;;;727        if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
;;;728        {
;;;729          tmp = I2S_Mode_SlaveTx;
;;;730        }
;;;731      }
;;;732    
;;;733     
;;;734      /* Configure the I2S with the SPI_InitStruct values */
;;;735      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
000024  884b              LDRH     r3,[r1,#2]
000026  888d              LDRH     r5,[r1,#4]
000028  8989              LDRH     r1,[r1,#0xc]
00002a  432b              ORRS     r3,r3,r5
00002c  4311              ORRS     r1,r1,r2
00002e  430b              ORRS     r3,r3,r1
000030  4323              ORRS     r3,r3,r4
000032  f4436100          ORR      r1,r3,#0x800
;;;736                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;737                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;738     
;;;739      /* Write to SPIx I2SCFGR */  
;;;740      I2Sxext->I2SCFGR = tmpreg;
000036  8381              STRH     r1,[r0,#0x1c]
;;;741    }
000038  bd30              POP      {r4,r5,pc}
;;;742    
                          ENDP


                          AREA ||i.I2S_Init||, CODE, READONLY, ALIGN=2

                  I2S_Init PROC
;;;390      */
;;;391    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;392    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;393      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
000006  2002              MOVS     r0,#2
000008  2100              MOVS     r1,#0
;;;394      uint32_t tmp = 0;
;;;395      RCC_ClocksTypeDef RCC_Clocks;
;;;396      uint32_t sourceclock = 0;
;;;397    
;;;398      /* Check the I2S parameters */
;;;399      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;400      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;401      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;402      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;403      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
;;;404      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
;;;405      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;406    
;;;407    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;408      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;409      SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
00000a  8baa              LDRH     r2,[r5,#0x1c]
00000c  b08f              SUB      sp,sp,#0x3c           ;392
00000e  2601              MOVS     r6,#1                 ;393
000010  f24f0340          MOV      r3,#0xf040
000014  401a              ANDS     r2,r2,r3
000016  83aa              STRH     r2,[r5,#0x1c]
;;;410      SPIx->I2SPR = 0x0002;
000018  8428              STRH     r0,[r5,#0x20]
;;;411    
;;;412      /* Get the I2SCFGR register value */
;;;413      tmpreg = SPIx->I2SCFGR;
00001a  8baf              LDRH     r7,[r5,#0x1c]
;;;414    
;;;415      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;416      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
00001c  68a2              LDR      r2,[r4,#8]
00001e  2a02              CMP      r2,#2
000020  d027              BEQ      |L3.114|
;;;417      {
;;;418        i2sodd = (uint16_t)0;
;;;419        i2sdiv = (uint16_t)2;   
;;;420      }
;;;421      /* If the requested audio frequency is not the default, compute the prescaler */
;;;422      else
;;;423      {
;;;424        /* Check the frame length (For the Prescaler computing) */
;;;425        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
000022  88a0              LDRH     r0,[r4,#4]
000024  b100              CBZ      r0,|L3.40|
;;;426        {
;;;427          /* Packet length is 16 bits */
;;;428          packetlength = 1;
;;;429        }
;;;430        else
;;;431        {
;;;432          /* Packet length is 32 bits */
;;;433          packetlength = 2;
000026  2602              MOVS     r6,#2
                  |L3.40|
;;;434        }
;;;435    
;;;436        /* I2S Clock source is System clock: Get System Clock frequency */
;;;437        RCC_GetClocksFreq(&RCC_Clocks);      
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       RCC_GetClocksFreq
;;;438    
;;;439        /* Get the source clock value: based on System Clock value */
;;;440        sourceclock = RCC_Clocks.SYSCLK_Frequency;    
;;;441    
;;;442        /* Compute the Real divider depending on the MCLK output state with a floating point */
;;;443        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
00002e  88e1              LDRH     r1,[r4,#6]
000030  9800              LDR      r0,[sp,#0]
000032  f5b17f00          CMP      r1,#0x200
000036  d02d              BEQ      |L3.148|
;;;444        {
;;;445          /* MCLK output is enabled */
;;;446          tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
;;;447        }
;;;448        else
;;;449        {
;;;450          /* MCLK output is disabled */
;;;451          tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
000038  0171              LSLS     r1,r6,#5
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  bf00              NOP      
                  |L3.64|
000040  eb000080          ADD      r0,r0,r0,LSL #2
000044  68a1              LDR      r1,[r4,#8]
000046  0040              LSLS     r0,r0,#1
000048  fbb0f0f1          UDIV     r0,r0,r1
00004c  1d40              ADDS     r0,r0,#5
00004e  b280              UXTH     r0,r0
;;;452        }
;;;453        
;;;454        /* Remove the floating point */
;;;455        tmp = tmp / 10;
000050  210a              MOVS     r1,#0xa
000052  fbb0f0f1          UDIV     r0,r0,r1
;;;456    
;;;457        /* Check the parity of the divider */
;;;458        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
000056  f0000101          AND      r1,r0,#1
;;;459    
;;;460        /* Compute the i2sdiv prescaler */
;;;461        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
00005a  1a40              SUBS     r0,r0,r1
;;;462    
;;;463        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;464        i2sodd = (uint16_t) (i2sodd << 8);
00005c  f64f72ff          MOV      r2,#0xffff
000060  f3c0004f          UBFX     r0,r0,#1,#16          ;461
000064  ea022101          AND      r1,r2,r1,LSL #8
;;;465      }
;;;466    
;;;467      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;468      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
000068  1e82              SUBS     r2,r0,#2
00006a  2afe              CMP      r2,#0xfe
00006c  d301              BCC      |L3.114|
;;;469      {
;;;470        /* Set the default values */
;;;471        i2sdiv = 2;
00006e  2002              MOVS     r0,#2
;;;472        i2sodd = 0;
000070  2100              MOVS     r1,#0
                  |L3.114|
;;;473      }
;;;474    
;;;475      /* Write to SPIx I2SPR register the computed value */
;;;476      SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
000072  88e2              LDRH     r2,[r4,#6]
000074  4308              ORRS     r0,r0,r1
000076  4302              ORRS     r2,r2,r0
000078  842a              STRH     r2,[r5,#0x20]
;;;477    
;;;478      /* Configure the I2S with the SPI_InitStruct values */
;;;479      tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
00007a  8820              LDRH     r0,[r4,#0]
00007c  8861              LDRH     r1,[r4,#2]
00007e  89a2              LDRH     r2,[r4,#0xc]
000080  4308              ORRS     r0,r0,r1
000082  88a1              LDRH     r1,[r4,#4]
000084  4311              ORRS     r1,r1,r2
000086  4308              ORRS     r0,r0,r1
000088  4338              ORRS     r0,r0,r7
00008a  f4406000          ORR      r0,r0,#0x800
;;;480                           (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
;;;481                           I2S_InitStruct->I2S_CPOL)));
;;;482    
;;;483      /* Write to SPIx I2SCFGR */
;;;484      SPIx->I2SCFGR = tmpreg;
00008e  83a8              STRH     r0,[r5,#0x1c]
;;;485    }
000090  b00f              ADD      sp,sp,#0x3c
000092  bdf0              POP      {r4-r7,pc}
                  |L3.148|
000094  0a00              LSRS     r0,r0,#8              ;446
000096  e7d3              B        |L3.64|
;;;486    
                          ENDP


                          AREA ||i.I2S_StructInit||, CODE, READONLY, ALIGN=1

                  I2S_StructInit PROC
;;;353      */
;;;354    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
000000  2100              MOVS     r1,#0
;;;355    {
;;;356    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;357      /* Initialize the I2S_Mode member */
;;;358      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
000002  8001              STRH     r1,[r0,#0]
;;;359    
;;;360      /* Initialize the I2S_Standard member */
;;;361      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
000004  8041              STRH     r1,[r0,#2]
;;;362    
;;;363      /* Initialize the I2S_DataFormat member */
;;;364      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
000006  8081              STRH     r1,[r0,#4]
;;;365    
;;;366      /* Initialize the I2S_MCLKOutput member */
;;;367      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;368    
;;;369      /* Initialize the I2S_AudioFreq member */
;;;370      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
00000a  2202              MOVS     r2,#2
;;;371    
;;;372      /* Initialize the I2S_CPOL member */
;;;373      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
00000c  6082              STR      r2,[r0,#8]
00000e  8181              STRH     r1,[r0,#0xc]
;;;374    }
000010  4770              BX       lr
;;;375    
                          ENDP


                          AREA ||i.SPI_BiDirectionalLineConfig||, CODE, READONLY, ALIGN=1

                  SPI_BiDirectionalLineConfig PROC
;;;635      */
;;;636    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
000000  f5b14f80          CMP      r1,#0x4000
;;;637    {
;;;638      /* Check the parameters */
;;;639      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;640      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;641      if (SPI_Direction == SPI_Direction_Tx)
;;;642      {
;;;643        /* Set the Tx only mode */
;;;644        SPIx->CR1 |= SPI_Direction_Tx;
;;;645      }
;;;646      else
;;;647      {
;;;648        /* Set the Rx only mode */
;;;649        SPIx->CR1 &= SPI_Direction_Rx;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L5.16|
000008  f4214180          BIC      r1,r1,#0x4000
                  |L5.12|
00000c  8001              STRH     r1,[r0,#0]            ;644
;;;650      }
;;;651    }
00000e  4770              BX       lr
                  |L5.16|
000010  f4414180          ORR      r1,r1,#0x4000         ;644
000014  e7fa              B        |L5.12|
;;;652    
                          ENDP


                          AREA ||i.SPI_CRCLengthConfig||, CODE, READONLY, ALIGN=1

                  SPI_CRCLengthConfig PROC
;;;963      */
;;;964    void SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength)
000000  8802              LDRH     r2,[r0,#0]
;;;965    {
;;;966      /* Check the parameters */
;;;967      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;968      assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));
;;;969    
;;;970      /* Clear CRCL bit */
;;;971      SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
000002  f4226200          BIC      r2,r2,#0x800
000006  8002              STRH     r2,[r0,#0]
;;;972    
;;;973      /* Set new CRCL bit value */
;;;974      SPIx->CR1 |= SPI_CRCLength;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;975    }
00000e  4770              BX       lr
;;;976    
                          ENDP


                          AREA ||i.SPI_CalculateCRC||, CODE, READONLY, ALIGN=1

                  SPI_CalculateCRC PROC
;;;983      */
;;;984    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;985    {
;;;986      /* Check the parameters */
;;;987      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;988      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;989    
;;;990      if (NewState != DISABLE)
;;;991      {
;;;992        /* Enable the selected SPI CRC calculation */
;;;993        SPIx->CR1 |= SPI_CR1_CRCEN;
;;;994      }
;;;995      else
;;;996      {
;;;997        /* Disable the selected SPI CRC calculation */
;;;998        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;993
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;993
;;;999      }
;;;1000   }
000012  4770              BX       lr
;;;1001   
                          ENDP


                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=1

                  SPI_Cmd PROC
;;;493      */
;;;494    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;495    {
;;;496      /* Check the parameters */
;;;497      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;498      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;499    
;;;500      if (NewState != DISABLE)
;;;501      {
;;;502        /* Enable the selected SPI peripheral */
;;;503        SPIx->CR1 |= SPI_CR1_SPE;
;;;504      }
;;;505      else
;;;506      {
;;;507        /* Disable the selected SPI peripheral */
;;;508        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L8.12|
000006  f0410140          ORR      r1,r1,#0x40           ;503
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L8.16|
000010  8001              STRH     r1,[r0,#0]            ;503
;;;509      }
;;;510    }
000012  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=1

                  SPI_DataSizeConfig PROC
;;;586      */
;;;587    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000000  8882              LDRH     r2,[r0,#4]
;;;588    {
;;;589      uint16_t tmpreg = 0;
;;;590      
;;;591      /* Check the parameters */
;;;592      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;593      assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
;;;594      /* Read the CR2 register */
;;;595      tmpreg = SPIx->CR2;
;;;596      /* Clear DS[3:0] bits */
;;;597      tmpreg &= (uint16_t)~SPI_CR2_DS;
000002  f4226270          BIC      r2,r2,#0xf00
;;;598      /* Set new DS[3:0] bits value */
;;;599      tmpreg |= SPI_DataSize;
000006  430a              ORRS     r2,r2,r1
;;;600      SPIx->CR2 = tmpreg;
000008  8082              STRH     r2,[r0,#4]
;;;601    }
00000a  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.SPI_GetCRC||, CODE, READONLY, ALIGN=1

                  SPI_GetCRC PROC
;;;1024     */
;;;1025   uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000000  2901              CMP      r1,#1
;;;1026   {
000002  d001              BEQ      |L10.8|
;;;1027     uint16_t crcreg = 0;
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1030     assert_param(IS_SPI_CRC(SPI_CRC));
;;;1031   
;;;1032     if (SPI_CRC != SPI_CRC_Rx)
;;;1033     {
;;;1034       /* Get the Tx CRC register */
;;;1035       crcreg = SPIx->TXCRCR;
000004  8b00              LDRH     r0,[r0,#0x18]
;;;1036     }
;;;1037     else
;;;1038     {
;;;1039       /* Get the Rx CRC register */
;;;1040       crcreg = SPIx->RXCRCR;
;;;1041     }
;;;1042     /* Return the selected CRC register */
;;;1043     return crcreg;
;;;1044   }
000006  4770              BX       lr
                  |L10.8|
000008  8a80              LDRH     r0,[r0,#0x14]         ;1040
00000a  4770              BX       lr
;;;1045   
                          ENDP


                          AREA ||i.SPI_GetCRCPolynomial||, CODE, READONLY, ALIGN=1

                  SPI_GetCRCPolynomial PROC
;;;1050     */
;;;1051   uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;1052   {
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1055   
;;;1056     /* Return the CRC polynomial register */
;;;1057     return SPIx->CRCPR;
;;;1058   }
000002  4770              BX       lr
;;;1059   
                          ENDP


                          AREA ||i.SPI_GetReceptionFIFOStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetReceptionFIFOStatus PROC
;;;1274     */
;;;1275   uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
000000  8900              LDRH     r0,[r0,#8]
;;;1276   {
;;;1277     /* Get the SPIx Reception FIFO level bits */
;;;1278     return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
000002  f40060c0          AND      r0,r0,#0x600
;;;1279   }
000006  4770              BX       lr
;;;1280   
                          ENDP


                          AREA ||i.SPI_GetTransmissionFIFOStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetTransmissionFIFOStatus PROC
;;;1259     */
;;;1260   uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
000000  8900              LDRH     r0,[r0,#8]
;;;1261   {
;;;1262     /* Get the SPIx Transmission FIFO level bits */
;;;1263     return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
000002  f40050c0          AND      r0,r0,#0x1800
;;;1264   }
000006  4770              BX       lr
;;;1265   
                          ENDP


                          AREA ||i.SPI_I2S_ClearFlag||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ClearFlag PROC
;;;1333     */
;;;1334   void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  43c9              MVNS     r1,r1
;;;1335   {
;;;1336     /* Check the parameters */
;;;1337     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1338     assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));
;;;1339   
;;;1340     /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;1341     SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
000002  8101              STRH     r1,[r0,#8]
;;;1342   }
000004  4770              BX       lr
;;;1343   
                          ENDP


                          AREA ||i.SPI_I2S_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_I2S_DMACmd PROC
;;;1087     */
;;;1088   void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1089   {
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1092     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1093     assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));
;;;1094   
;;;1095     if (NewState != DISABLE)
;;;1096     {
;;;1097       /* Enable the selected SPI DMA requests */
;;;1098       SPIx->CR2 |= SPI_I2S_DMAReq;
;;;1099     }
;;;1100     else
;;;1101     {
;;;1102       /* Disable the selected SPI DMA requests */
;;;1103       SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L15.10|
000006  430a              ORRS     r2,r2,r1              ;1098
000008  e000              B        |L15.12|
                  |L15.10|
00000a  438a              BICS     r2,r2,r1
                  |L15.12|
00000c  8082              STRH     r2,[r0,#4]            ;1098
;;;1104     }
;;;1105   }
00000e  4770              BX       lr
;;;1106   
                          ENDP


                          AREA ||i.SPI_I2S_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;189      */
;;;190    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  4911              LDR      r1,|L16.72|
;;;191    {
000002  b510              PUSH     {r4,lr}
;;;192      /* Check the parameters */
;;;193      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;194    
;;;195      if (SPIx == SPI1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L16.30|
;;;196      {
;;;197        /* Enable SPI1 reset state */
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
000008  1484              ASRS     r4,r0,#18
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;199        /* Release SPI1 from reset state */
;;;200        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L16.30|
;;;201      }
;;;202      else if (SPIx == SPI2)
00001e  490b              LDR      r1,|L16.76|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L16.42|
;;;203      {
;;;204        /* Enable SPI2 reset state */
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
000024  2101              MOVS     r1,#1
000026  1404              ASRS     r4,r0,#16
;;;206        /* Release SPI2 from reset state */
;;;207        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
000028  e004              B        |L16.52|
                  |L16.42|
;;;208      }
;;;209      else
;;;210      {
;;;211        if (SPIx == SPI3)
00002a  4909              LDR      r1,|L16.80|
00002c  4288              CMP      r0,r1
00002e  d10a              BNE      |L16.70|
;;;212        {
;;;213          /* Enable SPI3 reset state */
;;;214          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
000030  2101              MOVS     r1,#1
000032  13c4              ASRS     r4,r0,#15
                  |L16.52|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;215          /* Release SPI3 from reset state */
;;;216          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
00003a  4620              MOV      r0,r4
00003c  e8bd4010          POP      {r4,lr}
000040  2100              MOVS     r1,#0
000042  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L16.70|
;;;217        }
;;;218      }
;;;219    }
000046  bd10              POP      {r4,pc}
;;;220    
                          ENDP

                  |L16.72|
                          DCD      0x40013000
                  |L16.76|
                          DCD      0x40003800
                  |L16.80|
                          DCD      0x40003c00

                          AREA ||i.SPI_I2S_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetFlagStatus PROC
;;;1297     */
;;;1298   FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  4602              MOV      r2,r0
;;;1299   {
;;;1300     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1301     /* Check the parameters */
;;;1302     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1303     assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;1304   
;;;1305     /* Check the status of the specified SPI flag */
;;;1306     if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
000004  8912              LDRH     r2,[r2,#8]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L17.12|
;;;1307     {
;;;1308       /* SPI_I2S_FLAG is set */
;;;1309       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L17.12|
;;;1310     }
;;;1311     else
;;;1312     {
;;;1313       /* SPI_I2S_FLAG is reset */
;;;1314       bitstatus = RESET;
;;;1315     }
;;;1316     /* Return the SPI_I2S_FLAG status */
;;;1317     return  bitstatus;
;;;1318   }
00000c  4770              BX       lr
;;;1319   
                          ENDP


                          AREA ||i.SPI_I2S_GetITStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetITStatus PROC
;;;1357     */
;;;1358   ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000000  b510              PUSH     {r4,lr}
;;;1359   {
;;;1360     ITStatus bitstatus = RESET;
;;;1361     uint16_t itpos = 0, itmask = 0, enablestatus = 0;
;;;1362   
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1365     assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;1366   
;;;1367     /* Get the SPI_I2S_IT index */
;;;1368     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
000002  f001040f          AND      r4,r1,#0xf
000006  2201              MOVS     r2,#1
000008  4603              MOV      r3,r0                 ;1359
00000a  fa02f404          LSL      r4,r2,r4
00000e  2000              MOVS     r0,#0                 ;1360
;;;1369   
;;;1370     /* Get the SPI_I2S_IT IT mask */
;;;1371     itmask = SPI_I2S_IT >> 4;
000010  0909              LSRS     r1,r1,#4
;;;1372   
;;;1373     /* Set the IT mask */
;;;1374     itmask = 0x01 << itmask;
000012  408a              LSLS     r2,r2,r1
000014  b291              UXTH     r1,r2
;;;1375   
;;;1376     /* Get the SPI_I2S_IT enable bit status */
;;;1377     enablestatus = (SPIx->CR2 & itmask) ;
000016  889a              LDRH     r2,[r3,#4]
000018  b2a4              UXTH     r4,r4                 ;1368
00001a  400a              ANDS     r2,r2,r1
;;;1378   
;;;1379     /* Check the status of the specified SPI interrupt */
;;;1380     if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
00001c  8919              LDRH     r1,[r3,#8]
00001e  4221              TST      r1,r4
000020  d002              BEQ      |L18.40|
000022  2a00              CMP      r2,#0
000024  d000              BEQ      |L18.40|
;;;1381     {
;;;1382       /* SPI_I2S_IT is set */
;;;1383       bitstatus = SET;
000026  2001              MOVS     r0,#1
                  |L18.40|
;;;1384     }
;;;1385     else
;;;1386     {
;;;1387       /* SPI_I2S_IT is reset */
;;;1388       bitstatus = RESET;
;;;1389     }
;;;1390     /* Return the SPI_I2S_IT status */
;;;1391     return bitstatus;
;;;1392   }
000028  bd10              POP      {r4,pc}
;;;1393   
                          ENDP


                          AREA ||i.SPI_I2S_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ITConfig PROC
;;;1223     */
;;;1224   void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
000000  0909              LSRS     r1,r1,#4
;;;1225   {
;;;1226     uint16_t itpos = 0, itmask = 0 ;
;;;1227   
;;;1228     /* Check the parameters */
;;;1229     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1230     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1231     assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;1232   
;;;1233     /* Get the SPI IT index */
;;;1234     itpos = SPI_I2S_IT >> 4;
;;;1235   
;;;1236     /* Set the IT mask */
;;;1237     itmask = (uint16_t)1 << (uint16_t)itpos;
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
;;;1238   
;;;1239     if (NewState != DISABLE)
000006  2a00              CMP      r2,#0
;;;1240     {
;;;1241       /* Enable the selected SPI interrupt */
;;;1242       SPIx->CR2 |= itmask;
;;;1243     }
;;;1244     else
;;;1245     {
;;;1246       /* Disable the selected SPI interrupt */
;;;1247       SPIx->CR2 &= (uint16_t)~itmask;
000008  8882              LDRH     r2,[r0,#4]
00000a  b299              UXTH     r1,r3                 ;1237
00000c  d001              BEQ      |L19.18|
00000e  430a              ORRS     r2,r2,r1              ;1242
000010  e000              B        |L19.20|
                  |L19.18|
000012  438a              BICS     r2,r2,r1
                  |L19.20|
000014  8082              STRH     r2,[r0,#4]            ;1242
;;;1248     }
;;;1249   }
000016  4770              BX       lr
;;;1250   
                          ENDP


                          AREA ||i.SPI_I2S_ReceiveData16||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ReceiveData16 PROC
;;;881      */
;;;882    uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
000000  8980              LDRH     r0,[r0,#0xc]
;;;883    {  
;;;884      /* Check the parameters */
;;;885      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;886      
;;;887      return SPIx->DR;
;;;888    }
000002  4770              BX       lr
;;;889    /**
                          ENDP


                          AREA ||i.SPI_I2S_SendData16||, CODE, READONLY, ALIGN=1

                  SPI_I2S_SendData16 PROC
;;;849      */
;;;850    void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
000000  8181              STRH     r1,[r0,#0xc]
;;;851    {
;;;852      /* Check the parameters */
;;;853      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;854      
;;;855      SPIx->DR = (uint16_t)Data;
;;;856    }
000002  4770              BX       lr
;;;857    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=1

                  SPI_Init PROC
;;;256      */
;;;257    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;258    {
;;;259      uint16_t tmpreg = 0;
;;;260    
;;;261      /* check the parameters */
;;;262      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;263    
;;;264      /* Check the SPI parameters */
;;;265      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;266      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;267      assert_param(IS_SPI_DATA_SIZE(SPI_InitStruct->SPI_DataSize));
;;;268      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;269      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;270      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;271      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;272      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;273      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;274    
;;;275      /* Configuring the SPI in master mode */
;;;276      if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
000002  884a              LDRH     r2,[r1,#2]
000004  f5b27f82          CMP      r2,#0x104
000008  d01e              BEQ      |L22.72|
;;;277      {
;;;278    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;279        /* Get the SPIx CR1 value */
;;;280        tmpreg = SPIx->CR1;
;;;281        /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;282        tmpreg &= CR1_CLEAR_MASK;
;;;283        /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;284           master/slave mode, CPOL and CPHA */
;;;285        /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;286        /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;287        /* Set LSBFirst bit according to SPI_FirstBit value */
;;;288        /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;289        /* Set CPOL bit according to SPI_CPOL value */
;;;290        /* Set CPHA bit according to SPI_CPHA value */
;;;291        tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
;;;292                             (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
;;;293                             (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
;;;294                             SPI_InitStruct->SPI_FirstBit)));
;;;295        /* Write to SPIx CR1 */
;;;296        SPIx->CR1 = tmpreg;
;;;297        /*-------------------------Data Size Configuration -----------------------*/
;;;298        /* Get the SPIx CR2 value */
;;;299        tmpreg = SPIx->CR2;
;;;300        /* Clear DS[3:0] bits */
;;;301        tmpreg &= (uint16_t)~SPI_CR2_DS;
;;;302        /* Configure SPIx: Data Size */
;;;303        tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
;;;304        /* Write to SPIx CR2 */
;;;305        SPIx->CR2 = tmpreg;
;;;306      }
;;;307      /* Configuring the SPI in slave mode */
;;;308      else
;;;309      {
;;;310    /*---------------------------- Data size Configuration -----------------------*/
;;;311        /* Get the SPIx CR2 value */
;;;312        tmpreg = SPIx->CR2;
00000a  8882              LDRH     r2,[r0,#4]
;;;313        /* Clear DS[3:0] bits */
;;;314        tmpreg &= (uint16_t)~SPI_CR2_DS;
00000c  f4226370          BIC      r3,r2,#0xf00
;;;315        /* Configure SPIx: Data Size */
;;;316        tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
000010  888a              LDRH     r2,[r1,#4]
000012  431a              ORRS     r2,r2,r3
;;;317        /* Write to SPIx CR2 */
;;;318        SPIx->CR2 = tmpreg;
000014  8082              STRH     r2,[r0,#4]
;;;319    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;320        /* Get the SPIx CR1 value */
;;;321        tmpreg = SPIx->CR1;
000016  8802              LDRH     r2,[r0,#0]
;;;322        /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;323        tmpreg &= CR1_CLEAR_MASK;
;;;324        /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;325           master/salve mode, CPOL and CPHA */
;;;326        /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;327        /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;328        /* Set LSBFirst bit according to SPI_FirstBit value */
;;;329        /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;330        /* Set CPOL bit according to SPI_CPOL value */
;;;331        /* Set CPHA bit according to SPI_CPHA value */
;;;332        tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
000018  890c              LDRH     r4,[r1,#8]
00001a  f4025341          AND      r3,r2,#0x3040         ;323
00001e  88ca              LDRH     r2,[r1,#6]
000020  898d              LDRH     r5,[r1,#0xc]
000022  4322              ORRS     r2,r2,r4
000024  894c              LDRH     r4,[r1,#0xa]
000026  432c              ORRS     r4,r4,r5
000028  89cd              LDRH     r5,[r1,#0xe]
00002a  432c              ORRS     r4,r4,r5
00002c  4322              ORRS     r2,r2,r4
00002e  880c              LDRH     r4,[r1,#0]
000030  884d              LDRH     r5,[r1,#2]
000032  432c              ORRS     r4,r4,r5
000034  4322              ORRS     r2,r2,r4
000036  431a              ORRS     r2,r2,r3
;;;333                             (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
;;;334                             (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
;;;335                             SPI_InitStruct->SPI_FirstBit)));
;;;336    
;;;337        /* Write to SPIx CR1 */
;;;338        SPIx->CR1 = tmpreg;
000038  8002              STRH     r2,[r0,#0]
                  |L22.58|
;;;339      }
;;;340    
;;;341      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;342      SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
00003a  8b82              LDRH     r2,[r0,#0x1c]
00003c  f4226200          BIC      r2,r2,#0x800
000040  8382              STRH     r2,[r0,#0x1c]
;;;343    
;;;344    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;345      /* Write to SPIx CRCPOLY */
;;;346      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
000042  8a09              LDRH     r1,[r1,#0x10]
000044  8201              STRH     r1,[r0,#0x10]
;;;347    }
000046  bd30              POP      {r4,r5,pc}
                  |L22.72|
000048  8802              LDRH     r2,[r0,#0]            ;280
00004a  890c              LDRH     r4,[r1,#8]            ;291
00004c  f4025341          AND      r3,r2,#0x3040         ;282
000050  88ca              LDRH     r2,[r1,#6]            ;291
000052  898d              LDRH     r5,[r1,#0xc]          ;291
000054  4322              ORRS     r2,r2,r4              ;291
000056  894c              LDRH     r4,[r1,#0xa]          ;291
000058  432c              ORRS     r4,r4,r5              ;291
00005a  89cd              LDRH     r5,[r1,#0xe]          ;291
00005c  432c              ORRS     r4,r4,r5              ;291
00005e  4322              ORRS     r2,r2,r4              ;291
000060  880c              LDRH     r4,[r1,#0]            ;291
000062  f4447482          ORR      r4,r4,#0x104          ;291
000066  4322              ORRS     r2,r2,r4              ;291
000068  431a              ORRS     r2,r2,r3              ;291
00006a  8002              STRH     r2,[r0,#0]            ;296
00006c  8882              LDRH     r2,[r0,#4]            ;299
00006e  f4226370          BIC      r3,r2,#0xf00          ;301
000072  888a              LDRH     r2,[r1,#4]            ;303
000074  431a              ORRS     r2,r2,r3              ;303
000076  8082              STRH     r2,[r0,#4]            ;305
000078  e7df              B        |L22.58|
;;;348    
                          ENDP


                          AREA ||i.SPI_LastDMATransferCmd||, CODE, READONLY, ALIGN=1

                  SPI_LastDMATransferCmd PROC
;;;1124     */
;;;1125   void SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer)
000000  8882              LDRH     r2,[r0,#4]
;;;1126   {
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1129     assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));
;;;1130   
;;;1131     /* Clear LDMA_TX and LDMA_RX bits */
;;;1132     SPIx->CR2 &= CR2_LDMA_MASK;
000002  f42242c0          BIC      r2,r2,#0x6000
000006  8082              STRH     r2,[r0,#4]
;;;1133   
;;;1134     /* Set new LDMA_TX and LDMA_RX bits value */
;;;1135     SPIx->CR2 |= SPI_LastDMATransfer; 
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;1136   }
00000e  4770              BX       lr
;;;1137   
                          ENDP


                          AREA ||i.SPI_NSSInternalSoftwareConfig||, CODE, READONLY, ALIGN=1

                  SPI_NSSInternalSoftwareConfig PROC
;;;663      */
;;;664    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
000000  f5a1427e          SUB      r2,r1,#0xfe00
;;;665    {
;;;666      /* Check the parameters */
;;;667      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;668      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;669    
;;;670      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
;;;671      {
;;;672        /* Set NSS pin internally by software */
;;;673        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
;;;674      }
;;;675      else
;;;676      {
;;;677        /* Reset NSS pin internally by software */
;;;678        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
000004  8801              LDRH     r1,[r0,#0]
000006  3aff              SUBS     r2,r2,#0xff           ;670
000008  d002              BEQ      |L24.16|
00000a  f4417180          ORR      r1,r1,#0x100          ;673
00000e  e001              B        |L24.20|
                  |L24.16|
000010  f4217180          BIC      r1,r1,#0x100
                  |L24.20|
000014  8001              STRH     r1,[r0,#0]            ;673
;;;679      }
;;;680    }
000016  4770              BX       lr
;;;681    
                          ENDP


                          AREA ||i.SPI_NSSPulseModeCmd||, CODE, READONLY, ALIGN=1

                  SPI_NSSPulseModeCmd PROC
;;;780      */
;;;781    void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;782    {
;;;783      /* Check the parameters */
;;;784      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;785      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;786    
;;;787      if (NewState != DISABLE)
;;;788      {
;;;789        /* Enable the NSS pulse management mode */
;;;790        SPIx->CR2 |= SPI_CR2_NSSP;
;;;791      }
;;;792      else
;;;793      {
;;;794        /* Disable the NSS pulse management mode */
;;;795        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L25.12|
000006  f0410108          ORR      r1,r1,#8              ;790
00000a  e001              B        |L25.16|
                  |L25.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L25.16|
000010  8081              STRH     r1,[r0,#4]            ;790
;;;796      }
;;;797    }
000012  4770              BX       lr
;;;798    
                          ENDP


                          AREA ||i.SPI_ReceiveData8||, CODE, READONLY, ALIGN=1

                  SPI_ReceiveData8 PROC
;;;862      */
;;;863    uint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx)
000000  7b00              LDRB     r0,[r0,#0xc]
;;;864    {
;;;865      uint32_t spixbase = 0x00;
;;;866      
;;;867      /* Check the parameters */
;;;868      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;869      
;;;870      spixbase = (uint32_t)SPIx; 
;;;871      spixbase += 0x0C;
;;;872      
;;;873      return *(__IO uint8_t *) spixbase;
;;;874    }
000002  4770              BX       lr
;;;875    
                          ENDP


                          AREA ||i.SPI_RxFIFOThresholdConfig||, CODE, READONLY, ALIGN=1

                  SPI_RxFIFOThresholdConfig PROC
;;;613      */
;;;614    void SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold)
000000  8882              LDRH     r2,[r0,#4]
;;;615    {
;;;616      /* Check the parameters */
;;;617      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;618      assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));
;;;619    
;;;620      /* Clear FRXTH bit */
;;;621      SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
000002  f4225280          BIC      r2,r2,#0x1000
000006  8082              STRH     r2,[r0,#4]
;;;622    
;;;623      /* Set new FRXTH bit value */
;;;624      SPIx->CR2 |= SPI_RxFIFOThreshold;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;625    }
00000e  4770              BX       lr
;;;626    
                          ENDP


                          AREA ||i.SPI_SSOutputCmd||, CODE, READONLY, ALIGN=1

                  SPI_SSOutputCmd PROC
;;;751      */
;;;752    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;753    {
;;;754      /* Check the parameters */
;;;755      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757      if (NewState != DISABLE)
;;;758      {
;;;759        /* Enable the selected SPI SS output */
;;;760        SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
;;;761      }
;;;762      else
;;;763      {
;;;764        /* Disable the selected SPI SS output */
;;;765        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L28.12|
000006  f0410104          ORR      r1,r1,#4              ;760
00000a  e001              B        |L28.16|
                  |L28.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L28.16|
000010  8081              STRH     r1,[r0,#4]            ;760
;;;766      }
;;;767    }
000012  4770              BX       lr
;;;768    
                          ENDP


                          AREA ||i.SPI_SendData8||, CODE, READONLY, ALIGN=1

                  SPI_SendData8 PROC
;;;829      */
;;;830    void SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data)
000000  7301              STRB     r1,[r0,#0xc]
;;;831    {
;;;832      uint32_t spixbase = 0x00;
;;;833    
;;;834      /* Check the parameters */
;;;835      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;836    
;;;837      spixbase = (uint32_t)SPIx; 
;;;838      spixbase += 0x0C;
;;;839      
;;;840      *(__IO uint8_t *) spixbase = Data;
;;;841    }
000002  4770              BX       lr
;;;842    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;225      */
;;;226    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;227    {
;;;228    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;229      /* Initialize the SPI_Direction member */
;;;230      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000002  8001              STRH     r1,[r0,#0]
;;;231      /* Initialize the SPI_Mode member */
;;;232      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000004  8041              STRH     r1,[r0,#2]
;;;233      /* Initialize the SPI_DataSize member */
;;;234      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000006  f44f62e0          MOV      r2,#0x700
00000a  8082              STRH     r2,[r0,#4]
;;;235      /* Initialize the SPI_CPOL member */
;;;236      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
00000c  80c1              STRH     r1,[r0,#6]
;;;237      /* Initialize the SPI_CPHA member */
;;;238      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
00000e  8101              STRH     r1,[r0,#8]
;;;239      /* Initialize the SPI_NSS member */
;;;240      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
000010  8141              STRH     r1,[r0,#0xa]
;;;241      /* Initialize the SPI_BaudRatePrescaler member */
;;;242      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
000012  8181              STRH     r1,[r0,#0xc]
;;;243      /* Initialize the SPI_FirstBit member */
;;;244      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
000014  81c1              STRH     r1,[r0,#0xe]
;;;245      /* Initialize the SPI_CRCPolynomial member */
;;;246      SPI_InitStruct->SPI_CRCPolynomial = 7;
000016  2107              MOVS     r1,#7
000018  8201              STRH     r1,[r0,#0x10]
;;;247    }
00001a  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.SPI_TIModeCmd||, CODE, READONLY, ALIGN=1

                  SPI_TIModeCmd PROC
;;;523      */
;;;524    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;525    {
;;;526      /* Check the parameters */
;;;527      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529    
;;;530      if (NewState != DISABLE)
;;;531      {
;;;532        /* Enable the TI mode for the selected SPI peripheral */
;;;533        SPIx->CR2 |= SPI_CR2_FRF;
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Disable the TI mode for the selected SPI peripheral */
;;;538        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L31.12|
000006  f0410110          ORR      r1,r1,#0x10           ;533
00000a  e001              B        |L31.16|
                  |L31.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L31.16|
000010  8081              STRH     r1,[r0,#4]            ;533
;;;539      }
;;;540    }
000012  4770              BX       lr
;;;541    
                          ENDP


                          AREA ||i.SPI_TransmitCRC||, CODE, READONLY, ALIGN=1

                  SPI_TransmitCRC PROC
;;;1006     */
;;;1007   void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000000  8801              LDRH     r1,[r0,#0]
;;;1008   {
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1011   
;;;1012     /* Enable the selected SPI CRC transmission */
;;;1013     SPIx->CR1 |= SPI_CR1_CRCNEXT;
000002  f4415180          ORR      r1,r1,#0x1000
000006  8001              STRH     r1,[r0,#0]
;;;1014   }
000008  4770              BX       lr
;;;1015   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_spi_c_2b928927____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f30x_spi_c_2b928927____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_spi_c_2b928927____REVSH|
#line 128
|__asm___15_stm32f30x_spi_c_2b928927____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
