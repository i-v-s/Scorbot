; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_gpio.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_gpio.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_gpio.c]
                          THUMB

                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;120      */
;;;121    void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123      /* Check the parameters */
;;;124      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;125    
;;;126      if(GPIOx == GPIOA)
000002  f1b04f90          CMP      r0,#0x48000000
000006  d005              BEQ      |L1.20|
;;;127      {
;;;128        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;129        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
;;;130      }
;;;131      else if(GPIOx == GPIOB)
000008  4914              LDR      r1,|L1.92|
00000a  4288              CMP      r0,r1
00000c  d105              BNE      |L1.26|
;;;132      {
;;;133        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0204              LSLS     r4,r0,#8
;;;134        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
000012  e019              B        |L1.72|
                  |L1.20|
000014  2101              MOVS     r1,#1                 ;128
000016  044c              LSLS     r4,r1,#17             ;128
000018  e016              B        |L1.72|
                  |L1.26|
;;;135      }
;;;136      else if(GPIOx == GPIOC)
00001a  4911              LDR      r1,|L1.96|
00001c  4288              CMP      r0,r1
00001e  d102              BNE      |L1.38|
;;;137      {
;;;138        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
000020  2101              MOVS     r1,#1
000022  0204              LSLS     r4,r0,#8
;;;139        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
000024  e010              B        |L1.72|
                  |L1.38|
;;;140      }
;;;141      else if(GPIOx == GPIOD)
000026  490f              LDR      r1,|L1.100|
000028  4288              CMP      r0,r1
00002a  d102              BNE      |L1.50|
;;;142      {
;;;143        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  050c              LSLS     r4,r1,#20
;;;144        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
000030  e00a              B        |L1.72|
                  |L1.50|
;;;145      }
;;;146      else if(GPIOx == GPIOE)
000032  490d              LDR      r1,|L1.104|
000034  4288              CMP      r0,r1
000036  d102              BNE      |L1.62|
;;;147      {
;;;148        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
000038  2101              MOVS     r1,#1
00003a  0244              LSLS     r4,r0,#9
;;;149        RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
00003c  e004              B        |L1.72|
                  |L1.62|
;;;150      }
;;;151      else
;;;152      {
;;;153        if(GPIOx == GPIOF)
00003e  490b              LDR      r1,|L1.108|
000040  4288              CMP      r0,r1
000042  d10a              BNE      |L1.90|
;;;154        {
;;;155          RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
000044  2101              MOVS     r1,#1
000046  058c              LSLS     r4,r1,#22
                  |L1.72|
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;156          RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
00004e  4620              MOV      r0,r4
000050  e8bd4010          POP      {r4,lr}
000054  2100              MOVS     r1,#0
000056  f7ffbffe          B.W      RCC_AHBPeriphResetCmd
                  |L1.90|
;;;157        }
;;;158      }
;;;159    }
00005a  bd10              POP      {r4,pc}
;;;160    
                          ENDP

                  |L1.92|
                          DCD      0x48000400
                  |L1.96|
                          DCD      0x48000800
                  |L1.100|
                          DCD      0x48000c00
                  |L1.104|
                          DCD      0x48001000
                  |L1.108|
                          DCD      0x48001400

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;173      */
;;;174    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;175    { 
;;;176      uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
000002  2200              MOVS     r2,#0
;;;177    
;;;178      /* Check the parameters */
;;;179      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;180      assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;181      assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;182      assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
;;;183    
;;;184      /*-------------------------- Configure the port pins -----------------------*/
;;;185      /*-- GPIO Mode Configuration --*/
;;;186      for (pinpos = 0x00; pinpos < 0x10; pinpos++)
;;;187      {
;;;188        pos = ((uint32_t)0x01) << pinpos;
000004  2501              MOVS     r5,#1
;;;189    
;;;190        /* Get the port pins position */
;;;191        currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
;;;192    
;;;193        if (currentpin == pos)
;;;194        {
;;;195          if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
;;;196          {
;;;197            /* Check Speed mode parameters */
;;;198            assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;199    
;;;200            /* Speed mode configuration */
;;;201            GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
000006  2403              MOVS     r4,#3
                  |L2.8|
000008  680e              LDR      r6,[r1,#0]            ;191
00000a  fa05f302          LSL      r3,r5,r2              ;188
00000e  401e              ANDS     r6,r6,r3              ;191
000010  429e              CMP      r6,r3                 ;193
000012  d12d              BNE      |L2.112|
000014  790e              LDRB     r6,[r1,#4]            ;195
000016  2e01              CMP      r6,#1                 ;195
000018  d001              BEQ      |L2.30|
00001a  2e02              CMP      r6,#2                 ;195
00001c  d113              BNE      |L2.70|
                  |L2.30|
00001e  6887              LDR      r7,[r0,#8]
000020  0056              LSLS     r6,r2,#1
000022  fa04fc06          LSL      r12,r4,r6
000026  ea27070c          BIC      r7,r7,r12
00002a  6087              STR      r7,[r0,#8]
;;;202            GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
00002c  794f              LDRB     r7,[r1,#5]
00002e  40b7              LSLS     r7,r7,r6
000030  6886              LDR      r6,[r0,#8]
000032  4337              ORRS     r7,r7,r6
000034  6087              STR      r7,[r0,#8]
;;;203    
;;;204            /* Check Output mode parameters */
;;;205            assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
;;;206    
;;;207            /* Output mode configuration */
;;;208            GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
000036  8886              LDRH     r6,[r0,#4]
000038  439e              BICS     r6,r6,r3
00003a  8086              STRH     r6,[r0,#4]
;;;209            GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
00003c  8886              LDRH     r6,[r0,#4]
00003e  798b              LDRB     r3,[r1,#6]
000040  4093              LSLS     r3,r3,r2
000042  431e              ORRS     r6,r6,r3
000044  8086              STRH     r6,[r0,#4]
                  |L2.70|
;;;210          }
;;;211          
;;;212          GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
000046  6807              LDR      r7,[r0,#0]
000048  0056              LSLS     r6,r2,#1
00004a  fa04f306          LSL      r3,r4,r6
00004e  439f              BICS     r7,r7,r3
000050  6007              STR      r7,[r0,#0]
;;;213    
;;;214          GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
000052  790f              LDRB     r7,[r1,#4]
000054  f8d0c000          LDR      r12,[r0,#0]
000058  40b7              LSLS     r7,r7,r6
00005a  ea47070c          ORR      r7,r7,r12
00005e  6007              STR      r7,[r0,#0]
;;;215    
;;;216          /* Pull-up Pull down resistor configuration */
;;;217          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
000060  68c7              LDR      r7,[r0,#0xc]
000062  439f              BICS     r7,r7,r3
000064  60c7              STR      r7,[r0,#0xc]
;;;218          GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
000066  79cb              LDRB     r3,[r1,#7]
000068  40b3              LSLS     r3,r3,r6
00006a  68c6              LDR      r6,[r0,#0xc]
00006c  4333              ORRS     r3,r3,r6
00006e  60c3              STR      r3,[r0,#0xc]
                  |L2.112|
000070  1c52              ADDS     r2,r2,#1
000072  2a10              CMP      r2,#0x10              ;186
000074  d3c8              BCC      |L2.8|
;;;219        }
;;;220      }
;;;221    }
000076  bdf0              POP      {r4-r7,pc}
;;;222    
                          ENDP


                          AREA ||i.GPIO_PinAFConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinAFConfig PROC
;;;497      */
;;;498    void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
000000  074b              LSLS     r3,r1,#29
;;;499    {
;;;500      uint32_t temp = 0x00;
;;;501      uint32_t temp_2 = 0x00;
;;;502      
;;;503      /* Check the parameters */
;;;504      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;505      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;506      assert_param(IS_GPIO_AF(GPIO_AF));
;;;507      
;;;508      temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
000002  0edb              LSRS     r3,r3,#27
000004  409a              LSLS     r2,r2,r3
;;;509      GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
000006  08c9              LSRS     r1,r1,#3
000008  b510              PUSH     {r4,lr}               ;499
00000a  eb000081          ADD      r0,r0,r1,LSL #2
00000e  6a01              LDR      r1,[r0,#0x20]
000010  240f              MOVS     r4,#0xf
000012  409c              LSLS     r4,r4,r3
000014  43a1              BICS     r1,r1,r4
000016  6201              STR      r1,[r0,#0x20]
;;;510      temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
000018  6a01              LDR      r1,[r0,#0x20]
00001a  4311              ORRS     r1,r1,r2
;;;511      GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
00001c  6201              STR      r1,[r0,#0x20]
;;;512    }
00001e  bd10              POP      {r4,pc}
;;;513    
                          ENDP


                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;249      */
;;;250    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  f4413280          ORR      r2,r1,#0x10000
;;;251    {
;;;252      uint32_t tmp = 0x00010000;
;;;253      
;;;254      /* Check the parameters */
;;;255      assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
;;;256      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;257      
;;;258      tmp |= GPIO_Pin;
;;;259      /* Set LCKK bit */
;;;260      GPIOx->LCKR = tmp;
000004  61c2              STR      r2,[r0,#0x1c]
;;;261      /* Reset LCKK bit */
;;;262      GPIOx->LCKR =  GPIO_Pin;
000006  61c1              STR      r1,[r0,#0x1c]
;;;263      /* Set LCKK bit */
;;;264      GPIOx->LCKR = tmp;
000008  61c2              STR      r2,[r0,#0x1c]
;;;265      /* Read LCKK bit */
;;;266      tmp = GPIOx->LCKR;
00000a  69c1              LDR      r1,[r0,#0x1c]
;;;267      /* Read LCKK bit */
;;;268      tmp = GPIOx->LCKR;
00000c  69c0              LDR      r0,[r0,#0x1c]
;;;269    }
00000e  4770              BX       lr
;;;270    
                          ENDP


                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;319      */
;;;320    uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;321    {
;;;322      /* Check the parameters */
;;;323      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;324    
;;;325      return ((uint16_t)GPIOx->IDR);
;;;326    }
000002  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.GPIO_ReadInputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputDataBit PROC
;;;295      */
;;;296    uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;297    {
;;;298      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;299      
;;;300      /* Check the parameters */
;;;301      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;302      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;303    
;;;304      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L6.12|
;;;305      {
;;;306        bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;307      }
;;;308      else
;;;309      {
;;;310        bitstatus = (uint8_t)Bit_RESET;
;;;311      }
;;;312      return bitstatus;
;;;313    }
00000c  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;360      */
;;;361    uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  8a80              LDRH     r0,[r0,#0x14]
;;;362    {
;;;363      /* Check the parameters */
;;;364      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;365      
;;;366      return ((uint16_t)GPIOx->ODR);
;;;367    }
000002  4770              BX       lr
;;;368    
                          ENDP


                          AREA ||i.GPIO_ReadOutputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputDataBit PROC
;;;336      */
;;;337    uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;338    {
;;;339      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;340    
;;;341      /* Check the parameters */
;;;342      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;343      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;344      
;;;345      if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  8a92              LDRH     r2,[r2,#0x14]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;346      {
;;;347        bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;348      }
;;;349      else
;;;350      {
;;;351        bitstatus = (uint8_t)Bit_RESET;
;;;352      }
;;;353      return bitstatus;
;;;354    }
00000c  4770              BX       lr
;;;355    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;395      */
;;;396    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  8501              STRH     r1,[r0,#0x28]
;;;397    {
;;;398      /* Check the parameters */
;;;399      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;400      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;401      
;;;402      GPIOx->BRR = GPIO_Pin;
;;;403    }
000002  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;377      */
;;;378    void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6181              STR      r1,[r0,#0x18]
;;;379    {
;;;380      /* Check the parameters */
;;;381      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;382      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;383      
;;;384      GPIOx->BSRR = GPIO_Pin;
;;;385    }
000002  4770              BX       lr
;;;386    
                          ENDP


                          AREA ||i.GPIO_StructInit||, CODE, READONLY, ALIGN=1

                  GPIO_StructInit PROC
;;;228      */
;;;229    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;230    {
;;;231      /* Reset GPIO init structure parameters values */
;;;232      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
;;;233      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  7101              STRB     r1,[r0,#4]
;;;234      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
00000a  2202              MOVS     r2,#2
00000c  7142              STRB     r2,[r0,#5]
;;;235      GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
00000e  7181              STRB     r1,[r0,#6]
;;;236      GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
000010  71c1              STRB     r1,[r0,#7]
;;;237    }
000012  4770              BX       lr
;;;238    
                          ENDP


                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;441      */
;;;442    void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
000000  8281              STRH     r1,[r0,#0x14]
;;;443    {
;;;444      /* Check the parameters */
;;;445      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;446      
;;;447      GPIOx->ODR = PortVal;
;;;448    }
000002  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;417      */
;;;418    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
000000  b10a              CBZ      r2,|L13.6|
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;422      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;423      assert_param(IS_GPIO_BIT_ACTION(BitVal));
;;;424      
;;;425      if (BitVal != Bit_RESET)
;;;426      {
;;;427        GPIOx->BSRR = GPIO_Pin;
000002  6181              STR      r1,[r0,#0x18]
;;;428      }
;;;429      else
;;;430      {
;;;431        GPIOx->BRR = GPIO_Pin ;
;;;432      }
;;;433    }
000004  4770              BX       lr
                  |L13.6|
000006  8501              STRH     r1,[r0,#0x28]         ;431
000008  4770              BX       lr
;;;434    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f30x_gpio_c_f8e8e39a____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f30x_gpio_c_f8e8e39a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f30x_gpio_c_f8e8e39a____REVSH|
#line 128
|__asm___16_stm32f30x_gpio_c_f8e8e39a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
