; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32f30x_rcc.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32f30x_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F30X -DUSE_STM32303C_EVAL ..\..\..\Libraries\STM32F30x_StdPeriph_Driver\src\stm32f30x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;1105     */
;;;1106   void RCC_ADCCLKConfig(uint32_t RCC_PLLCLK)
000000  4906              LDR      r1,|L1.28|
;;;1107   {
;;;1108     uint32_t tmp = 0;
;;;1109     
;;;1110     /* Check the parameters */
;;;1111     assert_param(IS_RCC_ADCCLK(RCC_PLLCLK));
;;;1112   
;;;1113     tmp = (RCC_PLLCLK >> 28);
000002  0f02              LSRS     r2,r0,#28
;;;1114     
;;;1115     /* Clears ADCPRE34 bits */
;;;1116     if (tmp != 0)
;;;1117     {
;;;1118       RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE34;
;;;1119     }
;;;1120      /* Clears ADCPRE12 bits */
;;;1121     else
;;;1122     {
;;;1123       RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE12;
000004  6aca              LDR      r2,[r1,#0x2c]
000006  d002              BEQ      |L1.14|
000008  f4225278          BIC      r2,r2,#0x3e00         ;1118
00000c  e001              B        |L1.18|
                  |L1.14|
00000e  f42272f8          BIC      r2,r2,#0x1f0
                  |L1.18|
000012  62ca              STR      r2,[r1,#0x2c]
;;;1124     }
;;;1125     /* Set ADCPRE bits according to RCC_PLLCLK value */
;;;1126     RCC->CFGR2 |= RCC_PLLCLK;
000014  6aca              LDR      r2,[r1,#0x2c]
000016  4302              ORRS     r2,r2,r0
000018  62ca              STR      r2,[r1,#0x2c]
;;;1127   }
00001a  4770              BX       lr
;;;1128   
                          ENDP

                  |L1.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1368     */
;;;1369   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1370   {
;;;1371     /* Check the parameters */
;;;1372     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1373     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1374     
;;;1375     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1376     {
;;;1377       RCC->AHBENR |= RCC_AHBPeriph;
;;;1378     }
;;;1379     else
;;;1380     {
;;;1381       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1377
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6151              STR      r1,[r2,#0x14]         ;1377
;;;1382     }
;;;1383   }
000010  4770              BX       lr
;;;1384   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;1481     */
;;;1482   void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1483   {
;;;1484     /* Check the parameters */
;;;1485     assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
;;;1486     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1487   
;;;1488     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1489     {
;;;1490       RCC->AHBRSTR |= RCC_AHBPeriph;
;;;1491     }
;;;1492     else
;;;1493     {
;;;1494       RCC->AHBRSTR &= ~RCC_AHBPeriph;
000004  6a91              LDR      r1,[r2,#0x28]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1490
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6291              STR      r1,[r2,#0x28]         ;1490
;;;1495     }
;;;1496   }
000010  4770              BX       lr
;;;1497   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1448     */
;;;1449   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1450   {
;;;1451     /* Check the parameters */
;;;1452     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1453     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1454   
;;;1455     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1456     {
;;;1457       RCC->APB1ENR |= RCC_APB1Periph;
;;;1458     }
;;;1459     else
;;;1460     {
;;;1461       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1457
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1457
;;;1462     }
;;;1463   }
000010  4770              BX       lr
;;;1464   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1555     */
;;;1556   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1557   {
;;;1558     /* Check the parameters */
;;;1559     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1560     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1561   
;;;1562     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1563     {
;;;1564       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1565     }
;;;1566     else
;;;1567     {
;;;1568       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1564
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1564
;;;1569     }
;;;1570   }
000010  4770              BX       lr
;;;1571   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1403     */
;;;1404   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1405   {
;;;1406     /* Check the parameters */
;;;1407     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1408     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1409   
;;;1410     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1411     {
;;;1412       RCC->APB2ENR |= RCC_APB2Periph;
;;;1413     }
;;;1414     else
;;;1415     {
;;;1416       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1412
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6191              STR      r1,[r2,#0x18]         ;1412
;;;1417     }
;;;1418   }
000010  4770              BX       lr
;;;1419   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1513     */
;;;1514   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1515   {
;;;1516     /* Check the parameters */
;;;1517     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1518     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1519   
;;;1520     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1521     {
;;;1522       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1523     }
;;;1524     else
;;;1525     {
;;;1526       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;1522
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  60d1              STR      r1,[r2,#0xc]          ;1522
;;;1527     }
;;;1528   }
000010  4770              BX       lr
;;;1529   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;294      */
;;;295    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L8.16|
;;;296    {
;;;297      uint32_t tmpreg = 0;
;;;298      
;;;299      /* Check the parameters */
;;;300      assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
;;;301      
;;;302      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;303      
;;;304      /* Clear HSITRIM[4:0] bits */
;;;305      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;306      
;;;307      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;308      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;309      
;;;310      /* Store the new value */
;;;311      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;312    }
00000e  4770              BX       lr
;;;313    
                          ENDP

                  |L8.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1335     */
;;;1336   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L9.8|
;;;1337   {
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1340     
;;;1341     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1342   }
000004  4770              BX       lr
;;;1343   
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1694     */
;;;1695   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L10.12|
;;;1696   {
;;;1697     /* Set RMVF bit to clear the reset flags */
;;;1698     RCC->CSR |= RCC_CSR_RMVF;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1699   }
00000a  4770              BX       lr
;;;1700   
                          ENDP

                  |L10.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1744     */
;;;1745   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L11.8|
;;;1746   {
;;;1747     /* Check the parameters */
;;;1748     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1749     
;;;1750     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1751        pending bits */
;;;1752     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1753   }
000004  4770              BX       lr
;;;1754   
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;494      */
;;;495    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L12.8|
;;;496    {
;;;497      /* Check the parameters */
;;;498      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;499      
;;;500      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;501    }
000004  4770              BX       lr
;;;502    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;188      */
;;;189    void RCC_DeInit(void)
000000  480f              LDR      r0,|L13.64|
;;;190    {
;;;191      /* Set HSION bit */
;;;192      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;193    
;;;194      /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
;;;195      RCC->CFGR &= (uint32_t)0xF8FFC000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0d              LDR      r2,|L13.68|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;196      
;;;197      /* Reset HSEON, CSSON and PLLON bits */
;;;198      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4a0c              LDR      r2,|L13.72|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;199    
;;;200      /* Reset HSEBYP bit */
;;;201      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;202    
;;;203      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
;;;204      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f42101fe          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;205    
;;;206      /* Reset PREDIV1[3:0] and ADCPRE[13:4] bits */
;;;207      RCC->CFGR2 &= (uint32_t)0xFFFFC000;
00002a  6ac1              LDR      r1,[r0,#0x2c]
00002c  f36f010d          BFC      r1,#0,#14
000030  62c1              STR      r1,[r0,#0x2c]
;;;208    
;;;209      /* Reset USARTSW[1:0], I2CSW and TIMSW bits */
;;;210      RCC->CFGR3 &= (uint32_t)0xF00FCCC;
000032  6b01              LDR      r1,[r0,#0x30]
000034  4a05              LDR      r2,|L13.76|
000036  4011              ANDS     r1,r1,r2
000038  6301              STR      r1,[r0,#0x30]
;;;211      
;;;212      /* Disable all interrupts */
;;;213      RCC->CIR = 0x00000000;
00003a  2100              MOVS     r1,#0
00003c  6081              STR      r1,[r0,#8]
;;;214    }
00003e  4770              BX       lr
;;;215    
                          ENDP

                  |L13.64|
                          DCD      0x40021000
                  |L13.68|
                          DCD      0xf8ffc000
                  |L13.72|
                          DCD      0xfef6ffff
                  |L13.76|
                          DCD      0x0f00fccc

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;794      */
;;;795    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;796    {
;;;797      uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
;;;798      uint32_t apb2presc = 0, ahbpresc = 0;
;;;799      
;;;800      /* Get SYSCLK source -------------------------------------------------------*/
;;;801      tmp = RCC->CFGR & RCC_CFGR_SWS;
000004  498e              LDR      r1,|L14.576|
000006  2200              MOVS     r2,#0                 ;797
000008  684b              LDR      r3,[r1,#4]
;;;802      
;;;803      switch (tmp)
;;;804      {
;;;805        case 0x00:  /* HSI used as system clock */
;;;806          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00000a  4c8e              LDR      r4,|L14.580|
00000c  f013030c          ANDS     r3,r3,#0xc            ;801
000010  d003              BEQ      |L14.26|
000012  2b04              CMP      r3,#4                 ;803
000014  d001              BEQ      |L14.26|
000016  2b08              CMP      r3,#8                 ;803
000018  d001              BEQ      |L14.30|
                  |L14.26|
;;;807          break;
00001a  6004              STR      r4,[r0,#0]
00001c  e012              B        |L14.68|
                  |L14.30|
;;;808        case 0x04:  /* HSE used as system clock */
;;;809          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
;;;810          break;
;;;811        case 0x08:  /* PLL used as system clock */
;;;812          /* Get PLL clock source and multiplication factor ----------------------*/
;;;813          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00001e  684a              LDR      r2,[r1,#4]
;;;814          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000020  684b              LDR      r3,[r1,#4]
000022  f4021270          AND      r2,r2,#0x3c0000       ;813
;;;815          pllmull = ( pllmull >> 18) + 2;
000026  f04f0502          MOV      r5,#2
00002a  f4133f80          TST      r3,#0x10000           ;814
00002e  eb054292          ADD      r2,r5,r2,LSR #18
;;;816          
;;;817          if (pllsource == 0x00)
000032  d039              BEQ      |L14.168|
;;;818          {
;;;819            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;820            pllclk = (HSI_VALUE >> 1) * pllmull;
;;;821          }
;;;822          else
;;;823          {
;;;824            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
000034  6acb              LDR      r3,[r1,#0x2c]
000036  f003030f          AND      r3,r3,#0xf
00003a  1c5b              ADDS     r3,r3,#1
;;;825            /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;826            pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
00003c  fbb4f3f3          UDIV     r3,r4,r3
000040  435a              MULS     r2,r3,r2
                  |L14.66|
;;;827          }
;;;828          RCC_Clocks->SYSCLK_Frequency = pllclk;      
000042  6002              STR      r2,[r0,#0]
                  |L14.68|
;;;829          break;
;;;830        default: /* HSI used as system clock */
;;;831          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;832          break;
;;;833      }
;;;834        /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
;;;835      /* Get HCLK prescaler */
;;;836      tmp = RCC->CFGR & RCC_CFGR_HPRE;
000044  468a              MOV      r10,r1
000046  4688              MOV      r8,r1
000048  6849              LDR      r1,[r1,#4]
;;;837      tmp = tmp >> 4;
;;;838      ahbpresc = APBAHBPrescTable[tmp]; 
;;;839      /* HCLK clock frequency */
;;;840      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
;;;841    
;;;842      /* Get PCLK1 prescaler */
;;;843      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;844      tmp = tmp >> 8;
;;;845      presc = APBAHBPrescTable[tmp];
;;;846      /* PCLK1 clock frequency */
;;;847      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;848      
;;;849      /* Get PCLK2 prescaler */
;;;850      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;851      tmp = tmp >> 11;
;;;852      apb2presc = APBAHBPrescTable[tmp];
;;;853      /* PCLK2 clock frequency */
;;;854      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> apb2presc;
;;;855      
;;;856      /* Get ADC12CLK prescaler */
;;;857      tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE12;
;;;858      tmp = tmp >> 4;
;;;859      presc = ADCPrescTable[tmp];
;;;860      if ((presc & 0x10) != 0)
;;;861      {
;;;862         /* ADC12CLK clock frequency is derived from PLL clock */
;;;863         RCC_Clocks->ADC12CLK_Frequency = pllclk / presc;
;;;864      }
;;;865      else
;;;866      {
;;;867       /* ADC12CLK clock frequency is AHB clock */
;;;868         RCC_Clocks->ADC12CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;869      }
;;;870      
;;;871      /* Get ADC34CLK prescaler */
;;;872      tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE34;
;;;873      tmp = tmp >> 9;
;;;874      presc = ADCPrescTable[tmp];
;;;875      if ((presc & 0x10) != 0)
;;;876      {
;;;877         /* ADC34CLK clock frequency is derived from PLL clock */
;;;878         RCC_Clocks->ADC34CLK_Frequency = pllclk / presc;
;;;879      }
;;;880      else
;;;881      {
;;;882       /* ADC34CLK clock frequency is AHB clock */
;;;883         RCC_Clocks->ADC34CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;884      }
;;;885    
;;;886      /* I2C1CLK clock frequency */
;;;887      if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
;;;888      {
;;;889        /* I2C1 Clock is HSI Osc. */
;;;890        RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
;;;891      }
;;;892      else
;;;893      {
;;;894        /* I2C1 Clock is System Clock */
;;;895        RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;896      }
;;;897    
;;;898      /* I2C2CLK clock frequency */
;;;899      if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
;;;900      {
;;;901        /* I2C2 Clock is HSI Osc. */
;;;902        RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
;;;903      }
;;;904      else
;;;905      {
;;;906        /* I2C2 Clock is System Clock */
;;;907        RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;908      }
;;;909      
;;;910        /* TIM1CLK clock frequency */
;;;911      if(((RCC->CFGR3 & RCC_CFGR3_TIM1SW) == RCC_CFGR3_TIM1SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
;;;912      && (apb2presc == ahbpresc)) 
;;;913      {
;;;914        /* TIM1 Clock is 2 * pllclk */
;;;915        RCC_Clocks->TIM1CLK_Frequency = pllclk * 2;
;;;916      }
;;;917      else
;;;918      {
;;;919        /* TIM1 Clock is APB2 clock. */
;;;920        RCC_Clocks->TIM1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
;;;921      }
;;;922    
;;;923        /* TIM8CLK clock frequency */
;;;924      if(((RCC->CFGR3 & RCC_CFGR3_TIM8SW) == RCC_CFGR3_TIM8SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
;;;925      && (apb2presc == ahbpresc))
;;;926      {
;;;927        /* TIM8 Clock is 2 * pllclk */
;;;928        RCC_Clocks->TIM8CLK_Frequency = pllclk * 2;
;;;929      }
;;;930      else
;;;931      {
;;;932        /* TIM8 Clock is APB2 clock. */
;;;933        RCC_Clocks->TIM8CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
;;;934      }
;;;935      
;;;936      /* USART1CLK clock frequency */
;;;937      if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
;;;938      {
;;;939        /* USART Clock is PCLK */
;;;940        RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
;;;941      }
;;;942      else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
;;;943      {
;;;944        /* USART Clock is System Clock */
;;;945        RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;946      }
;;;947      else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
;;;948      {
;;;949        /* USART Clock is LSE Osc. */
;;;950        RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
;;;951      }
;;;952      else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
;;;953      {
;;;954        /* USART Clock is HSI Osc. */
;;;955        RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
;;;956      }
;;;957    
;;;958      /* USART2CLK clock frequency */
;;;959      if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
;;;960      {
;;;961        /* USART Clock is PCLK */
;;;962        RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
;;;963      }
;;;964      else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
;;;965      {
;;;966        /* USART Clock is System Clock */
;;;967        RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;968      }
;;;969      else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
;;;970      {
;;;971        /* USART Clock is LSE Osc. */
;;;972        RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
;;;973      }
;;;974      else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
;;;975      {
;;;976        /* USART Clock is HSI Osc. */
;;;977        RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
;;;978      }    
;;;979    
;;;980      /* USART3CLK clock frequency */
;;;981      if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
;;;982      {
;;;983        /* USART Clock is PCLK */
;;;984        RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
;;;985      }
;;;986      else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
;;;987      {
;;;988        /* USART Clock is System Clock */
;;;989        RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;990      }
;;;991      else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
;;;992      {
;;;993        /* USART Clock is LSE Osc. */
;;;994        RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
;;;995      }
;;;996      else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
;;;997      {
;;;998        /* USART Clock is HSI Osc. */
;;;999        RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
;;;1000     }
;;;1001     
;;;1002       /* UART4CLK clock frequency */
;;;1003     if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == 0x0)
;;;1004     {
;;;1005       /* USART Clock is PCLK */
;;;1006       RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
;;;1007     }
;;;1008     else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_0)
;;;1009     {
;;;1010       /* USART Clock is System Clock */
;;;1011       RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1012     }
;;;1013     else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_1)
;;;1014     {
;;;1015       /* USART Clock is LSE Osc. */
;;;1016       RCC_Clocks->UART4CLK_Frequency = LSE_VALUE;
;;;1017     }
;;;1018     else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW)
;;;1019     {
;;;1020       /* USART Clock is HSI Osc. */
;;;1021       RCC_Clocks->UART4CLK_Frequency = HSI_VALUE;
;;;1022     }   
;;;1023     
;;;1024     /* UART5CLK clock frequency */
;;;1025     if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == 0x0)
;;;1026     {
;;;1027       /* USART Clock is PCLK */
;;;1028       RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
;;;1029     }
;;;1030     else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_0)
;;;1031     {
;;;1032       /* USART Clock is System Clock */
;;;1033       RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1034     }
;;;1035     else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_1)
;;;1036     {
;;;1037       /* USART Clock is LSE Osc. */
;;;1038       RCC_Clocks->UART5CLK_Frequency = LSE_VALUE;
;;;1039     }
;;;1040     else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW)
;;;1041     {
;;;1042       /* USART Clock is HSI Osc. */
;;;1043       RCC_Clocks->UART5CLK_Frequency = HSI_VALUE;
;;;1044     } 
;;;1045   }
00004a  230f              MOVS     r3,#0xf
00004c  f8df91f8          LDR      r9,|L14.584|
000050  ea031111          AND      r1,r3,r1,LSR #4
000054  f8197001          LDRB     r7,[r9,r1]            ;838
000058  6801              LDR      r1,[r0,#0]            ;840
00005a  fa21f307          LSR      r3,r1,r7              ;840
00005e  6043              STR      r3,[r0,#4]            ;843
000060  f8d85004          LDR      r5,[r8,#4]            ;843
000064  2607              MOVS     r6,#7
000066  ea062515          AND      r5,r6,r5,LSR #8
00006a  f8195005          LDRB     r5,[r9,r5]            ;845
00006e  fa23f505          LSR      r5,r3,r5              ;847
000072  6085              STR      r5,[r0,#8]            ;850
000074  f8d8c004          LDR      r12,[r8,#4]           ;850
000078  ea0626dc          AND      r6,r6,r12,LSR #11
00007c  f8196006          LDRB     r6,[r9,r6]            ;852
000080  40f3              LSRS     r3,r3,r6              ;854
000082  60c3              STR      r3,[r0,#0xc]          ;857
000084  f8d8802c          LDR      r8,[r8,#0x2c]         ;857
000088  469c              MOV      r12,r3                ;854
00008a  f04f0b1f          MOV      r11,#0x1f
00008e  ea0b1318          AND      r3,r11,r8,LSR #4
000092  f1090e10          ADD      lr,r9,#0x10           ;859
000096  f83e3013          LDRH     r3,[lr,r3,LSL #1]     ;859
00009a  ea5f68c3          LSLS     r8,r3,#27             ;860
00009e  d506              BPL      |L14.174|
0000a0  fbb2f3f3          UDIV     r3,r2,r3              ;863
0000a4  6103              STR      r3,[r0,#0x10]         ;863
0000a6  e003              B        |L14.176|
                  |L14.168|
0000a8  4b68              LDR      r3,|L14.588|
0000aa  435a              MULS     r2,r3,r2              ;820
0000ac  e7c9              B        |L14.66|
                  |L14.174|
0000ae  6101              STR      r1,[r0,#0x10]         ;868
                  |L14.176|
0000b0  f8da802c          LDR      r8,[r10,#0x2c]        ;872
0000b4  46d1              MOV      r9,r10                ;872
0000b6  ea0b2358          AND      r3,r11,r8,LSR #9
0000ba  f83e3013          LDRH     r3,[lr,r3,LSL #1]     ;874
0000be  ea5f68c3          LSLS     r8,r3,#27             ;875
0000c2  d503              BPL      |L14.204|
0000c4  fbb2f3f3          UDIV     r3,r2,r3              ;878
0000c8  6143              STR      r3,[r0,#0x14]         ;878
0000ca  e000              B        |L14.206|
                  |L14.204|
0000cc  6141              STR      r1,[r0,#0x14]         ;883
                  |L14.206|
0000ce  f8d98030          LDR      r8,[r9,#0x30]         ;887
0000d2  464b              MOV      r3,r9                 ;887
0000d4  ea5f68c8          LSLS     r8,r8,#27             ;887
0000d8  d401              BMI      |L14.222|
0000da  6184              STR      r4,[r0,#0x18]         ;890
0000dc  e000              B        |L14.224|
                  |L14.222|
0000de  6181              STR      r1,[r0,#0x18]         ;895
                  |L14.224|
0000e0  f8d38030          LDR      r8,[r3,#0x30]         ;899
0000e4  ea5f6888          LSLS     r8,r8,#26             ;899
0000e8  d401              BMI      |L14.238|
0000ea  61c4              STR      r4,[r0,#0x1c]         ;902
0000ec  e000              B        |L14.240|
                  |L14.238|
0000ee  61c1              STR      r1,[r0,#0x1c]         ;907
                  |L14.240|
0000f0  f8d38030          LDR      r8,[r3,#0x30]         ;911
0000f4  ea5f58c8          LSLS     r8,r8,#23             ;911
0000f8  d508              BPL      |L14.268|
0000fa  4291              CMP      r1,r2                 ;911
0000fc  d106              BNE      |L14.268|
0000fe  42be              CMP      r6,r7                 ;912
000100  d104              BNE      |L14.268|
000102  ea4f0842          LSL      r8,r2,#1              ;915
000106  f8c08020          STR      r8,[r0,#0x20]         ;915
00010a  e001              B        |L14.272|
                  |L14.268|
00010c  f8c0c020          STR      r12,[r0,#0x20]        ;920
                  |L14.272|
000110  f8d38030          LDR      r8,[r3,#0x30]         ;924
000114  ea5f5888          LSLS     r8,r8,#22             ;924
000118  d506              BPL      |L14.296|
00011a  4291              CMP      r1,r2                 ;924
00011c  d104              BNE      |L14.296|
00011e  42be              CMP      r6,r7                 ;925
000120  d102              BNE      |L14.296|
000122  0052              LSLS     r2,r2,#1              ;928
000124  6242              STR      r2,[r0,#0x24]         ;928
000126  e001              B        |L14.300|
                  |L14.296|
000128  f8c0c024          STR      r12,[r0,#0x24]        ;933
                  |L14.300|
00012c  6b1a              LDR      r2,[r3,#0x30]         ;937
00012e  0796              LSLS     r6,r2,#30             ;937
000130  f44f4200          MOV      r2,#0x8000            ;950
000134  d00e              BEQ      |L14.340|
000136  6b1e              LDR      r6,[r3,#0x30]         ;942
000138  f0060603          AND      r6,r6,#3              ;942
00013c  2e01              CMP      r6,#1                 ;942
00013e  d00c              BEQ      |L14.346|
000140  6b1e              LDR      r6,[r3,#0x30]         ;947
000142  f0060603          AND      r6,r6,#3              ;947
000146  2e02              CMP      r6,#2                 ;947
000148  d009              BEQ      |L14.350|
00014a  6b1e              LDR      r6,[r3,#0x30]         ;952
00014c  43f6              MVNS     r6,r6                 ;952
00014e  07b6              LSLS     r6,r6,#30             ;952
000150  d007              BEQ      |L14.354|
000152  e007              B        |L14.356|
                  |L14.340|
000154  f8c0c028          STR      r12,[r0,#0x28]        ;940
000158  e004              B        |L14.356|
                  |L14.346|
00015a  6281              STR      r1,[r0,#0x28]         ;945
00015c  e002              B        |L14.356|
                  |L14.350|
00015e  6282              STR      r2,[r0,#0x28]         ;950
000160  e000              B        |L14.356|
                  |L14.354|
000162  6284              STR      r4,[r0,#0x28]         ;955
                  |L14.356|
000164  6b1e              LDR      r6,[r3,#0x30]         ;959
000166  f4163f40          TST      r6,#0x30000           ;959
00016a  d00f              BEQ      |L14.396|
00016c  6b1e              LDR      r6,[r3,#0x30]         ;964
00016e  f3c64601          UBFX     r6,r6,#16,#2          ;964
000172  2e01              CMP      r6,#1                 ;964
000174  d00c              BEQ      |L14.400|
000176  6b1e              LDR      r6,[r3,#0x30]         ;969
000178  f3c64601          UBFX     r6,r6,#16,#2          ;969
00017c  2e02              CMP      r6,#2                 ;969
00017e  d009              BEQ      |L14.404|
000180  6b1e              LDR      r6,[r3,#0x30]         ;974
000182  f3c64601          UBFX     r6,r6,#16,#2          ;974
000186  2e03              CMP      r6,#3                 ;974
000188  d006              BEQ      |L14.408|
00018a  e006              B        |L14.410|
                  |L14.396|
00018c  62c5              STR      r5,[r0,#0x2c]         ;962
00018e  e004              B        |L14.410|
                  |L14.400|
000190  62c1              STR      r1,[r0,#0x2c]         ;967
000192  e002              B        |L14.410|
                  |L14.404|
000194  62c2              STR      r2,[r0,#0x2c]         ;972
000196  e000              B        |L14.410|
                  |L14.408|
000198  62c4              STR      r4,[r0,#0x2c]         ;977
                  |L14.410|
00019a  6b1e              LDR      r6,[r3,#0x30]         ;981
00019c  f4162f40          TST      r6,#0xc0000           ;981
0001a0  d00f              BEQ      |L14.450|
0001a2  6b1e              LDR      r6,[r3,#0x30]         ;986
0001a4  f3c64681          UBFX     r6,r6,#18,#2          ;986
0001a8  2e01              CMP      r6,#1                 ;986
0001aa  d00c              BEQ      |L14.454|
0001ac  6b1e              LDR      r6,[r3,#0x30]         ;991
0001ae  f3c64681          UBFX     r6,r6,#18,#2          ;991
0001b2  2e02              CMP      r6,#2                 ;991
0001b4  d009              BEQ      |L14.458|
0001b6  6b1e              LDR      r6,[r3,#0x30]         ;996
0001b8  f3c64681          UBFX     r6,r6,#18,#2          ;996
0001bc  2e03              CMP      r6,#3                 ;996
0001be  d006              BEQ      |L14.462|
0001c0  e006              B        |L14.464|
                  |L14.450|
0001c2  6305              STR      r5,[r0,#0x30]         ;984
0001c4  e004              B        |L14.464|
                  |L14.454|
0001c6  6301              STR      r1,[r0,#0x30]         ;989
0001c8  e002              B        |L14.464|
                  |L14.458|
0001ca  6302              STR      r2,[r0,#0x30]         ;994
0001cc  e000              B        |L14.464|
                  |L14.462|
0001ce  6304              STR      r4,[r0,#0x30]         ;999
                  |L14.464|
0001d0  6b1e              LDR      r6,[r3,#0x30]         ;1003
0001d2  f4161f40          TST      r6,#0x300000          ;1003
0001d6  d00f              BEQ      |L14.504|
0001d8  6b1e              LDR      r6,[r3,#0x30]         ;1008
0001da  f3c65601          UBFX     r6,r6,#20,#2          ;1008
0001de  2e01              CMP      r6,#1                 ;1008
0001e0  d00c              BEQ      |L14.508|
0001e2  6b1e              LDR      r6,[r3,#0x30]         ;1013
0001e4  f3c65601          UBFX     r6,r6,#20,#2          ;1013
0001e8  2e02              CMP      r6,#2                 ;1013
0001ea  d009              BEQ      |L14.512|
0001ec  6b1e              LDR      r6,[r3,#0x30]         ;1018
0001ee  f3c65601          UBFX     r6,r6,#20,#2          ;1018
0001f2  2e03              CMP      r6,#3                 ;1018
0001f4  d006              BEQ      |L14.516|
0001f6  e006              B        |L14.518|
                  |L14.504|
0001f8  6345              STR      r5,[r0,#0x34]         ;1006
0001fa  e004              B        |L14.518|
                  |L14.508|
0001fc  6341              STR      r1,[r0,#0x34]         ;1011
0001fe  e002              B        |L14.518|
                  |L14.512|
000200  6342              STR      r2,[r0,#0x34]         ;1016
000202  e000              B        |L14.518|
                  |L14.516|
000204  6344              STR      r4,[r0,#0x34]         ;1021
                  |L14.518|
000206  6b1e              LDR      r6,[r3,#0x30]         ;1025
000208  f4160f40          TST      r6,#0xc00000          ;1025
00020c  d011              BEQ      |L14.562|
00020e  6b1d              LDR      r5,[r3,#0x30]         ;1030
000210  f3c55581          UBFX     r5,r5,#22,#2          ;1030
000214  2d01              CMP      r5,#1                 ;1030
000216  d00e              BEQ      |L14.566|
000218  6b19              LDR      r1,[r3,#0x30]         ;1035
00021a  f3c15181          UBFX     r1,r1,#22,#2          ;1035
00021e  2902              CMP      r1,#2                 ;1035
000220  d00b              BEQ      |L14.570|
000222  6b19              LDR      r1,[r3,#0x30]         ;1040
000224  f3c15181          UBFX     r1,r1,#22,#2          ;1040
000228  2903              CMP      r1,#3                 ;1040
00022a  d100              BNE      |L14.558|
00022c  6384              STR      r4,[r0,#0x38]         ;1043
                  |L14.558|
00022e  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.562|
000232  6385              STR      r5,[r0,#0x38]         ;1028
000234  e7fb              B        |L14.558|
                  |L14.566|
000236  6381              STR      r1,[r0,#0x38]         ;1033
000238  e7f9              B        |L14.558|
                  |L14.570|
00023a  6382              STR      r2,[r0,#0x38]         ;1038
00023c  e7f7              B        |L14.558|
;;;1046   
                          ENDP

00023e  0000              DCW      0x0000
                  |L14.576|
                          DCD      0x40021000
                  |L14.580|
                          DCD      0x007a1200
                  |L14.584|
                          DCD      ||.data||
                  |L14.588|
                          DCD      0x003d0900

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1643     */
;;;1644   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4603              MOV      r3,r0
;;;1645   {
;;;1646     uint32_t tmp = 0;
;;;1647     uint32_t statusreg = 0;
;;;1648     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1649   
;;;1650     /* Check the parameters */
;;;1651     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1652   
;;;1653     /* Get the RCC register index */
;;;1654     tmp = RCC_FLAG >> 5;
;;;1655   
;;;1656      if (tmp == 0)               /* The flag to check is in CR register */
;;;1657     {
;;;1658       statusreg = RCC->CR;
000004  4a0a              LDR      r2,|L15.48|
000006  0959              LSRS     r1,r3,#5              ;1654
000008  d00c              BEQ      |L15.36|
;;;1659     }
;;;1660     else if (tmp == 1)          /* The flag to check is in BDCR register */
00000a  2901              CMP      r1,#1
00000c  d00c              BEQ      |L15.40|
;;;1661     {
;;;1662       statusreg = RCC->BDCR;
;;;1663     }
;;;1664     else if (tmp == 4)          /* The flag to check is in CFGR register */
00000e  2904              CMP      r1,#4
000010  d00c              BEQ      |L15.44|
;;;1665     {
;;;1666       statusreg = RCC->CFGR;
;;;1667     }
;;;1668     else                       /* The flag to check is in CSR register */
;;;1669     {
;;;1670       statusreg = RCC->CSR;
000012  6a51              LDR      r1,[r2,#0x24]
                  |L15.20|
;;;1671     }
;;;1672   
;;;1673     /* Get the flag position */
;;;1674     tmp = RCC_FLAG & FLAG_MASK;
000014  f003021f          AND      r2,r3,#0x1f
;;;1675   
;;;1676     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000018  2301              MOVS     r3,#1
00001a  4093              LSLS     r3,r3,r2
00001c  420b              TST      r3,r1
00001e  d000              BEQ      |L15.34|
;;;1677     {
;;;1678       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L15.34|
;;;1679     }
;;;1680     else
;;;1681     {
;;;1682       bitstatus = RESET;
;;;1683     }
;;;1684     /* Return the flag status */
;;;1685     return bitstatus;
;;;1686   }
000022  4770              BX       lr
                  |L15.36|
000024  6811              LDR      r1,[r2,#0]            ;1658
000026  e7f5              B        |L15.20|
                  |L15.40|
000028  6a11              LDR      r1,[r2,#0x20]         ;1662
00002a  e7f3              B        |L15.20|
                  |L15.44|
00002c  6851              LDR      r1,[r2,#4]            ;1666
00002e  e7f1              B        |L15.20|
;;;1687   
                          ENDP

                  |L15.48|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1712     */
;;;1713   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L16.16|
;;;1714   {
000002  4601              MOV      r1,r0
;;;1715     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1716     
;;;1717     /* Check the parameters */
;;;1718     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1719     
;;;1720     /* Check the status of the specified RCC interrupt */
;;;1721     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L16.14|
;;;1722     {
;;;1723       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L16.14|
;;;1724     }
;;;1725     else
;;;1726     {
;;;1727       bitstatus = RESET;
;;;1728     }
;;;1729     /* Return the RCC_IT status */
;;;1730     return  bitstatus;
;;;1731   }
00000e  4770              BX       lr
;;;1732   
                          ENDP

                  |L16.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;651      */
;;;652    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L17.12|
;;;653    {
;;;654      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;655    }
000008  4770              BX       lr
;;;656    
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;676      */
;;;677    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L18.16|
;;;678    {
;;;679      uint32_t tmpreg = 0;
;;;680      
;;;681      /* Check the parameters */
;;;682      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;683      
;;;684      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;685      
;;;686      /* Clear HPRE[3:0] bits */
;;;687      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;688      
;;;689      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;690      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;691      
;;;692      /* Store the new value */
;;;693      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;694    }
00000c  4770              BX       lr
;;;695    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;235      */
;;;236    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L19.12|
;;;237    {
;;;238      /* Check the parameters */
;;;239      assert_param(IS_RCC_HSE(RCC_HSE));
;;;240    
;;;241      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;242      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  708a              STRB     r2,[r1,#2]
;;;243    
;;;244      /* Set the new HSE configuration -------------------------------------------*/
;;;245      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
000006  7088              STRB     r0,[r1,#2]
;;;246    
;;;247    }
000008  4770              BX       lr
;;;248    
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;328      */
;;;329    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;330    {
;;;331      /* Check the parameters */
;;;332      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;333      
;;;334      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;335    }
000004  4770              BX       lr
;;;336    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42420000

                          AREA ||i.RCC_I2CCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2CCLKConfig PROC
;;;1138     */
;;;1139   void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
000000  4906              LDR      r1,|L21.28|
;;;1140   { 
;;;1141     uint32_t tmp = 0;
;;;1142     
;;;1143     /* Check the parameters */
;;;1144     assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
;;;1145   
;;;1146     tmp = (RCC_I2CCLK >> 28);
000002  0f02              LSRS     r2,r0,#28
;;;1147     
;;;1148     /* Clear I2CSW bit */
;;;1149     if (tmp != 0)
;;;1150     {
;;;1151       RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
;;;1152     }
;;;1153     else
;;;1154     {
;;;1155       RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
000004  6b0a              LDR      r2,[r1,#0x30]
000006  d002              BEQ      |L21.14|
000008  f0220220          BIC      r2,r2,#0x20           ;1151
00000c  e001              B        |L21.18|
                  |L21.14|
00000e  f0220210          BIC      r2,r2,#0x10
                  |L21.18|
000012  630a              STR      r2,[r1,#0x30]
;;;1156     }
;;;1157     /* Set I2CSW bits according to RCC_I2CCLK value */
;;;1158     RCC->CFGR3 |= RCC_I2CCLK;
000014  6b0a              LDR      r2,[r1,#0x30]
000016  4302              ORRS     r2,r2,r0
000018  630a              STR      r2,[r1,#0x30]
;;;1159   }
00001a  4770              BX       lr
;;;1160   
                          ENDP

                  |L21.28|
                          DCD      0x40021000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1303     */
;;;1304   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L22.8|
;;;1305   {
;;;1306     /* Check the parameters */
;;;1307     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1308   
;;;1309     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  f8c100dc          STR      r0,[r1,#0xdc]
;;;1310   }
000006  4770              BX       lr
;;;1311   
                          ENDP

                  |L22.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1606     */
;;;1607   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L23.20|
;;;1608   {
;;;1609     /* Check the parameters */
;;;1610     assert_param(IS_RCC_IT(RCC_IT));
;;;1611     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1612     
;;;1613     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1614     {
;;;1615       /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
;;;1616       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;1617     }
;;;1618     else
;;;1619     {
;;;1620       /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
;;;1621       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  d001              BEQ      |L23.12|
000008  4301              ORRS     r1,r1,r0              ;1616
00000a  e000              B        |L23.14|
                  |L23.12|
00000c  4381              BICS     r1,r1,r0
                  |L23.14|
00000e  7251              STRB     r1,[r2,#9]            ;1616
;;;1622     }
;;;1623   }
000010  4770              BX       lr
;;;1624   
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;353      */
;;;354    void RCC_LSEConfig(uint32_t RCC_LSE)
000000  4906              LDR      r1,|L24.28|
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_RCC_LSE(RCC_LSE));
;;;358    
;;;359      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;360      /* Reset LSEON bit */
;;;361      RCC->BDCR &= ~(RCC_BDCR_LSEON);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
;;;362    
;;;363      /* Reset LSEBYP bit */
;;;364      RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  f0220204          BIC      r2,r2,#4
000010  620a              STR      r2,[r1,#0x20]
;;;365    
;;;366      /* Configure LSE */
;;;367      RCC->BDCR |= RCC_LSE;
000012  6a0a              LDR      r2,[r1,#0x20]
000014  4302              ORRS     r2,r2,r0
000016  620a              STR      r2,[r1,#0x20]
;;;368    }
000018  4770              BX       lr
;;;369    
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEDriveConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEDriveConfig PROC
;;;379      */
;;;380    void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
000000  4904              LDR      r1,|L25.20|
;;;381    {
;;;382      /* Check the parameters */
;;;383      assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
;;;384      
;;;385      /* Clear LSEDRV[1:0] bits */
;;;386      RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220218          BIC      r2,r2,#0x18
000008  620a              STR      r2,[r1,#0x20]
;;;387    
;;;388      /* Set the LSE Drive */
;;;389      RCC->BDCR |= RCC_LSEDrive;
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  4302              ORRS     r2,r2,r0
00000e  620a              STR      r2,[r1,#0x20]
;;;390    }
000010  4770              BX       lr
;;;391    
                          ENDP

000012  0000              DCW      0x0000
                  |L25.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;403      */
;;;404    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;405    {
;;;406      /* Check the parameters */
;;;407      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;408      
;;;409      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;410    }
000004  4770              BX       lr
;;;411    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;517      */
;;;518    void RCC_MCOConfig(uint8_t RCC_MCOSource)
000000  4901              LDR      r1,|L27.8|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
;;;522        
;;;523      /* Select MCO clock source and prescaler */
;;;524      *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
000002  71c8              STRB     r0,[r1,#7]
;;;525    }
000004  4770              BX       lr
;;;526    
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;707      */
;;;708    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L28.16|
;;;709    {
;;;710      uint32_t tmpreg = 0;
;;;711      
;;;712      /* Check the parameters */
;;;713      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;714      
;;;715      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;716      /* Clear PPRE1[2:0] bits */
;;;717      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42161e0          BIC      r1,r1,#0x700
;;;718      
;;;719      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;720      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;721      
;;;722      /* Store the new value */
;;;723      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;724    }
00000c  4770              BX       lr
;;;725    
                          ENDP

00000e  0000              DCW      0x0000
                  |L28.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;737      */
;;;738    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L29.16|
;;;739    {
;;;740      uint32_t tmpreg = 0;
;;;741      
;;;742      /* Check the parameters */
;;;743      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;744      
;;;745      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;746      /* Clear PPRE2[2:0] bits */
;;;747      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4225260          BIC      r2,r2,#0x3800
;;;748      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;749      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;750      /* Store the new value */
;;;751      RCC->CFGR = tmpreg;
00000c  6048              STR      r0,[r1,#4]
;;;752    }
00000e  4770              BX       lr
;;;753    
                          ENDP

                  |L29.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;450      */
;;;451    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L30.8|
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;455    
;;;456      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;457    }
000004  4770              BX       lr
;;;458    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;426      */
;;;427    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4a04              LDR      r2,|L31.20|
;;;428    {
;;;429      /* Check the parameters */
;;;430      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;431      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;432      
;;;433      /* Clear PLL Source [16] and Multiplier [21:18] bits */
;;;434      RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
000002  6853              LDR      r3,[r2,#4]
000004  f4231374          BIC      r3,r3,#0x3d0000
000008  6053              STR      r3,[r2,#4]
;;;435    
;;;436      /* Set the PLL Source and Multiplier */
;;;437      RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
00000a  6853              LDR      r3,[r2,#4]
00000c  4308              ORRS     r0,r0,r1
00000e  4303              ORRS     r3,r3,r0
000010  6053              STR      r3,[r2,#4]
;;;438    }
000012  4770              BX       lr
;;;439    
                          ENDP

                  |L31.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PREDIV1Config||, CODE, READONLY, ALIGN=2

                  RCC_PREDIV1Config PROC
;;;465      */
;;;466    void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
000000  4a03              LDR      r2,|L32.16|
;;;467    {
;;;468      uint32_t tmpreg = 0;
;;;469      
;;;470      /* Check the parameters */
;;;471      assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
;;;472    
;;;473      tmpreg = RCC->CFGR2;
000002  6ad1              LDR      r1,[r2,#0x2c]
;;;474      /* Clear PREDIV1[3:0] bits */
;;;475      tmpreg &= ~(RCC_CFGR2_PREDIV1);
000004  f021010f          BIC      r1,r1,#0xf
;;;476    
;;;477      /* Set the PREDIV1 division factor */
;;;478      tmpreg |= RCC_PREDIV1_Div;
000008  4301              ORRS     r1,r1,r0
;;;479    
;;;480      /* Store the new value */
;;;481      RCC->CFGR2 = tmpreg;
00000a  62d1              STR      r1,[r2,#0x2c]
;;;482    }
00000c  4770              BX       lr
;;;483    
                          ENDP

00000e  0000              DCW      0x0000
                  |L32.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1319     */
;;;1320   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L33.8|
;;;1321   {
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1324     
;;;1325     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1326   }
000004  4770              BX       lr
;;;1327   
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1284     */
;;;1285   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L34.12|
;;;1286   {
;;;1287     /* Check the parameters */
;;;1288     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1289     
;;;1290     /* Select the RTC clock source */
;;;1291     RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;1292   }
000008  4770              BX       lr
;;;1293   
                          ENDP

00000a  0000              DCW      0x0000
                  |L34.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;623      */
;;;624    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L35.16|
;;;625    {
;;;626      uint32_t tmpreg = 0;
;;;627      
;;;628      /* Check the parameters */
;;;629      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;630      
;;;631      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;632      
;;;633      /* Clear SW[1:0] bits */
;;;634      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;635      
;;;636      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;637      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;638      
;;;639      /* Store the new value */
;;;640      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;641    }
00000c  4770              BX       lr
;;;642    
                          ENDP

00000e  0000              DCW      0x0000
                  |L35.16|
                          DCD      0x40021000

                          AREA ||i.RCC_TIMCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_TIMCLKConfig PROC
;;;1174     */
;;;1175   void RCC_TIMCLKConfig(uint32_t RCC_TIMCLK)
000000  4906              LDR      r1,|L36.28|
;;;1176   { 
;;;1177     uint32_t tmp = 0;
;;;1178     
;;;1179     /* Check the parameters */
;;;1180     assert_param(IS_RCC_TIMCLK(RCC_TIMCLK));
;;;1181   
;;;1182     tmp = (RCC_TIMCLK >> 28);
000002  0f02              LSRS     r2,r0,#28
;;;1183     
;;;1184     /* Clear I2CSW bit */
;;;1185     if (tmp != 0)
;;;1186     {
;;;1187       RCC->CFGR3 &= ~RCC_CFGR3_TIM8SW;
;;;1188     }
;;;1189     else
;;;1190     {
;;;1191       RCC->CFGR3 &= ~RCC_CFGR3_TIM1SW;
000004  6b0a              LDR      r2,[r1,#0x30]
000006  d002              BEQ      |L36.14|
000008  f4227200          BIC      r2,r2,#0x200          ;1187
00000c  e001              B        |L36.18|
                  |L36.14|
00000e  f4227280          BIC      r2,r2,#0x100
                  |L36.18|
000012  630a              STR      r2,[r1,#0x30]
;;;1192     }
;;;1193     /* Set I2CSW bits according to RCC_TIMCLK value */
;;;1194     RCC->CFGR3 |= RCC_TIMCLK;
000014  6b0a              LDR      r2,[r1,#0x30]
000016  4302              ORRS     r2,r2,r0
000018  630a              STR      r2,[r1,#0x30]
;;;1195   }
00001a  4770              BX       lr
;;;1196   
                          ENDP

                  |L36.28|
                          DCD      0x40021000

                          AREA ||i.RCC_USARTCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USARTCLKConfig PROC
;;;1208     */
;;;1209   void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
000000  0f02              LSRS     r2,r0,#28
;;;1210   { 
;;;1211     uint32_t tmp = 0;
;;;1212     
;;;1213     /* Check the parameters */
;;;1214     assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
;;;1215   
;;;1216     tmp = (RCC_USARTCLK >> 28);
;;;1217   
;;;1218     /* Clear USARTSW[1:0] bit */
;;;1219     switch (tmp)
;;;1220     {
;;;1221       case 0x01:  /* clear USART1SW */
;;;1222         RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
000002  4910              LDR      r1,|L37.68|
000004  2a06              CMP      r2,#6                 ;1219
000006  d20c              BCS      |L37.34|
000008  e8dff002          TBB      [pc,r2]               ;1219
00000c  0b03070f          DCB      0x0b,0x03,0x07,0x0f
000010  1317              DCB      0x13,0x17
000012  6b0a              LDR      r2,[r1,#0x30]
000014  f0220203          BIC      r2,r2,#3
;;;1223         break;
000018  e002              B        |L37.32|
;;;1224       case 0x02:  /* clear USART2SW */
;;;1225         RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
00001a  6b0a              LDR      r2,[r1,#0x30]
00001c  f4223240          BIC      r2,r2,#0x30000
                  |L37.32|
000020  630a              STR      r2,[r1,#0x30]         ;1222
                  |L37.34|
;;;1226         break;
;;;1227       case 0x03:  /* clear USART3SW */
;;;1228         RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
;;;1229         break;
;;;1230       case 0x04:  /* clear UART4SW */
;;;1231         RCC->CFGR3 &= ~RCC_CFGR3_UART4SW;
;;;1232         break;
;;;1233       case 0x05:  /* clear UART5SW */
;;;1234         RCC->CFGR3 &= ~RCC_CFGR3_UART5SW;
;;;1235         break;
;;;1236       default:
;;;1237         break;
;;;1238     }
;;;1239   
;;;1240     /* Set USARTSW bits according to RCC_USARTCLK value */
;;;1241     RCC->CFGR3 |= RCC_USARTCLK;
000022  6b0a              LDR      r2,[r1,#0x30]
000024  4302              ORRS     r2,r2,r0
000026  630a              STR      r2,[r1,#0x30]
;;;1242   }
000028  4770              BX       lr
00002a  6b0a              LDR      r2,[r1,#0x30]         ;1228
00002c  f4222240          BIC      r2,r2,#0xc0000        ;1228
000030  e7f6              B        |L37.32|
000032  6b0a              LDR      r2,[r1,#0x30]         ;1231
000034  f4221240          BIC      r2,r2,#0x300000       ;1231
000038  e7f2              B        |L37.32|
00003a  6b0a              LDR      r2,[r1,#0x30]         ;1234
00003c  f4220240          BIC      r2,r2,#0xc00000       ;1234
000040  e7ee              B        |L37.32|
;;;1243   
                          ENDP

000042  0000              DCW      0x0000
                  |L37.68|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;1253     */
;;;1254   void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L38.8|
;;;1255   {
;;;1256     /* Check the parameters */
;;;1257     assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;1258   
;;;1259     *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  f8c100d8          STR      r0,[r1,#0xd8]
;;;1260   }
000006  4770              BX       lr
;;;1261   
                          ENDP

                  |L38.8|
                          DCD      0x42420000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;260      */
;;;261    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;262    {
;;;263      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
;;;264      ErrorStatus status = ERROR;
;;;265      FlagStatus HSEStatus = RESET;
;;;266      
;;;267      /* Wait till HSE is ready and if timeout is reached exit */
;;;268      do
;;;269      {
;;;270        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;271        StartUpCounter++;  
;;;272      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L39.10|
00000a  2011              MOVS     r0,#0x11              ;270
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;271
000012  1c49              ADDS     r1,r1,#1              ;271
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L39.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L39.10|
                  |L39.30|
;;;273      
;;;274      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2011              MOVS     r0,#0x11
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L39.42|
;;;275      {
;;;276        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L39.42|
;;;277      }
;;;278      else
;;;279      {
;;;280        status = ERROR;
;;;281      }  
;;;282      return (status);
;;;283    }
00002a  bd18              POP      {r3,r4,pc}
;;;284    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  00000001          DCW      0x0000,0x0001
000014  00020004          DCW      0x0002,0x0004
000018  00060008          DCW      0x0006,0x0008
00001c  000a000c          DCW      0x000a,0x000c
000020  00100020          DCW      0x0010,0x0020
000024  00400080          DCW      0x0040,0x0080
000028  0100              DCW      0x0100

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F30x_StdPeriph_Driver\\src\\stm32f30x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_rcc_c_49e27980____REV16|
#line 114 "..\\..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f30x_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f30x_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f30x_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
